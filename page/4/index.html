<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="iOS 修炼中...">
<meta property="og:type" content="website">
<meta property="og:title" content="以梦为马">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="以梦为马">
<meta property="og:description" content="iOS 修炼中...">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以梦为马">
<meta name="twitter:description" content="iOS 修炼中...">






  <link rel="canonical" href="http://yoursite.com/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以梦为马</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以梦为马</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">谨以此纪念岁月</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之 - 微信支付/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之 - 微信支付/" itemprop="url">
                  iOS开发之 - 微信支付
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/2665449-0d0a74ab4c5830ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS开发之 - 微信支付"></p>
<blockquote>
<p>作为 iOS 开发者，支付无疑是很重要的，特别是这两年几乎到处都是微信支付、支付宝支付。相比支付宝支付，觉得微信支付还算简单，但还是建议预先看下<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=9_1" target="_blank" rel="noopener">文档</a>。开始说文章的内容吧，这篇文章主要分为四个部分：创建应用、了解支付的流程、集成微信SDK，最后是实现支付的demo。</p>
</blockquote>
<ul>
<li><strong>第一步：创建应用</strong></li>
</ul>
<p><em>通常来说注册APP这样的事情是部门经理做的，所以这一步也可以忽略～～～</em></p>
<p>在 <a href="https://open.weixin.qq.com/cgi-bin/index?t=home/index&amp;lang=zh_CN&amp;token=0ebf4697e5671e8567a5c5f4682a4c6cb0fcaa92" target="_blank" rel="noopener">微信开放平台</a> 的管理中心 <a href="https://open.weixin.qq.com/cgi-bin/frame?t=home/app_tmpl&amp;lang=zh_CN" target="_blank" rel="noopener">创建一个应用。</a>此应用官方称七日内审核通过，一般都是三四天！而关于填写经营信息、填写商户信息、填写对公帐号信息在这里就忽略不写了。有兴趣的朋友可以了解下<a href="http://494075592.blog.51cto.com/10682677/1701260" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-723d6f42f6b41ba2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建应用"></p>
<ul>
<li><strong>第二步：了解支付的流程</strong></li>
</ul>
<p>如果做过其它支付，就会发现这些流程其实都差不多，就像我们平时用手机支付买东西一样。下边的流程两分钟大概就能读完，很容易理解！</p>
<p>1&gt; 用户使用 APP 客户端，选择商品下单。<br>2&gt; APP 客户端将用户的商品数据传给商户服务器，请求生成支付订单。<br>3&gt; 商户后台调用统一下单 API 向微信的服务器发送请求，微信服务器生成预付单，并生成一个 prepay_id 返回给商户后台。<br>4&gt; 商户后台将这个 prepay_id 返回给商户客户端。<br>5&gt; 用户点击确认支付，这时候商户客户端调用 SDK 打开微信客户端，进行微信支付。<br>6&gt; 微信客户端向微信服务器发起支付请求并返回支付结果（他们之间交互用的就是prepay_id这个参数，微信的服务器要验证微信客户端传过去的参数是否跟第三步中生成的那个id一致）。<br>7&gt; 用户输入支付密码后，微信客户端提交支付授权，跟微信服务器交互，完成支付<br>8&gt; 微信服务器给微信客户端发送支付结果提示，并异步给商户服务器发送支付结果通知。<br>9&gt; 商户客户端通过支付结果回调接口查询支付结果，并向后台检查支付结果是否正确，后台返回支付结果。<br>10&gt; 商户客户端显示支付结果，完成订单，发货。</p>
<ul>
<li><strong>第三步：集成SDK</strong></li>
</ul>
<p>其实严格来说，这一步才是微信支付的真正开始。首先我们应该下载 <a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;lang=zh_CN" target="_blank" rel="noopener">微信SDK</a>，如有需要，还可把<a href="https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=11_1_" target="_blank" rel="noopener">【微信支付】APP支付示例</a>下载下来看看。下面是集成 SDK 的具体步骤：</p>
<p>1.把下载好的 SDK 导入工程（如下图）（我下的是OpenSDK1.7.4版本）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-a0dfa21d98e8d045.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="把下载好的 SDK 导入工程"></p>
<p>2.导入微信支付SDK依赖库（如下图）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-f4bd0524a4a2d18f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入微信支付SDK依赖库"></p>
<p>3.设置URL Scheme<br>在注册微信平台APP的时候，会给一个唯一识别标识符（APPID）,需要填写在工程中。（如下图）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-8c7b570a18293fc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置URL Scheme"></p>
<hr>
<p><em>配置好上述参数后就可以写代码了～～～</em></p>
<ul>
<li><strong>第四部：代码</strong></li>
</ul>
<p>代码分为以下步骤：</p>
<p>1.在 Appdelegate 中注册微信 APPID<br>这是首先要做的事情。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)<span class="string">application:</span>(UIApplication *)application <span class="string">didFinishLaunchingWithOptions:</span>(NSDictionary *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向微信终端注册ID</span></span><br><span class="line">[WXApi <span class="string">registerApp:</span>@<span class="string">"wx0f8d5e0eadd2d4b7"</span> <span class="string">withDescription:</span>@<span class="string">"demo test"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.获取微信支付所必要的参数<br>接着，在微信支付的.m文件中获取微信支付所必要的参数。为了提高数据安全性，下单、签名等操作一般都是在后台完成的，因此以下这些参数后台会给我们。我们主要得知道这些参数如何设置：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起微信支付，设置参数</span></span><br><span class="line">PayReq *request   = [[PayReq alloc] init];  <span class="comment">// 创建支付对象</span></span><br><span class="line">request.openID = <span class="string">@""</span>; <span class="comment">// 由用户微信号和AppID组成的唯一标识</span></span><br><span class="line">request.partnerId = <span class="string">@""</span>; <span class="comment">// 商家ID</span></span><br><span class="line">request.prepayId  = <span class="string">@""</span>; <span class="comment">// 预支付订单ID</span></span><br><span class="line">request.package   = <span class="string">@"Sign=WXPay"</span>; <span class="comment">// 数据和签名</span></span><br><span class="line">request.nonceStr  = <span class="string">@""</span>; <span class="comment">// 随机编码</span></span><br><span class="line"><span class="built_in">NSDate</span> *date = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="built_in">NSString</span> * timeSp = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)[date timeIntervalSince1970]];</span><br><span class="line"><span class="built_in">UInt32</span> timeStamp = [timeSp intValue];</span><br><span class="line">request.timeStamp = timeStamp; <span class="comment">// 时间戳</span></span><br><span class="line">request.sign = <span class="string">@""</span>; <span class="comment">// 签名，签名一般都会加密</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送请求到微信，等待微信返回 onResp</span></span><br><span class="line">[WXApi sendReq:request];</span><br></pre></td></tr></table></figure></p>
<p>3.微信支付回调<br>最后要在Appdelegate.m文件中添加微信支付结果 onResp 回调方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断发起的请求是否为微信支付，如果是就回调</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)options &#123;</span><br><span class="line"><span class="keyword">return</span> [WXApi handleOpenURL:url delegate:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - WXApiDelegate</span></span><br><span class="line"><span class="comment">// 微信支付结果回调方法</span></span><br><span class="line">- (<span class="keyword">void</span>)onResp:(BaseResp *)resp &#123;</span><br><span class="line"><span class="built_in">NSString</span> *payResoult = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>, resp.errCode];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>([resp isKindOfClass:[PayResp <span class="keyword">class</span>]])&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">WXSuccess           = 0,    成功</span></span><br><span class="line"><span class="comment">WXErrCodeCommon     = -1,    普通错误类型</span></span><br><span class="line"><span class="comment">WXErrCodeUserCancel = -2,    用户点击取消并返回</span></span><br><span class="line"><span class="comment">WXErrCodeSentFail   = -3,    发送失败</span></span><br><span class="line"><span class="comment">WXErrCodeAuthDeny   = -4,    授权失败</span></span><br><span class="line"><span class="comment">WXErrCodeUnsupport  = -5,    微信不支持</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//支付返回结果，实际支付结果需要去微信服务器端查询</span></span><br><span class="line"><span class="keyword">switch</span> (resp.errCode) &#123;</span><br><span class="line"><span class="keyword">case</span> WXSuccess:</span><br><span class="line">payResoult = <span class="string">@"支付成功"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WXErrCodeCommon:</span><br><span class="line">payResoult = <span class="string">@"支付失败"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WXErrCodeUserCancel:</span><br><span class="line">payResoult = <span class="string">@"用户点击取消并返回"</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// 错误码 以及 错误提示字符串</span></span><br><span class="line">payResoult = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"支付结果：失败！retcode = %d, retstr = %@"</span>, resp.errCode,resp.errStr];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>结束语：在开发中，微信支付常常与其它技术配合使用，比如MD5加密，AFN等等。有空闲的话会一一整理出来与大家分享！另外文章写的如果有什么错误，还请大家指出来，谢谢大家！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之 - 支付宝支付/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之 - 支付宝支付/" itemprop="url">
                  iOS开发之 - 支付宝支付
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在开发中，很多时候我们都会用到支付宝支付和微信支付，前段时间已经总结过<a href="http://www.jianshu.com/p/a17b37cb8fe3" target="_blank" rel="noopener">微信支付流程</a>，这里再说下支付宝支付（相对来说觉得支付宝有点坑），先说下支付宝支付的流程，如下图：</p>
</blockquote>
<h3 id="一、支付流程理解"><a href="#一、支付流程理解" class="headerlink" title="一、支付流程理解"></a>一、支付流程理解</h3><p>先看个图<br><img src="http://upload-images.jianshu.io/upload_images/2665449-111551cb2f5ba892.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="支付流程"></p>
<p>流程和咱们平时在手机上买东西是一样的：<br>1.用户选好商品后，点击提交订单（一般是这样），选择使用支付宝付款。<br>2.手机客户端（你做的APP）把用户选择的商品的信息传给你们后台服务器。<br>3.后台的服务器将各种数据拼接签名后生成一个签名后的字符串，回传到客户端APP上。<br>4.用户点击确认支付按钮，调用手机支付宝客户端，利用后台传过来的那个参数调起支付宝，让支付宝客户端传给他们服务器交互，进行付款。(这一步是支付宝自己完成的，安全性高)<br>5.支付宝的服务器将支付的结果（可能成功也可能不成功）返回给手机支付宝客户端和你们公司的后台服务器。<br>6.你们公司后台服务器收到后一般是更新下数据信息，手机支付宝客户端会显示一下支付成功。</p>
<h3 id="二、支付流程详解"><a href="#二、支付流程详解" class="headerlink" title="二、支付流程详解"></a>二、支付流程详解</h3><ol>
<li><p>下载支付宝SDK<br><a href="https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.B7TwKK&amp;treeId=54&amp;articleId=104509&amp;docType=1" target="_blank" rel="noopener">App支付DEMO&amp;SDK</a></p>
</li>
<li><p>进入支付平台注册应用<br><a href="https://openhome.alipay.com/platform/appCreate.htm" target="_blank" rel="noopener">创建应用</a></p>
</li>
<li><p>获取支付相关的 ‘私钥’ 和 ‘密钥’<br><a href="https://doc.open.alipay.com/doc2/detail?treeId=44&amp;articleId=103242&amp;docType=1" target="_blank" rel="noopener">RSA私钥及公钥生成</a></p>
</li>
<li><p>集成支付宝SDK<br>可以先看下<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=a219a.7386797.0.0.IGzFSR&amp;treeId=48&amp;articleId=103346&amp;docType=1" target="_blank" rel="noopener">官方集成文档</a>，下面是一些具体步骤：</p>
</li>
</ol>
<p>4.1 导入文件（如下图）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-79cac6572336637c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入相应的文件"><br>这里有一个注意点：如果不在客户端上签名，只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle和AlipaySDK.framework就行了。</p>
<p>4.2 导入相关的依赖库</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-df522e1f9642c24e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入相关的依赖库"></p>
<p>4.3 为URL Types 添加支付宝回调scheme</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-39aa192999a9d489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置回调scheme"></p>
<p>identifier必须为 alipayShare<br>URL Schemes 命名规则：ap+AppID，需要和代码中的一致</p>
<p>4.4  代码部分</p>
<ul>
<li>发送订单的方法</li>
</ul>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>payOrder:<span class="params">(NSString *)</span>orderStr</span><br><span class="line">fromScheme:<span class="params">(NSString *)</span>schemeStr</span><br><span class="line">callback:<span class="params">(CompletionBlock)</span>completionBlock;</span><br></pre></td></tr></table></figure>
<ul>
<li>在AppDelegate中处理事件回调</li>
</ul>
<p>在 APAppDelegate.m 文件中，增加引用代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;AlipaySDK/AlipaySDK.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>在@implementation AppDelegate中增加如下代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> 处理返回结果</span><br><span class="line"><span class="selector-tag">-</span> (BOOL)<span class="selector-tag">application</span><span class="selector-pseudo">:(UIApplication</span> *)<span class="selector-tag">application</span> <span class="selector-tag">openURL</span><span class="selector-pseudo">:(NSURL</span> *)<span class="selector-tag">url</span> <span class="selector-tag">sourceApplication</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">sourceApplication</span> <span class="selector-tag">annotation</span><span class="selector-pseudo">:(id)annotation</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果极简开发包不可用，会跳转支付宝钱包进行支付，需要将支付宝钱包的支付结果回传给开发包</span></span><br><span class="line"><span class="selector-tag">if</span> ([url.host <span class="attribute">isEqualToString</span>:@<span class="string">"safepay"</span>]) &#123;</span><br><span class="line"><span class="selector-attr">[[AlipaySDK defaultService]</span> <span class="selector-tag">processOrderWithPaymentResult</span><span class="selector-pseudo">:url</span> <span class="selector-tag">standbyCallback</span>:^(NSDictionary *resultDic) &#123;</span><br><span class="line"><span class="comment">//【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span></span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"result = %@"</span>,resultDic);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">if</span> ([url.host <span class="attribute">isEqualToString</span>:@<span class="string">"platformapi"</span>])&#123;<span class="comment">//支付宝钱包快登授权返回authCode</span></span><br><span class="line"></span><br><span class="line"><span class="selector-attr">[[AlipaySDK defaultService]</span> <span class="selector-tag">processAuthResult</span><span class="selector-pseudo">:url</span> <span class="selector-tag">standbyCallback</span>:^(NSDictionary *resultDic) &#123;</span><br><span class="line"><span class="comment">//【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】</span></span><br><span class="line"><span class="selector-tag">NSLog</span>(@<span class="string">"result = %@"</span>,resultDic);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">return</span> <span class="selector-tag">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>集成到这里就差不多了，另外再推荐几篇好文章：</li>
</ul>
<ol>
<li>这篇是客户端做的时候遇到的坑：<a href="http://www.mamicode.com/info-detail-1076023.html" target="_blank" rel="noopener">点这里</a>。</li>
<li>如果签名数据是在App上做的，可以参考下这篇文章，已经封装好的，<a href="http://www.360doc.com/content/15/0703/10/20918780_482317876.shtml" target="_blank" rel="noopener">点这里</a>。</li>
<li>这个是官方的集成流程，很详细，<a href="https://doc.open.alipay.com/doc2/detail.htm?spm=0.0.0.0.hEK6Hb&amp;treeId=59&amp;articleId=103675&amp;docType=1" target="_blank" rel="noopener">点这里</a>。</li>
<li><a href="http://www.jianshu.com/p/4a6232d8294b" target="_blank" rel="noopener">iOS 集成支付宝</a></li>
<li><a href="http://www.jianshu.com/p/fe56e122663e" target="_blank" rel="noopener">集成支付宝钱包支付iOS SDK的方法与经验</a></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之 - 毛玻璃&模糊视图&滤镜/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之 - 毛玻璃&模糊视图&滤镜/" itemprop="url">
                  iOS开发之 - 毛玻璃&模糊视图&滤镜
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>为了让界面更加美观，有时候我们需要将图片设置成模糊，比如下边这张图片：</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-6946c7d084d2e1ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CoreImage/CoreImage初窥"></p>
<p>这篇文章主要演示了三种模糊效果，如下：</p>
<h4 id="一、简单的毛玻璃效果："><a href="#一、简单的毛玻璃效果：" class="headerlink" title="一、简单的毛玻璃效果："></a>一、简单的毛玻璃效果：</h4><ul>
<li>原图<br><img src="http://upload-images.jianshu.io/upload_images/2665449-cb2dfce94d622fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图"></li>
</ul>
<ul>
<li><p>毛玻璃效果<br><img src="http://upload-images.jianshu.io/upload_images/2665449-df954aee7a52a2ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="毛玻璃效果"></p>
</li>
<li><p>代码如下：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreImage/CoreImage.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.imageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="keyword">self</span>.view.frame];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"1.jpg"</span>];</span><br><span class="line"><span class="keyword">self</span>.imageView.contentMode = <span class="built_in">UIViewContentModeScaleAspectFill</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.imageView];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIButton</span> *button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">button.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.view.frame.size.height - <span class="number">80</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="number">40</span>);</span><br><span class="line">[button setTitle:<span class="string">@"蒙奇·D·路飞"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">button.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</span><br><span class="line">[button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(<span class="string">"点击调用的方法"</span>) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:button];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>button 被点击时调用以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="keyword">self</span>.view.frame];</span><br><span class="line"><span class="keyword">self</span>.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"1.jpg"</span>];</span><br><span class="line"><span class="built_in">UIBlurEffect</span> *blur = [<span class="built_in">UIBlurEffect</span> effectWithStyle:<span class="built_in">UIBlurEffectStyleLight</span>];</span><br><span class="line"><span class="built_in">UIVisualEffectView</span> *visualEffectView = [[<span class="built_in">UIVisualEffectView</span> alloc] initWithEffect:blur];</span><br><span class="line">visualEffectView.frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line">[<span class="keyword">self</span>.imageView addSubview:visualEffectView];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIVibrancyEffect</span> *vibrancyEffect = [<span class="built_in">UIVibrancyEffect</span> effectForBlurEffect:blur];</span><br><span class="line"><span class="built_in">UIVisualEffectView</span> *ano = [[<span class="built_in">UIVisualEffectView</span> alloc] initWithEffect:vibrancyEffect];</span><br><span class="line">ano.frame = <span class="keyword">self</span>.view.frame;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">label.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">40</span>];</span><br><span class="line">label.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="keyword">self</span>.view.frame.size.height - <span class="number">120</span>, <span class="keyword">self</span>.view.frame.size.width, <span class="number">80</span>);</span><br><span class="line">label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">label.text = <span class="string">@"蒙奇·D·路飞"</span>;</span><br><span class="line">[visualEffectView.contentView addSubview:ano];</span><br><span class="line">[ano.contentView addSubview:label];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.imageView];</span><br></pre></td></tr></table></figure></p>
<h4 id="二、高斯模糊运动模糊等，先看效果图："><a href="#二、高斯模糊运动模糊等，先看效果图：" class="headerlink" title="二、高斯模糊运动模糊等，先看效果图："></a>二、高斯模糊运动模糊等，先看效果图：</h4><ul>
<li>原图</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-954940694c6fed53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图"></p>
<ul>
<li><p>运动模糊效果图<br><img src="http://upload-images.jianshu.io/upload_images/2665449-d27b1bd30c08f616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运动模糊"></p>
</li>
<li><p>代码如下</p>
</li>
</ul>
<p>viewDidLoad 中的代码和“简单的毛玻璃效果”中的 viewDidLoad 是一样的，这里只简单贴出 button 被点击调用的代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIImage</span> *inputImage = [<span class="built_in">CIImage</span> imageWithCGImage:<span class="keyword">self</span>.imageView.image.CGImage];</span><br><span class="line"></span><br><span class="line"><span class="comment">// CIGaussianBlur   高斯模糊</span></span><br><span class="line"><span class="comment">// CIBoxBlur        均值模糊</span></span><br><span class="line"><span class="comment">// CIDiscBlur       环形卷积模糊</span></span><br><span class="line"><span class="comment">// CIMotionBlur     运动模糊</span></span><br><span class="line"><span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIMotionBlur"</span>];</span><br><span class="line">[filter setValue:inputImage forKey:kCIInputImageKey];</span><br><span class="line">[filter setValue:@<span class="number">5</span> forKey:kCIInputRadiusKey];</span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CIImage</span> *outupImage = filter.outputImage;</span><br><span class="line"><span class="built_in">CGImageRef</span> imageRef = [context createCGImage:outupImage fromRect:outupImage.extent];</span><br><span class="line"><span class="keyword">self</span>.imageView.image= [<span class="built_in">UIImage</span> imageWithCGImage:imageRef];</span><br></pre></td></tr></table></figure></p>
<h4 id="三、滤镜效果，先看下效果图"><a href="#三、滤镜效果，先看下效果图" class="headerlink" title="三、滤镜效果，先看下效果图"></a>三、滤镜效果，先看下效果图</h4><ul>
<li><p>原图<br><img src="http://upload-images.jianshu.io/upload_images/2665449-503d38d5e10a65b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图"></p>
</li>
<li><p>“怀旧”效果图<br><img src="http://upload-images.jianshu.io/upload_images/2665449-f1196625bd86712d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="“怀旧”效果图"></p>
</li>
</ul>
<ul>
<li>代码如下</li>
</ul>
<p>viewDidLoad 中的代码和“简单的毛玻璃效果”中的 viewDidLoad 是一样的，这里也只贴出 button 被点击调用的代码<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CIContext</span> *context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CIImage</span> *inputImage = [[<span class="built_in">CIImage</span> alloc] initWithImage:<span class="keyword">self</span>.imageView.image];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 怀旧  CIPhotoEffectInstant</span></span><br><span class="line"><span class="comment">// 单色  CIPhotoEffectMono</span></span><br><span class="line"><span class="comment">// 黑白  CIPhotoEffectNoir</span></span><br><span class="line"><span class="comment">// 褪色  CIPhotoEffectFade</span></span><br><span class="line"><span class="comment">// 色调  CIPhotoEffectTonal</span></span><br><span class="line"><span class="comment">// 冲印  CIPhotoEffectProcess</span></span><br><span class="line"><span class="comment">// 岁月  CIPhotoEffectTransfer</span></span><br><span class="line"><span class="comment">// 铬黄  CIPhotoEffectChrome</span></span><br><span class="line"><span class="built_in">CIFilter</span> *filter = [<span class="built_in">CIFilter</span> filterWithName:<span class="string">@"CIPhotoEffectInstant"</span>];</span><br><span class="line">[filter setValue:inputImage forKey:kCIInputImageKey];</span><br><span class="line"><span class="built_in">CIImage</span> *result = [filter valueForKey:kCIOutputImageKey];</span><br><span class="line"><span class="built_in">CGImageRef</span> cgImage = [context createCGImage:result fromRect:[result extent]];</span><br><span class="line"><span class="built_in">UIImage</span> *resultImage = [<span class="built_in">UIImage</span> imageWithCGImage:cgImage];</span><br><span class="line"><span class="keyword">self</span>.imageView.image= [<span class="built_in">UIImage</span> imageWithCGImage:resultImage.CGImage];</span><br></pre></td></tr></table></figure></p>
<hr>
<p>这是今晚整理的 CoreImage 相关的知识，如果哪里写的有问题，欢迎大家指正！另外给大家分享一篇文章，里面有很多 iOS 9 出来的 Core Image新滤镜，<a href="http://www.cocoachina.com/ios/20151118/14253.html" target="_blank" rel="noopener">在这里。</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之 - 银联支付/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之 - 银联支付/" itemprop="url">
                  iOS开发之 - 银联支付
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前阵子看了很多篇博客，有很多朋友吐槽说银联支付怎么怎么坑，所以集成的时候小心翼翼，但集成完银联支付之后，觉得相对于支付宝支付微信支付而言，银联支付还可以说的过去。下面就来介绍一下怎样快速的集成银联支付。</p>
</blockquote>
<ul>
<li>首先，下载<a href="https://open.unionpay.com/ajweb/help/search?category=aj&amp;keyword=开发包" target="_blank" rel="noopener">银联支付SDK</a>（这个有点不好找），里面包含需要的库文件和详细的文档；下载好开发包之后，进行解压，解压成下面这样的文件</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-02336a46b0ff2407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="银联支付SDK"></p>
<ul>
<li>官方文档也在这个目录下：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-0602bf8cbd8aea0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="银联支付官方文档"></p>
<ul>
<li>下面开始集成SDK</li>
</ul>
<ol>
<li>导入文件（文件目录：app开发包/控件开发包/upmp_iphone/paymentcontrol）</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-d3b3f6332abf8f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入文件"></p>
<p>注意：记得老版本是三个文件，现在是新版本，只有两个</p>
<p>到这里的话，其实银联支付就做了一半了，是不是觉得很轻松很 easy 😉，接下来像我们 iOS 客户端再简单调用一个方法就行啦</p>
<ul>
<li>支付接口调用<br>商户App从商户服务器获取tn，当tn不为空时，调用支付接口。<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当获得的tn不为空时，调用支付接口</span></span><br><span class="line"><span class="keyword">if</span> (tn != nil &amp;&amp; tn.length &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">[[UPPaymentControl defaultControl]</span><br><span class="line"><span class="string">startPay:</span>tn</span><br><span class="line"><span class="string">fromScheme:</span>@<span class="string">"UPPay"</span></span><br><span class="line"><span class="string">mode:</span>self.tnMode</span><br><span class="line"><span class="string">viewController:</span>self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上边这个方法需要的几个参数文档上都写的有，tn 是交易流水号，fromScheme 是商户自定义协议， mode 是接入模式，viewController指的是发起调用的视图控制器。</p>
<ul>
<li>检测是否已安装银联App接口调用(这个方法可写可不写)<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">([[UPPaymentControl defaultControl] isPaymentAppInstalled])</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当判断用户手机上已安装银联App，商户客户端可以做相应个性化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<p>到这里的话，银联支付就轻松愉快的搞定了。另外银联的开发文档中给我们提供的有测试帐号，大家可以试试。那里还有支付接口回调、检查是否安装银联App的接口、返回结果接口这三个方法，大家有兴趣的话也可以试试的。集成完银联支付之后，对比下支付宝和微信，觉得还是银联比较有业界良心。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之 - 键盘处理神器 IQKeyboardManager/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之 - 键盘处理神器 IQKeyboardManager/" itemprop="url">
                  iOS开发之 - 键盘处理神器 IQKeyboardManager
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>  年后上班第一天，比较闲，上午的时候抽空整理了<code>iOS</code>开发中常用的易忘知识点：<a href="http://www.jianshu.com/p/328a4c65dc5c" target="_blank" rel="noopener">iOS开发之 - 小冷易忘知识点总结</a>，有兴趣的朋友们可以去看看。下午整理了之前用过的一个第三方库——键盘处理神器  <code>IQKeyboardManager</code>。</p>
</blockquote>
<blockquote>
<p>平常在开发中，用到输入框的地方不胜其数，当输入框位于屏幕底部时，弹起的键盘很可能覆盖输入框，导致用户看不到输入结果，体验较差…… <code>IQKeyboardManager</code> 可以很简单快捷的解决键盘遮盖输入框的问题，接下来就一起来学习一下吧。</p>
</blockquote>
<ul>
<li><p>先简单认识下 IQKeyboardManager<br>GitHub 地址：<a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">GitHub 地址</a></p>
</li>
<li><p>官方示意效果图如下：</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-85b8ad91640b23c3.gif?imageMogr2/auto-orient/strip" alt="官方示意效果图"></p>
<hr>
<p>再贴一下自己做的简单效果图☺️<br>先说下我的 Xcode 版本是：Version 8.1 (8B62)，简单起见直接在 Main.storyboard 中拖入 7 个UITextField， 每个 UITextField 都设有占位文字。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-1cabc35287b06995.gif?imageMogr2/auto-orient/strip" alt="简单效果图☺️"></p>
<hr>
<h3 id="以下是-IQKeyboardManager-的一些具体使用"><a href="#以下是-IQKeyboardManager-的一些具体使用" class="headerlink" title="以下是 IQKeyboardManager 的一些具体使用"></a>以下是 IQKeyboardManager 的一些具体使用</h3><h4 id="1-用-Cocoapod-导入或直接下载拖进去，这里方便起见直接用-Cocoapod-导入。"><a href="#1-用-Cocoapod-导入或直接下载拖进去，这里方便起见直接用-Cocoapod-导入。" class="headerlink" title="1. 用 Cocoapod  导入或直接下载拖进去，这里方便起见直接用 Cocoapod 导入。"></a>1. 用 Cocoapod  导入或直接下载拖进去，这里方便起见直接用 Cocoapod 导入。</h4><p>IQKeyboardManager 的 GitHub地址：<a href="https://github.com/hackiftekhar/IQKeyboardManager" target="_blank" rel="noopener">IQKeyboardManager 的 GitHub 地址</a></p>
<h4 id="2-在-AppDelegate-m-中导入头文件"><a href="#2-在-AppDelegate-m-中导入头文件" class="headerlink" title="2. 在 AppDelegate.m 中导入头文件"></a>2. 在 AppDelegate.m 中导入头文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;IQKeyboardManager/IQKeyboardManager.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<h4 id="3-在-AppDelegate-中设置全局属性"><a href="#3-在-AppDelegate-中设置全局属性" class="headerlink" title="3. 在 AppDelegate 中设置全局属性"></a>3. 在 AppDelegate 中设置全局属性</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line"></span><br><span class="line">IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; <span class="comment">// 获取类库的单例变量</span></span><br><span class="line"></span><br><span class="line">keyboardManager.enable = <span class="literal">YES</span>; <span class="comment">// 控制整个功能是否启用</span></span><br><span class="line"></span><br><span class="line">keyboardManager.shouldResignOnTouchOutside = <span class="literal">YES</span>; <span class="comment">// 控制点击背景是否收起键盘</span></span><br><span class="line"></span><br><span class="line">keyboardManager.shouldToolbarUsesTextFieldTintColor = <span class="literal">YES</span>; <span class="comment">// 控制键盘上的工具条文字颜色是否用户自定义</span></span><br><span class="line"></span><br><span class="line">keyboardManager.toolbarManageBehaviour = IQAutoToolbarBySubviews; <span class="comment">// 有多个输入框时，可以通过点击Toolbar 上的“前一个”“后一个”按钮来实现移动到不同的输入框</span></span><br><span class="line"></span><br><span class="line">keyboardManager.enableAutoToolbar = <span class="literal">YES</span>; <span class="comment">// 控制是否显示键盘上的工具条</span></span><br><span class="line"></span><br><span class="line">keyboardManager.shouldShowTextFieldPlaceholder = <span class="literal">YES</span>; <span class="comment">// 是否显示占位文字</span></span><br><span class="line"></span><br><span class="line">keyboardManager.placeholderFont = [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">17</span>]; <span class="comment">// 设置占位文字的字体</span></span><br><span class="line"></span><br><span class="line">keyboardManager.keyboardDistanceFromTextField = <span class="number">10.0</span>f; <span class="comment">// 输入框距离键盘的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-若某个类不需要使用-IQKeyboardManager，可以在这个类中这样设置"><a href="#4-若某个类不需要使用-IQKeyboardManager，可以在这个类中这样设置" class="headerlink" title="4. 若某个类不需要使用 IQKeyboardManager，可以在这个类中这样设置"></a>4. 若某个类不需要使用 IQKeyboardManager，可以在这个类中这样设置</h4><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillAppear:</span>(BOOL)animated &#123;</span><br><span class="line">[<span class="keyword">super</span> <span class="string">viewWillAppear:</span>animated];</span><br><span class="line">[IQKeyboardManager sharedManager].enable = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">viewWillDisappear:</span>(BOOL)animated &#123;</span><br><span class="line">[<span class="keyword">super</span> <span class="string">viewWillDisappear:</span>animated];</span><br><span class="line">[IQKeyboardManager sharedManager].enable = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-常用属性介绍"><a href="#5-常用属性介绍" class="headerlink" title="5. 常用属性介绍"></a>5. 常用属性介绍</h4><ul>
<li><code>sharedManager</code>：获取类库的单例变量</li>
<li><code>enable</code>：项目使用不使用 IQKeyboardManager 这个类库，当然，某些页面可以根据需要单独设置</li>
<li><code>shouldResignOnTouchOutside</code>：点击背景页面时是否收起键盘</li>
<li><code>shouldToolbarUsesTextFieldTintColor</code>：控制键盘上的工具条文字颜色是否用户自定义，默认为 NO</li>
<li><code>toolbarManageBehaviour</code>：有多个输入框时，可以通过点击Toolbar 上的“前一个” “后一个”按钮来实现移动到不同的输入框</li>
<li><code>enableAutoToolbar</code>：是否显示键盘上的工具条</li>
<li><code>shouldShowTextFieldPlaceholder</code>：是否显示占位文字（如果输入框有占位文字，那么在 Toolbar 中默认会显示出来）</li>
<li><code>placeholderFont</code>：占位文字的字体大小</li>
<li><code>keyboardDistanceFromTextField</code>：输入框距离键盘的距离</li>
</ul>
<h4 id="6-再推荐几篇不错的相关文章"><a href="#6-再推荐几篇不错的相关文章" class="headerlink" title="6. 再推荐几篇不错的相关文章"></a>6. 再推荐几篇不错的相关文章</h4><ul>
<li><p><a href="http://www.jianshu.com/p/01c0682003a9" target="_blank" rel="noopener">iOS开发第三方库一 IQKeyboardManager</a></p>
</li>
<li><p><a href="https://my.oschina.net/u/1418722/blog/384477" target="_blank" rel="noopener">自动处理键盘事件的第三方库 IQKeyboardManager</a></p>
</li>
<li><p><a href="http://www.jianshu.com/p/3ea3db5429f3" target="_blank" rel="noopener">iOS开发之处理键盘问题神器IQKeyboardManager</a></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发技巧 - UIViewController 基类设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发技巧 - UIViewController 基类设计/" itemprop="url">
                  iOS开发技巧 - UIViewController 基类设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在项目开发中，所有控制器里面大概都有共同的属性，比如背景色、导航栏、tarBar 的设置等等，这时我们一般都会设计出来一个 <strong><code>UIViewController</code></strong> 的基类，通常叫做 <strong><code>baseViewController</code></strong>或<strong><code>rootViewController</code></strong>，在这个类里面设置所有控制器的共同的属性，然后项目中所有的控制器再继承自这个类。</p>
</blockquote>
<h5 id="一般来说这种基类控制器里面需要做的操作有以下几个："><a href="#一般来说这种基类控制器里面需要做的操作有以下几个：" class="headerlink" title="一般来说这种基类控制器里面需要做的操作有以下几个："></a>一般来说这种基类控制器里面需要做的操作有以下几个：</h5><ul>
<li>为 APP 设置统一的背景色</li>
<li>设置是否允许控制器自动调整高度（一般是 NO）</li>
<li>自定义导航栏返回按钮</li>
<li>重新布局视图大小，及时更新视图的 frame</li>
</ul>
<p>当然还有其它的一些，毕竟这和项目的具体需求息息相关，因此还要因项目而异。我这里主要就列出基类控制器中基本的常用的一些需求，和大家分享下，希望能帮到需要的人，少走弯路；另外文章如果有不足之处，也希望各位同行能多多的交流指点。</p>
<h4 id="UIViewController-基类控制器设计步骤"><a href="#UIViewController-基类控制器设计步骤" class="headerlink" title="UIViewController 基类控制器设计步骤"></a>UIViewController 基类控制器设计步骤</h4><h6 id="首先创建一个-UIViewController-类，命名为-NNBaseViewController"><a href="#首先创建一个-UIViewController-类，命名为-NNBaseViewController" class="headerlink" title="首先创建一个 UIViewController 类，命名为 NNBaseViewController"></a>首先创建一个 <code>UIViewController</code> 类，命名为 <code>NNBaseViewController</code></h6><h6 id="接着在-NNBaseViewController-m中做一些操作"><a href="#接着在-NNBaseViewController-m中做一些操作" class="headerlink" title="接着在 NNBaseViewController.m中做一些操作"></a>接着在 <code>NNBaseViewController.m</code>中做一些操作</h6><p>1.设置应用的统一背景色</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置应用的背景色</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br></pre></td></tr></table></figure>
<p>2.将 automaticallyAdjustsScrollViewInsets 设置为NO，不然视图会下移64像素</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素</span></span><br><span class="line"><span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>3.有时候系统的返回按钮不符合应用的风格，所以就需要重写导航栏上的返回按钮</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 自定义返回按钮</span></span><br><span class="line">- (<span class="keyword">void</span>)setupLeftBarButton &#123;</span><br><span class="line"><span class="comment">// 自定义 leftBarButtonItem ，UIImageRenderingModeAlwaysOriginal 防止图片被渲染</span></span><br><span class="line"><span class="keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc]</span><br><span class="line">initWithImage:[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Back-蓝"</span>] imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>]</span><br><span class="line">style:<span class="built_in">UIBarButtonItemStylePlain</span></span><br><span class="line">target:<span class="keyword">self</span></span><br><span class="line">action:<span class="keyword">@selector</span>(leftBarButtonClick)];</span><br><span class="line"><span class="comment">// 防止返回手势失效</span></span><br><span class="line"><span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.delegate = (<span class="keyword">id</span>&lt;<span class="built_in">UIGestureRecognizerDelegate</span>&gt;)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 返回按钮的点击事件</span></span><br><span class="line">- (<span class="keyword">void</span>)leftBarButtonClick &#123;</span><br><span class="line">[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然这里需要判断一下，不然首层控制器的导航栏上也会被设置上返回按钮 <code>leftBarButtonItem</code>，我是在 <code>- (void)viewDidLoad</code> 方法中判断的。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有上级页面，有的话再调用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="meta">[</span><span class="built_in">self</span>.navigationController.viewControllers indexOfObject:<span class="built_in">self</span><span class="meta">]</span> &gt; 0) &#123;</span><br><span class="line"><span class="meta">[</span><span class="built_in">self</span> setupLeftBarButton<span class="meta">]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.接下来我们一起设置下 <code>View</code> 中视图的布局，根据视图中控件的最大的 Y 值和最大的 X 值调整 <code>View</code> 的 <code>frame</code> 。这个主要用在视图中控件比较多的时候，也需要具体分析，比如有时候应用中全是 <code>UITableView</code>，那么就不需要设置了，因为 <code>UITableView</code> 可以根据 <code>cell</code> 自动调整 <code>frame</code>。不过也有用到的时候，比如应用中需要计算高度的类有很多，那么就可以用这个统一设置，主要还是看项目需求。另外注意这个方法要放在 <code>- (void)viewWillAppear:(BOOL)animated</code>中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">[<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> baseViewHeight = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> baseViewWidth = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span>.baseView.subviews;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历视图中的所有控件，求出最大的Y值和最大的X值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> subViews) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGRectGetMaxY</span>(view.frame) &gt; baseViewHeight) &#123;</span><br><span class="line">baseViewHeight = <span class="built_in">CGRectGetMaxY</span>(view.frame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGRectGetMaxX</span>(view.frame) &gt; baseViewWidth) &#123;</span><br><span class="line">baseViewWidth = <span class="built_in">CGRectGetMaxX</span>(view.frame);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三目运算方法求出最大的宽是否大于屏幕宽，以及最大的高是否大于屏幕高</span></span><br><span class="line"><span class="built_in">CGFloat</span> NNHeight = baseViewHeight &gt; NNBaseViewSizeHeight ? baseViewHeight:NNBaseViewSizeHeight;</span><br><span class="line"><span class="built_in">CGFloat</span> NNWidth = baseViewWidth &gt; NNBaseViewSizeWidth ? baseViewWidth:NNBaseViewSizeWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.baseView.contentSize = <span class="built_in">CGSizeMake</span>(NNWidth, NNHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码块中用到了一个属性 <code>baseView</code> ， <code>baseView</code> 属于 <code>UIScrollView</code> 类，相当于一个子视图容器，所有继承自 <code>NNBaseViewController</code> 的控制器都应该把子视图添加到  <code>baseView</code>上，这样才能更新它的 <code>frame</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NNBaseViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 子视图容器 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *baseView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>另外别忘了在 <code>- (void)viewDidLoad</code> 这个方法中创建<code>baseView</code>并设置它的属性。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.baseView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height - <span class="number">64</span>)];</span><br><span class="line"><span class="comment">// 是否反弹</span></span><br><span class="line"><span class="keyword">self</span>.baseView.bounces = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 是否显示滚动指示器</span></span><br><span class="line"><span class="keyword">self</span>.baseView.showsVerticalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.baseView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.baseView];</span><br><span class="line"><span class="keyword">self</span>.baseView.contentSize = NNContentSize;</span><br></pre></td></tr></table></figure>
<p>上面便是一个基本的 <code>UIViewController</code> 的基类，具体还是要根据项目的需要来设计。</p>
<hr>
<h4 id="接下来是完整的代码："><a href="#接下来是完整的代码：" class="headerlink" title="接下来是完整的代码："></a>接下来是完整的代码：</h4><h6 id="NNBaseViewController-h"><a href="#NNBaseViewController-h" class="headerlink" title="NNBaseViewController.h"></a>NNBaseViewController.h</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NNBaseViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 子视图容器 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIScrollView</span> *baseView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h6 id="NNBaseViewController-m"><a href="#NNBaseViewController-m" class="headerlink" title="NNBaseViewController.m"></a>NNBaseViewController.m</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NNBaseViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define NNBaseViewSize self.baseView.bounds.size</span></span><br><span class="line"><span class="meta">#define NNBaseViewSizeHeight self.baseView.bounds.size.height</span></span><br><span class="line"><span class="meta">#define NNBaseViewSizeWidth self.baseView.bounds.size.width</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NNBaseViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NNBaseViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">[<span class="keyword">self</span> setupViews];</span><br><span class="line"><span class="comment">// 判断是否有上级页面，有的话再调用</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.navigationController.viewControllers indexOfObject:<span class="keyword">self</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span> setupLeftBarButton];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupViews &#123;</span><br><span class="line"><span class="comment">// 设置应用的背景色</span></span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line"><span class="comment">// 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素</span></span><br><span class="line"><span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.baseView = [[<span class="built_in">UIScrollView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">64</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.height - <span class="number">64</span>)];</span><br><span class="line"><span class="comment">// 是否反弹</span></span><br><span class="line"><span class="keyword">self</span>.baseView.bounces = <span class="literal">NO</span>;</span><br><span class="line"><span class="comment">// 是否显示滚动指示器</span></span><br><span class="line"><span class="keyword">self</span>.baseView.showsVerticalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.baseView.showsHorizontalScrollIndicator = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.baseView];</span><br><span class="line"><span class="keyword">self</span>.baseView.contentSize = NNBaseViewSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">[<span class="keyword">super</span> viewWillAppear:animated];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> baseViewHeight = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CGFloat</span> baseViewWidth = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span>.baseView.subviews;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历视图中的所有控件，求出最大的Y值和最大的X值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> subViews) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGRectGetMaxY</span>(view.frame) &gt; baseViewHeight) &#123;</span><br><span class="line">baseViewHeight = <span class="built_in">CGRectGetMaxY</span>(view.frame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CGRectGetMaxX</span>(view.frame) &gt; baseViewWidth) &#123;</span><br><span class="line">baseViewWidth = <span class="built_in">CGRectGetMaxX</span>(view.frame);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 三目运算方法求出最大的宽和最大的高</span></span><br><span class="line"><span class="built_in">CGFloat</span> NNHeight = baseViewHeight &gt; NNBaseViewSizeHeight ? baseViewHeight:NNBaseViewSizeHeight;</span><br><span class="line"><span class="built_in">CGFloat</span> NNWidth = baseViewWidth &gt; NNBaseViewSizeWidth ? baseViewWidth:NNBaseViewSizeWidth;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.baseView.contentSize = <span class="built_in">CGSizeMake</span>(NNWidth, NNHeight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 自定义返回按钮</span></span><br><span class="line">- (<span class="keyword">void</span>)setupLeftBarButton &#123;</span><br><span class="line"><span class="comment">// 自定义 leftBarButtonItem ，UIImageRenderingModeAlwaysOriginal 防止图片被渲染</span></span><br><span class="line"><span class="keyword">self</span>.navigationItem.leftBarButtonItem = [[<span class="built_in">UIBarButtonItem</span> alloc]</span><br><span class="line">initWithImage:[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"Back-蓝"</span>] imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysOriginal</span>]</span><br><span class="line">style:<span class="built_in">UIBarButtonItemStylePlain</span></span><br><span class="line">target:<span class="keyword">self</span></span><br><span class="line">action:<span class="keyword">@selector</span>(leftBarButtonClick)];</span><br><span class="line"><span class="comment">// 防止返回手势失效</span></span><br><span class="line"><span class="keyword">self</span>.navigationController.interactivePopGestureRecognizer.delegate = (<span class="keyword">id</span>&lt;<span class="built_in">UIGestureRecognizerDelegate</span>&gt;)<span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 返回按钮的点击事件</span></span><br><span class="line">- (<span class="keyword">void</span>)leftBarButtonClick &#123;</span><br><span class="line">[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之源码解析 - MBProgressHUD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之源码解析 - MBProgressHUD/" itemprop="url">
                  iOS开发之源码解析 - MBProgressHUD
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a> 是一个为 <code>APP</code> 添加 <code>HUD</code> 窗口的第三方框架，使用起来极其简单方便，关于 <code>MBProgressHUD</code> 的使用方法，<code>GitHub</code> 上有详细的说明，这里就不多加介绍了，本文主要是从源码的角度分析 <code>MBProgressHUD</code>的具体实现。</p>
</blockquote>
<ul>
<li>先来对 <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a> 有个大体的认识，这是刚从 <code>GitHub</code> 上拉下来的代码，如下图，MBProgressHUD 的主要文件只有两个：<br><br><br></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-3cbf54d2915cfc84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MBProgressHUD 源码解析"></p>
<hr>
<p>下面我们就开始分析 <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a> 的具体实现。在此之前先了解下文章的目录，本文主要有三个部分：</p>
<ol>
<li><strong>MBProgressHUD 核心 API</strong></li>
</ol>
<ul>
<li>这一部分讲的主要是 MBProgressHUD 的一些属性方法等，主要是为了对 MBProgressHUD 先有个大概的认识</li>
</ul>
<ol start="2">
<li><strong>show 系列方法</strong></li>
</ol>
<ul>
<li>这一部分主要是展示 HUD 窗口时调用的方法及代码分析</li>
</ul>
<ol start="3">
<li><strong>hide 系列方法</strong></li>
</ol>
<ul>
<li>这一部分主要是隐藏 HUD 窗口时调用的方法及代码分析</li>
</ul>
<p><br><br></p>
<p><strong>begin~~~</strong></p>
<h2 id="一、MBProgressHUD-核心-API"><a href="#一、MBProgressHUD-核心-API" class="headerlink" title="一、MBProgressHUD 核心 API"></a>一、MBProgressHUD 核心 API</h2><blockquote>
<p>这一部分讲的主要是 MBProgressHUD 的一些属性方法等，主要是为了对 MBProgressHUD 先有个大概的认识</p>
</blockquote>
<h4 id="1-1-模式"><a href="#1-1-模式" class="headerlink" title="1.1 模式"></a>1.1 模式</h4><p>首先来看看 <a href="https://github.com/jdg/MBProgressHUD" target="_blank" rel="noopener">MBProgressHUD</a> 中定义的枚举，<code>mode</code> 一共有六种显示样式：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/// 显示样式</span><br><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">MBProgressHUDMode</span>) &#123;</span><br><span class="line">/// 默认模式, 系统自带的指示器</span><br><span class="line"><span class="type">MBProgressHUDModeIndeterminate</span>,</span><br><span class="line">/// 圆形饼图</span><br><span class="line"><span class="type">MBProgressHUDModeDeterminate</span>,</span><br><span class="line">/// 水平进度条</span><br><span class="line"><span class="type">MBProgressHUDModeDeterminateHorizontalBar</span>,</span><br><span class="line">/// 圆环</span><br><span class="line"><span class="type">MBProgressHUDModeAnnularDeterminate</span>,</span><br><span class="line">/// 自定义视图</span><br><span class="line"><span class="type">MBProgressHUDModeCustomView</span>,</span><br><span class="line">/// 只显示文字</span><br><span class="line"><span class="type">MBProgressHUDModeText</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简单的效果图如下（颜色尺寸等都可以优化，我这里只是简单地示例）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-2c0e36917095f806.gif?imageMogr2/auto-orient/strip" alt="默认模式：hud.mode = MBProgressHUDModeIndeterminate"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-33d61502f23a1cb8.gif?imageMogr2/auto-orient/strip" alt="圆形饼图：hud.mode = MBProgressHUDModeDeterminate"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-137f0865dea6bc2c.gif?imageMogr2/auto-orient/strip" alt="水平进度条：hud.mode = MBProgressHUDModeDeterminateHorizontalBar"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-6813068f5afe1668.gif?imageMogr2/auto-orient/strip" alt="圆环：hud.mode = MBProgressHUDModeAnnularDeterminate"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-9afbf851e3b786ed.gif?imageMogr2/auto-orient/strip" alt="自定义视图：hud.mode = MBProgressHUDModeCustomView"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-bfa363444cff270a.gif?imageMogr2/auto-orient/strip" alt="只显示文字：hud.mode = MBProgressHUDModeText"></p>
<p><br><br></p>
<h4 id="1-2-动画效果"><a href="#1-2-动画效果" class="headerlink" title="1.2 动画效果"></a>1.2 动画效果</h4><p>MBProgressHUD 在显示 HUD 窗口的时候，一般都伴随着动画效果，MBProgressHUD 中的动画效果也是一个枚举，如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span>(<span class="type">NSInteger</span>, <span class="type">MBProgressHUDAnimation</span>) &#123;</span><br><span class="line">///  默认效果，只有透明度变化</span><br><span class="line"><span class="type">MBProgressHUDAnimationFade</span>,</span><br><span class="line">/// 透明度变化 + 形变 (放大时出现缩小消失)</span><br><span class="line"><span class="type">MBProgressHUDAnimationZoom</span>,</span><br><span class="line">/// 透明度变化 + 形变 (缩小)</span><br><span class="line"><span class="type">MBProgressHUDAnimationZoomOut</span>,</span><br><span class="line">/// 透明度变化 + 形变 (放大)</span><br><span class="line"><span class="type">MBProgressHUDAnimationZoomIn</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><em>这里先简单的罗列出来，下文中还会多次用到。</em><br><br><br></p>
<h4 id="1-3-MBProgressHUD-组成"><a href="#1-3-MBProgressHUD-组成" class="headerlink" title="1.3 MBProgressHUD 组成"></a>1.3 MBProgressHUD 组成</h4><p><code>MBProgressHUD</code> 主要由四部分组成：<strong>loading 动画视图</strong>、<strong>标题文本框</strong>、<strong>详情文本框</strong>、<strong>HUD 背景框</strong>，如下图。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-c61402fca48f7cea.gif?imageMogr2/auto-orient/strip" alt="MBProgressHUD 组成"></p>
<p>之前用 <code>MBProgressHUD</code> 设置标题文本详情文本是通过几个属性来实现的，功能少也较为繁琐，因此被遗弃了；现在设置标题文本详情文本等十分简便，直接通过 label 等控件就可以实现，而且在功能上也有很大的扩展，详情请看下面这个代码块：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// bezelView 是指包括文本和指示器的视图，和自定义的 customView 类似</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) MBBackgroundView *bezelView;</span><br><span class="line"><span class="comment">/// backgroundView 背景视图</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) MBBackgroundView *backgroundView;</span><br><span class="line"><span class="comment">/// customView 自定义视图</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">UIView</span> *customView;</span><br><span class="line"><span class="comment">/// label 指的是标题文本</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UILabel</span> *label;</span><br><span class="line"><span class="comment">/// detailsLabel指的是详情文本</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UILabel</span> *detailsLabel;</span><br><span class="line"><span class="comment">/// hud 窗口还可以加入button，添加事件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIButton</span> *button;</span><br></pre></td></tr></table></figure>
<p>另外这里再附加两张 <code>MBProgressHUD</code> 的整体布局图，以便更好地认识 <code>MBProgressHUD</code>。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-c955394ba5fe50c9.gif?imageMogr2/auto-orient/strip" alt=" MBProgressHUD 的整体布局图 1"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-edeee858374f6c16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MBProgressHUD 的整体布局图 2"></p>
<p><strong>简单介绍</strong>：</p>
<ul>
<li>backgroundView：整个背景图层，可以通过 MBBackgroundView 的 style 属性设置</li>
<li>bezelView：提供元素 （indicator、label、detailLabel、button）的背景</li>
<li>indicator：指示器显示进度情况 这个视图由我们设定的mode属性决定</li>
<li>label：显示标题文本</li>
<li>detailLabel：显示详情文本</li>
<li>button：添加点击事件<br><br><br></li>
</ul>
<h4 id="1-4-MBProgressHUD-中的属性"><a href="#1-4-MBProgressHUD-中的属性" class="headerlink" title="1.4 MBProgressHUD 中的属性"></a>1.4 MBProgressHUD 中的属性</h4><p>MBProgressHUD 文件中主要包括四个类，它们分别是 <strong>MBProgressHUD</strong>、<strong>MBRoundProgressView</strong>、 <strong>MBBarProgressView</strong>、 <strong>MBBackgroundView</strong>。这四个类各有各的用法，比如如果是进度条模式(MBProgressHUDModeDeterminateHorizontalBar)，则使用的是 <code>MBBarProgressView</code> 类；如果是饼图模式(MBProgressHUDModeDeterminate)或环形模式(MBProgressHUDModeAnnularDeterminate)，则使用的是 <code>MBRoundProgressView</code>类。下面是这四个类的相关属性。</p>
<h6 id="1-41-MBProgressHUD-相关属性"><a href="#1-41-MBProgressHUD-相关属性" class="headerlink" title="1.41  MBProgressHUD 相关属性"></a>1.41  MBProgressHUD 相关属性</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// show 方法触发到显示 HUD 窗口的间隔时间，默认是 0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> graceTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 窗口显示的最短时间，默认是 0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> minShowTime;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 窗口显示模式, 默认是系统自带的指示器</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDMode mode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条指示器以及文本的颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">UIColor</span> *contentColor <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 窗口显示和隐藏的动画类型MBProgressHUD</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDAnimation animationType <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 窗口位置设置，比如 hud.offset = CGPointMake(0.f, MBProgressMaxOffset)，可以移到底部中心位置</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> offset <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 元素到 HUD 边缘的距离，默认是 20.f</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> margin <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 窗口背景框的最小尺寸</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> minSize <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 是否强制 HUD 背景框宽高相等</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isSquare) <span class="built_in">BOOL</span> square <span class="built_in">UI_APPEARANCE_SELECTOR</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条 (0.0 到 1.0)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> progress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// bezelView 是指包括文本和指示器的视图，和自定义的 customView 类似</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) MBBackgroundView *bezelView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// backgroundView 背景视图</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) MBBackgroundView *backgroundView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// customView 自定义视图</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">UIView</span> *customView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// label 指的是标题文本</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UILabel</span> *label;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// detailsLabel指的是详情文本</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UILabel</span> *detailsLabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// hud 窗口还可以加入button，添加事件</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">UIButton</span> *button;</span><br></pre></td></tr></table></figure>
<h6 id="1-42-MBRoundProgressView-相关属性"><a href="#1-42-MBRoundProgressView-相关属性" class="headerlink" title="1.42 MBRoundProgressView 相关属性"></a>1.42 MBRoundProgressView 相关属性</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 进度条 (0.0 到 1.0)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> progress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *progressColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条指示器的颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *progressTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条指示器的背景颜色，只适用在 iOS7 以上，默认为半透明的白色 (透明度 0.1)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *backgroundTintColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 显示模式，NO = 圆形；YES = 环形。默认是 NO</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">getter</span> = isAnnular) <span class="built_in">BOOL</span> annular;</span><br></pre></td></tr></table></figure>
<h6 id="1-43-MBBarProgressView-相关属性"><a href="#1-43-MBBarProgressView-相关属性" class="headerlink" title="1.43 MBBarProgressView 相关属性"></a>1.43 MBBarProgressView 相关属性</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 进度条 (0.0 到 1.0)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">float</span> progress;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条边界线的颜色，默认是白色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *lineColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条背景色，默认是透明</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *progressRemainingColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条颜色</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *progressColor;</span><br></pre></td></tr></table></figure>
<h6 id="1-44-MBBackgroundView-相关属性"><a href="#1-44-MBBackgroundView-相关属性" class="headerlink" title="1.44 MBBackgroundView 相关属性"></a>1.44 MBBackgroundView 相关属性</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 背景图层样式，有两种，iOS7 或者以上版本默认风格是MBProgressHUDBackgroundStyleBlur，其他为MBProgressHUDBackgroundStyleSolidColor，由于 iOS7 不支持 UIVisualEffectView，所以在 iOS7 和更高版本中会有所不同</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) MBProgressHUDBackgroundStyle style;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 背景颜色，由于 iOS7 不支持 UIVisualEffectView，所以在 iOS7 和更高版本中会有所不同</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *color;</span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h4 id="1-5-MBProgressHUD-中的一些方法"><a href="#1-5-MBProgressHUD-中的一些方法" class="headerlink" title="1.5 MBProgressHUD 中的一些方法"></a>1.5 MBProgressHUD 中的一些方法</h4><h6 id="1-51-类方法"><a href="#1-51-类方法" class="headerlink" title="1.51 类方法"></a>1.51 类方法</h6><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建一个 HUD 窗口，并把它显示在 view 上，还可以设置是否有动画</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 找到最上层的 HUD subview 并把它隐藏，成功为YES、其他情况为 NO</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回最上层的 HUD subview</span></span><br><span class="line">+ (<span class="keyword">nullable</span> MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure>
<p>这三个类方法中，常用的是第一个函数<code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;</code>直接创建 HUD，并把它显示在 view 上，用起来极其方便</p>
<h6 id="1-52-对象方法"><a href="#1-52-对象方法" class="headerlink" title="1.52 对象方法"></a>1.52 对象方法</h6><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 以view为基准创建初始化一个HUD对象，为HUD的初始化构造函数</span></span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">initWithView</span><span class="selector-pseudo">:(UIView</span> *)<span class="selector-tag">view</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 显示HUD控件，此函数应该在主线程中调用</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">showAnimated</span><span class="selector-pseudo">:(BOOL)animated</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 隐藏HUD控件，animated控制是否显示动画。对应于- (void)showAnimated:(BOOL)animated;</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">hideAnimated</span><span class="selector-pseudo">:(BOOL)animated</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 在delay时间之后隐藏HUD，animated控制显示动画与否，delay控制延迟时间</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">hideAnimated</span><span class="selector-pseudo">:(BOOL)animated</span> <span class="selector-tag">afterDelay</span><span class="selector-pseudo">:(NSTimeInterval)delay</span>;</span><br></pre></td></tr></table></figure>
<p>这几个对象方法中，常用的也有两个<code>- (void)hideAnimated:(BOOL)animated;</code>和<code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay;</code></p>
<p><br><br></p>
<h2 id="二、show-系列方法"><a href="#二、show-系列方法" class="headerlink" title="二、show 系列方法"></a>二、show 系列方法</h2><blockquote>
<p>这一部分主要是展示 HUD 窗口时调用的方法及代码分析</p>
</blockquote>
<p>下面这个方法在我们创建 MBProgressHUD 对象时首先调用</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (instance<span class="keyword">type</span>)showHUDAddedTo:(<span class="type">UIView</span> *)view animated:(<span class="type">BOOL</span>)animated &#123;</span><br><span class="line"></span><br><span class="line">/// 创建并初始化 <span class="type">MBProgressHUD</span> 对象，根据传进来的 view 来设定</span><br><span class="line"><span class="type">MBProgressHUD</span> *hud = [[self alloc] initWithView:view];</span><br><span class="line"></span><br><span class="line">/// 移除 <span class="type">HUD</span> 窗口</span><br><span class="line">hud.removeFromSuperViewOnHide = <span class="type">YES</span>;</span><br><span class="line"></span><br><span class="line">/// 添加到 <span class="type">View</span> 上，并显示</span><br><span class="line">[view addSubview:hud];</span><br><span class="line">[hud showAnimated:animated];</span><br><span class="line">return hud;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法会调用两个主要方法：<code>- (id)initWithView:(UIView *)view</code> 和 <code>- (void)showAnimated:(BOOL)animated</code>，具体的调用流程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-effb289399c57e61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="show 相关的方法调用"></p>
<p>当然在 MBProgressHUD 中，<code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated</code> 调用的方法远不止上图列的这些，图上列的只是几个主要方法。接下来我们就根据程序的执行过程来一步一步分析一下代码。</p>
<p>在方法 <code>- (id)initWithView:(UIView *)view</code>中，调用 <code>- (instancetype)initWithFrame:(CGRect)frame</code>，接着会调用<code>- (void)commonInit</code>。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithView:(<span class="built_in">UIView</span> *)view &#123;</span><br><span class="line"><span class="built_in">NSAssert</span>(view, <span class="string">@"View must not be nil."</span>);</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> initWithFrame:view.bounds];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame])) &#123;</span><br><span class="line">[<span class="keyword">self</span> commonInit];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder &#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:aDecoder])) &#123;</span><br><span class="line">[<span class="keyword">self</span> commonInit];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)commonInit &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 默认效果, 透明度变化</span></span><br><span class="line">_animationType = MBProgressHUDAnimationFade;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 默认模式, 系统自带的指示器</span></span><br><span class="line">_mode = MBProgressHUDModeIndeterminate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// HUD 元素到 HUD 边缘的距离，默认是 20.f</span></span><br><span class="line">_margin = <span class="number">20.0</span>f;</span><br><span class="line">_opacity = <span class="number">1.</span>f;</span><br><span class="line">_defaultMotionEffectsEnabled = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认颜色，根据当前的 iOS 版本</span></span><br><span class="line"><span class="built_in">BOOL</span> isLegacy = kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_7_0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条指示器以及文本的颜色</span></span><br><span class="line">_contentColor = isLegacy ? [<span class="built_in">UIColor</span> whiteColor] : [<span class="built_in">UIColor</span> colorWithWhite:<span class="number">0.</span>f alpha:<span class="number">0.7</span>f];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NO</span></span><br><span class="line"><span class="keyword">self</span>.opaque = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 背景色</span></span><br><span class="line"><span class="keyword">self</span>.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 透明度为 0</span></span><br><span class="line"><span class="keyword">self</span>.alpha = <span class="number">0.0</span>f;</span><br><span class="line"><span class="comment">/// 自动调整子控件与父控件之间的宽高</span></span><br><span class="line"><span class="keyword">self</span>.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line"><span class="keyword">self</span>.layer.allowsGroupOpacity = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置所需的子view</span></span><br><span class="line">[<span class="keyword">self</span> setupViews];</span><br><span class="line"><span class="comment">/// 设置指示器样式</span></span><br><span class="line">[<span class="keyword">self</span> updateIndicators];</span><br><span class="line"><span class="comment">/// 注册通知</span></span><br><span class="line">[<span class="keyword">self</span> registerForNotifications];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码块中的代码已经加过注释，因此在这里不再累述某句代码有什么作用，这里直接说程序的执行流程。当程序执行到 <code>- (void)commonInit</code> 这个方法时，会相继执行<code>- (void)setupViews</code>，<code>- (void)updateIndicators</code>，<code>- (void)registerForNotifications</code> 这三个方法，当然在执行这三个方法期间，也会执行其它的方法，比如会执行<code>- (void)updateForBackgroundStyle</code> 和<code>- (void)updateBezelMotionEffects</code>等等，这和你设置的 mode 的模式，以及和 label，detailsLabel ，button 这一系列元素，以及和相应的属性都有一定的关系。</p>
<p>接着我们来分析一下 <code>- (void)setupViews</code>，<code>- (void)updateIndicators</code>，<code>- (void)registerForNotifications</code> 这三个方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupViews &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 进度条指示器以及文本的颜色</span></span><br><span class="line"><span class="built_in">UIColor</span> *defaultColor = <span class="keyword">self</span>.contentColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建背景视图</span></span><br><span class="line">MBBackgroundView *backgroundView = [[MBBackgroundView alloc] initWithFrame:<span class="keyword">self</span>.bounds];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 背景图层样式</span></span><br><span class="line">backgroundView.style = MBProgressHUDBackgroundStyleSolidColor;</span><br><span class="line">backgroundView.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 自动调整 view 的宽度和高度</span></span><br><span class="line">backgroundView.autoresizingMask = <span class="built_in">UIViewAutoresizingFlexibleWidth</span> | <span class="built_in">UIViewAutoresizingFlexibleHeight</span>;</span><br><span class="line">backgroundView.alpha = <span class="number">0.</span>f;</span><br><span class="line">[<span class="keyword">self</span> addSubview:backgroundView];</span><br><span class="line">_backgroundView = backgroundView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建背景视图（和上面那个大小不同）</span></span><br><span class="line">MBBackgroundView *bezelView = [MBBackgroundView new];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NO</span></span><br><span class="line">bezelView.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">bezelView.layer.cornerRadius = <span class="number">5.</span>f;</span><br><span class="line">bezelView.alpha = <span class="number">0.</span>f;</span><br><span class="line">[<span class="keyword">self</span> addSubview:bezelView];</span><br><span class="line">_bezelView = bezelView;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用 updateBezelMotionEffects 方法，设置视差效果</span></span><br><span class="line">[<span class="keyword">self</span> updateBezelMotionEffects];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建 label 标签，显示主要文本</span></span><br><span class="line"><span class="built_in">UILabel</span> *label = [<span class="built_in">UILabel</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消文字大小自适应</span></span><br><span class="line">label.adjustsFontSizeToFitWidth = <span class="literal">NO</span>;</span><br><span class="line">label.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">label.textColor = defaultColor;</span><br><span class="line">label.font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:MBDefaultLabelFontSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NO</span></span><br><span class="line">label.opaque = <span class="literal">NO</span>;</span><br><span class="line">label.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">_label = label;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建 detailsLabel 标签，显示详细信息</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *detailsLabel = [<span class="built_in">UILabel</span> new];</span><br><span class="line"><span class="comment">/// 取消文字大小自适应</span></span><br><span class="line">detailsLabel.adjustsFontSizeToFitWidth = <span class="literal">NO</span>;</span><br><span class="line">detailsLabel.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">detailsLabel.textColor = defaultColor;</span><br><span class="line">detailsLabel.numberOfLines = <span class="number">0</span>;</span><br><span class="line">detailsLabel.font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:MBDefaultDetailsLabelFontSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NO</span></span><br><span class="line">detailsLabel.opaque = <span class="literal">NO</span>;</span><br><span class="line">detailsLabel.backgroundColor = [<span class="built_in">UIColor</span> clearColor];</span><br><span class="line">_detailsLabel = detailsLabel;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建 button 按钮，并添加响应按钮</span></span><br><span class="line"><span class="built_in">UIButton</span> *button = [MBProgressHUDRoundedButton buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">button.titleLabel.textAlignment = <span class="built_in">NSTextAlignmentCenter</span>;</span><br><span class="line">button.titleLabel.font = [<span class="built_in">UIFont</span> boldSystemFontOfSize:MBDefaultDetailsLabelFontSize];</span><br><span class="line">[button setTitleColor:defaultColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">_button = button;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将 label，detailLabel，button 添加到蒙版视图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> @[label, detailsLabel, button]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NO</span></span><br><span class="line">view.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为视图设置水平方向上优先级为 998 的压缩阻力</span></span><br><span class="line">[view setContentCompressionResistancePriority:<span class="number">998.</span>f forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为视图设置垂直方向上优先级为 998 的压缩阻力</span></span><br><span class="line">[view setContentCompressionResistancePriority:<span class="number">998.</span>f forAxis:<span class="built_in">UILayoutConstraintAxisVertical</span>];</span><br><span class="line">[bezelView addSubview:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建顶部视图</span></span><br><span class="line"><span class="built_in">UIView</span> *topSpacer = [<span class="built_in">UIView</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NO</span></span><br><span class="line">topSpacer.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">topSpacer.hidden = <span class="literal">YES</span>;</span><br><span class="line">[bezelView addSubview:topSpacer];</span><br><span class="line">_topSpacer = topSpacer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建底部视图</span></span><br><span class="line"><span class="built_in">UIView</span> *bottomSpacer = [<span class="built_in">UIView</span> new];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NO</span></span><br><span class="line">bottomSpacer.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">bottomSpacer.hidden = <span class="literal">YES</span>;</span><br><span class="line">[bezelView addSubview:bottomSpacer];</span><br><span class="line">_bottomSpacer = bottomSpacer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateIndicators &#123;</span><br><span class="line"><span class="built_in">UIView</span> *indicator = <span class="keyword">self</span>.indicator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断当前指示器是否是 UIActivityIndicatorView</span></span><br><span class="line"><span class="built_in">BOOL</span> isActivityIndicator = [indicator isKindOfClass:[<span class="built_in">UIActivityIndicatorView</span> <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 判断当前指示器是否是 MBRoundProgressView</span></span><br><span class="line"><span class="built_in">BOOL</span> isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView <span class="keyword">class</span>]];</span><br><span class="line"></span><br><span class="line">MBProgressHUDMode mode = <span class="keyword">self</span>.mode;</span><br><span class="line"><span class="comment">/// MBProgressHUDModeIndeterminate:系统自带的指示器</span></span><br><span class="line"><span class="keyword">if</span> (mode == MBProgressHUDModeIndeterminate) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isActivityIndicator) &#123;</span><br><span class="line"><span class="comment">// 如果当前指示器不属于 UIActivityIndicatorView 类型，则移除之前的indicator，重新创建</span></span><br><span class="line">[indicator removeFromSuperview];</span><br><span class="line">indicator = [[<span class="built_in">UIActivityIndicatorView</span> alloc] initWithActivityIndicatorStyle:<span class="built_in">UIActivityIndicatorViewStyleWhiteLarge</span>];</span><br><span class="line">[(<span class="built_in">UIActivityIndicatorView</span> *)indicator startAnimating];</span><br><span class="line">[<span class="keyword">self</span>.bezelView addSubview:indicator];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123;</span><br><span class="line"><span class="comment">/// 如果当前指示器不属于 MBBarProgressView 类型，则移除之前的indicator，重新创建</span></span><br><span class="line">[indicator removeFromSuperview];</span><br><span class="line">indicator = [[MBBarProgressView alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.bezelView addSubview:indicator];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isRoundIndicator) &#123;</span><br><span class="line"><span class="comment">/// 如果当前指示器不属于 MBRoundProgressView 类型，则移除之前的indicator，重新创建</span></span><br><span class="line">[indicator removeFromSuperview];</span><br><span class="line">indicator = [[MBRoundProgressView alloc] init];</span><br><span class="line">[<span class="keyword">self</span>.bezelView addSubview:indicator];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode == MBProgressHUDModeAnnularDeterminate) &#123; <span class="comment">/// 圆环指示器</span></span><br><span class="line">[(MBRoundProgressView *)indicator setAnnular:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeCustomView &amp;&amp; <span class="keyword">self</span>.customView != indicator) &#123; <span class="comment">/// 自定义视图指示器</span></span><br><span class="line">[indicator removeFromSuperview];</span><br><span class="line">indicator = <span class="keyword">self</span>.customView;</span><br><span class="line">[<span class="keyword">self</span>.bezelView addSubview:indicator];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mode == MBProgressHUDModeText) &#123; <span class="comment">/// 文本形式，去除指示器视图</span></span><br><span class="line">[indicator removeFromSuperview];</span><br><span class="line">indicator = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NO</span></span><br><span class="line">indicator.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.indicator = indicator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ([indicator respondsToSelector:<span class="keyword">@selector</span>(setProgress:)]) &#123;</span><br><span class="line"><span class="comment">/// 设置进度条的数值</span></span><br><span class="line">[(<span class="keyword">id</span>)indicator setValue:@(<span class="keyword">self</span>.progress) forKey:<span class="string">@"progress"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为视图设置水平方向上优先级为 998 的压缩阻力</span></span><br><span class="line">[indicator setContentCompressionResistancePriority:<span class="number">998.</span>f forAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 为视图设置垂直方向上优先级为 998 的压缩阻力</span></span><br><span class="line">[indicator setContentCompressionResistancePriority:<span class="number">998.</span>f forAxis:<span class="built_in">UILayoutConstraintAxisVertical</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置控件颜色</span></span><br><span class="line">[<span class="keyword">self</span> updateViewsForColor:<span class="keyword">self</span>.contentColor];</span><br><span class="line"><span class="comment">/// 更新布局</span></span><br><span class="line">[<span class="keyword">self</span> setNeedsUpdateConstraints];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerForNotifications &#123;</span><br><span class="line"><span class="meta">#if !TARGET_OS_TV</span></span><br><span class="line"><span class="built_in">NSNotificationCenter</span> *nc = [<span class="built_in">NSNotificationCenter</span> defaultCenter];</span><br><span class="line"><span class="comment">/// 通过通知 UIApplicationDidChangeStatusBarOrientationNotification 来处理屏幕转屏事件</span></span><br><span class="line">[nc addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(statusBarOrientationDidChange:)</span><br><span class="line">name:<span class="built_in">UIApplicationDidChangeStatusBarOrientationNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>由上面代码我们可以看出，在方法<code>- (void)setupViews</code>中，创建了 backgroundView、bezelView、label、detailsLabel、button 这几个控件，并使用 for 循环把 label、detailsLabel、button 添加到bezelView 视图中，最后还创建了顶部视图和底部视图，不过默认是隐藏的。有一点值得说明，在创建 button 时并没有设置 button 的 size 等属性，那么这个按钮是不会显示的。在这里 MBProgressHUD 重写了一个 Unbutton 的子类 MBProgressHUDRoundedButton。这个子类里面有一个方法，<code>- (CGSize)intrinsicContentSize</code>，通过这个方法来设置 Unbutton 的 size。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)intrinsicContentSize &#123;</span><br><span class="line"><span class="comment">/// 只有当有事件才显示（这里也告诉我们，如果这个 button 没有任何事件的话，它的大小就是 CGSizeZero，即不会显示）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.allControlEvents == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">CGSizeZero</span>;</span><br><span class="line"><span class="built_in">CGSize</span> size = [<span class="keyword">super</span> intrinsicContentSize];</span><br><span class="line"><span class="comment">// Add some side padding</span></span><br><span class="line">size.width += <span class="number">20.</span>f;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>- (void)updateIndicators</code>这个方法主要是用来设置 indicator 指示器的，根据 mode 的属性显示不同的形式，具体可以参看代码注释。这个方法最后调用的是<code>setNeedsUpdateConstraints</code>函数，这个函数是系统自带的方法，它会自动调用<code>- (void)updateConstraints</code> 方法，<code>- (void)updateConstraints</code> 主要作用是更新各个控件的布局，我们稍后再对这个方法进行详细分析。</p>
</li>
<li><p><code>- (void)registerForNotifications</code>这个方法中的代码量很少，它的作用是通过通知 UIApplicationDidChangeStatusBarOrientationNotification 来处理屏幕转屏事件</p>
</li>
</ul>
<p>当<code>- (void)registerForNotifications</code>这一系列方法执行完毕之后，程序会重新返回到<code>+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated</code>这个方法中，接着调用另一个主要函数<code>- (void)showAnimated:(BOOL)animated</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 显示放在主线程中</span></span><br><span class="line">MBMainThreadAssert();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消定时器</span></span><br><span class="line">[<span class="keyword">self</span>.minShowTimer invalidate];</span><br><span class="line"><span class="keyword">self</span>.useAnimation = animated;</span><br><span class="line"><span class="keyword">self</span>.finished = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果设置了宽限时间graceTime，则延迟显示（避免 HUD 一闪而过的差体验）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建定时器，把它加入 NSRunLoop 中</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="keyword">self</span>.graceTimer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 没有设置 graceTime，则直接显示</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">[<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设置宽限时间 graceTime时调用的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</span><br><span class="line"><span class="comment">// Show the HUD only if the task is still running</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.hasFinished) &#123;</span><br><span class="line">[<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)showUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"><span class="comment">/// 移除所有动画</span></span><br><span class="line">[<span class="keyword">self</span>.bezelView.layer removeAllAnimations];</span><br><span class="line">[<span class="keyword">self</span>.backgroundView.layer removeAllAnimations];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 取消 hideDelayTimer</span></span><br><span class="line">[<span class="keyword">self</span>.hideDelayTimer invalidate];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开始时间</span></span><br><span class="line"><span class="keyword">self</span>.showStarted = [<span class="built_in">NSDate</span> date];</span><br><span class="line"><span class="keyword">self</span>.alpha = <span class="number">1.</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 以防我们隐藏 NSProgress 对象</span></span><br><span class="line">[<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (animated) &#123;</span><br><span class="line">[<span class="keyword">self</span> animateIn:<span class="literal">YES</span> withType:<span class="keyword">self</span>.animationType completion:<span class="literal">NULL</span>];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/// 方法弃用告警</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line"><span class="keyword">self</span>.bezelView.alpha = <span class="keyword">self</span>.opacity;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"><span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面这段代码我们可以看出，在方法<code>- (void)showAnimated:(BOOL)animated</code>中，无论我们有没有设置<code>graceTime</code>这个属性，最后都会去执行一个方法 <code>- (void)showUsingAnimation:(BOOL)animated</code>，<code>- (void)showUsingAnimation:(BOOL)animated</code> 这个方法在上面已经做过注释，不再细说，不过有两小点值得我们注意，第一点是 <code>- (void)showUsingAnimation:(BOOL)animated</code> 在执行过程中调用了一个方法 <code>- (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled</code>，先来看下这个方法<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里使用 CADisplayLink，是因为如果使用 KVO 机制会非常消耗主线程（因为 NSProgress 频率非常快）</span></span><br><span class="line"><span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</span><br><span class="line"><span class="comment">/// 创建 CADisplayLink 对象</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</span><br><span class="line"><span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法是关于 <code>CADisplayLink</code> 的，<code>CADisplayLink</code> 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 <code>CADisplayLink</code> 对象，把它添加到一个<code>runloop</code> 中，并给它提供一个 <code>target</code> 和 <code>selector</code> 在屏幕刷新的时候调用。一旦 <code>CADisplayLink</code> 以特定的模式注册到 <code>runloop</code> 之后，每当屏幕需要刷新，<code>runloop</code> 就会向 <code>CADisplayLink</code> 指定的<code>target</code> 发送一次指定的 <code>selector</code> 消息， <code>CADisplayLink</code> 类对应的 <code>selector</code> 就会被调用一次。</p>
<p><code>- (void)showUsingAnimation:(BOOL)animated</code> 这个方法中还有一点值得注意，就是只有具有动画效果的前提下，即 <code>animated</code> 为真时才会调用 <code>- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion</code> 这个方法，下面我们再一起来看下这个方法。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// animated 为真时调用，消失或出现时的伸缩效果，以及透明度</span></span><br><span class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</span><br><span class="line"><span class="comment">/// 自动确定正确的缩放动画类型，关于 MBProgressHUDAnimation 的几种类型，上文已全部列出，这里不再详细介绍</span></span><br><span class="line"><span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</span><br><span class="line">type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CGAffineTransformMakeScale 中的两个参数，分别代表x和y方向缩放倍数</span></span><br><span class="line"><span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line"><span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设定初始状态</span></span><br><span class="line"><span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</span><br><span class="line"><span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">bezelView.transform = small; <span class="comment">/// 缩放</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">bezelView.transform = large; <span class="comment">/// 扩大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建动画任务</span></span><br><span class="line">dispatch_block_t animations = ^&#123;</span><br><span class="line"><span class="keyword">if</span> (animatingIn) &#123;</span><br><span class="line">bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">bezelView.transform = large;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">bezelView.transform = small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 方法弃用告警</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"><span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画的两种形式，&gt;= iOS7 的是一种形式，iOS7以下是另一种</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></span><br><span class="line"><span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</span><br><span class="line"><span class="comment">/// 只支持 &gt;= iOS7</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion</code> 这个方法，无论是处于 show 状态还是处于 hide 状态，都会调用，下边我们再一起看下 hide 系列的一些方法。</p>
<h2 id="三、hide-系列方法"><a href="#三、hide-系列方法" class="headerlink" title="三、hide 系列方法"></a>三、hide 系列方法</h2><blockquote>
<p>这一部分主要是隐藏 HUD 窗口时调用的方法及代码分析</p>
</blockquote>
<p>关于隐藏 HUD 窗口，MBProgressHUD 给我们提供的方法有以下几个：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 找到最上层的 HUD subview 并把它隐藏，成功为YES、其他情况为 NO</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐藏HUD控件，animated控制是否显示动画。对应于- (void)showAnimated:(BOOL)animated;</span></span><br><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在delay时间之后隐藏HUD，animated控制显示动画与否，delay控制延迟时间</span></span><br><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure></p>
<p>最常用的是后面两个： <code>- (void)hideAnimated:(BOOL)animated</code> 和  <code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay</code>，这两个方法的本质是相同的，不同的只是形式，也就是说这两个方法的实现流程基本上是一致的，只不过 <code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay</code> 多执行一两个方法而已。下面我们就来具体分析下 hide 系列的方法。</p>
<ul>
<li>首先还是来说说<code>+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated</code>这个函数，如果调用这个方法来隐藏 HUD 窗口，那么会先调用两个方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"><span class="comment">/// 获取当前 view 的最上面的 HUD</span></span><br><span class="line">MBProgressHUD *hud = [<span class="keyword">self</span> HUDForView:view];</span><br><span class="line"><span class="keyword">if</span> (hud != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="comment">/// 移除 HUD 窗口</span></span><br><span class="line">hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;</span><br><span class="line">[hud hideAnimated:animated];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view &#123;</span><br><span class="line"><span class="comment">/// NSEnumerator 是一个枚举器，依附于集合类（NSArray,NSSet,NSDictionary等），reverseObjectEnumerator 倒序遍历</span></span><br><span class="line"><span class="built_in">NSEnumerator</span> *subviewsEnum = [view.subviews reverseObjectEnumerator];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviewsEnum) &#123;</span><br><span class="line"><span class="keyword">if</span> ([subview isKindOfClass:<span class="keyword">self</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> (MBProgressHUD *)subview;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当执行完上面这两个方法之后，接下来执行的方法和调用<code>- (void)hideAnimated:(BOOL)animated</code>隐藏 HUD 窗口时执行的方法相同，所以下边会详细分析。</p>
<ul>
<li>接下来说说调用<code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay</code> 隐藏 HUD 窗口时的情况，上文已经说过，调用这个方法会比调用<code>- (void)hideAnimated:(BOOL)animated</code> 多执行一两个方法：</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">hideAnimated:</span>(BOOL)animated <span class="string">afterDelay:</span>(NSTimeInterval)delay &#123;</span><br><span class="line"><span class="comment">/// 创建定时器，并把它加入到 NSRunLoop 中</span></span><br><span class="line">NSTimer *timer = [NSTimer <span class="string">timerWithTimeInterval:</span>delay <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">handleHideTimer:</span>) <span class="string">userInfo:</span>@(animated) <span class="string">repeats:</span>NO];</span><br><span class="line">[[NSRunLoop currentRunLoop] <span class="string">addTimer:</span>timer <span class="string">forMode:</span>NSRunLoopCommonModes];</span><br><span class="line">self.hideDelayTimer = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)<span class="string">handleHideTimer:</span>(NSTimer *)timer &#123;</span><br><span class="line">[self <span class="string">hideAnimated:</span>[timer.userInfo boolValue]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码可以清晰的看出，<code>- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay</code> 这个方法中加了一个定时器，当执行完这个定时器的<code>selector</code>时，就会执行<code>- (void)hideAnimated:(BOOL)animated</code>方法。</p>
<ul>
<li>由此可见无论使用哪种方法隐藏 HUD 窗口，最终都会来到这个方法，<code>- (void)hideAnimated:(BOOL)animated</code>，接下来我们就来分析下这个方法的具体调用流程，先看个图：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-d01f3044d62ba8d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hide 相关的方法调用"></p>
<p>上图显示的是 hide 相关的方法调用，只罗列了几个主要方法。接下来我们就来分析下这几个主要方法。先来到<code>- (void)hideAnimated:(BOOL)animated</code>方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">MBMainThreadAssert();</span><br><span class="line">[<span class="keyword">self</span>.graceTimer invalidate];</span><br><span class="line"><span class="keyword">self</span>.useAnimation = animated;</span><br><span class="line"><span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果设置了最小显示时间，则执行此步骤，否则直接隐藏</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</span><br><span class="line"><span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:<span class="keyword">self</span>.showStarted];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 如果 minShowTime 比较大，则暂时不触发 HUD 的隐藏，而是启动一个 NSTimer</span></span><br><span class="line"><span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</span><br><span class="line"><span class="comment">/// 创建定时器，并把它加入到 NSRunLoop 中</span></span><br><span class="line"><span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="keyword">self</span>.minShowTimer = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 直接隐藏 HUD</span></span><br><span class="line">[<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</span><br><span class="line">[<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码块中可以看出，无论我们有没有设置最小显示时间 <code>self.minShowTime</code>，都会触发 <code>- (void)hideUsingAnimation:(BOOL)animated</code> 这个方法，因此程序最后都会来到 <code>- (void)hideUsingAnimation:(BOOL)animated</code> 这个方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)hideUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line"><span class="keyword">if</span> (animated &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</span><br><span class="line"><span class="comment">/// 将 showStarted 设为 nil</span></span><br><span class="line"><span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</span><br><span class="line">[<span class="keyword">self</span> animateIn:<span class="literal">NO</span> withType:<span class="keyword">self</span>.animationType completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">[<span class="keyword">self</span> done];</span><br><span class="line">&#125;];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">self</span>.bezelView.alpha = <span class="number">0.</span>f;</span><br><span class="line"><span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</span><br><span class="line">[<span class="keyword">self</span> done];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法和 show 系列的 <code>- (void)showUsingAnimation:(BOOL)animated</code> 方法一样，只要设定 animated 的属性为 YES，最终都会走到 <code>- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion</code> 这个方法中，同时会执行一个方法：<code>- (void)done</code>，接下来我们来看一下这两个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// animated 为真时调用，消失或出现时的伸缩效果，以及透明度</span></span><br><span class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</span><br><span class="line"><span class="comment">/// 自动确定正确的缩放动画类型，关于 MBProgressHUDAnimation 的几种类型，上文已全部列出，这里不再详细介绍</span></span><br><span class="line"><span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</span><br><span class="line">type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// CGAffineTransformMakeScale 中的两个参数，分别代表x和y方向缩放倍数</span></span><br><span class="line"><span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line"><span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 设定初始状态</span></span><br><span class="line"><span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</span><br><span class="line"><span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">bezelView.transform = small; <span class="comment">/// 缩放</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">bezelView.transform = large; <span class="comment">/// 扩大</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建动画任务</span></span><br><span class="line">dispatch_block_t animations = ^&#123;</span><br><span class="line"><span class="keyword">if</span> (animatingIn) &#123;</span><br><span class="line">bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">bezelView.transform = large;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">bezelView.transform = small;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 方法弃用告警</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line"><span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 动画的两种形式，&gt;= iOS7 的是一种形式，iOS7以下是另一种</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></span><br><span class="line"><span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</span><br><span class="line"><span class="comment">/// 只支持 &gt;= iOS7</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">[<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)done &#123;</span><br><span class="line"><span class="comment">/// 取消 hideDelayTimer</span></span><br><span class="line">[<span class="keyword">self</span>.hideDelayTimer invalidate];</span><br><span class="line"><span class="comment">/// 隐藏 NSProgress 对象</span></span><br><span class="line">[<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">NO</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasFinished) &#123;</span><br><span class="line"><span class="keyword">self</span>.alpha = <span class="number">0.0</span>f;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.removeFromSuperViewOnHide) &#123;</span><br><span class="line"><span class="comment">/// 从父视图中移除</span></span><br><span class="line">[<span class="keyword">self</span> removeFromSuperview];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MBProgressHUDCompletionBlock completionBlock = <span class="keyword">self</span>.completionBlock;</span><br><span class="line"><span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">completionBlock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">id</span>&lt;MBProgressHUDDelegate&gt; delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line"><span class="keyword">if</span> ([delegate respondsToSelector:<span class="keyword">@selector</span>(hudWasHidden:)]) &#123;</span><br><span class="line">[delegate performSelector:<span class="keyword">@selector</span>(hudWasHidden:) withObject:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 <code>- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion</code> 这个方法，只要 <code>animated</code> 的属性为 YES，都会调用；而在<code>- (void)done</code> 这个方法中，如果 removeFromSuperViewOnHide 属性为 YES，则将自己从父视图上移除；如果有 completionBlock 回调函数，则执行回调；如果实现了代理并实现了代理方法，则执行代理方法。而且我们还观察到在 hide 时，也会调用 <code>- (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled</code> 方法，只是在 hide 时 enabled 为 NO。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 这里使用 CADisplayLink，是因为如果使用 KVO 机制会非常消耗主线程（因为 NSProgress 频率非常快）</span></span><br><span class="line"><span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</span><br><span class="line"><span class="comment">/// 创建 CADisplayLink 对象</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</span><br><span class="line"><span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>over</strong></p>
<hr>
<p>以上便是对 MBProgressHUD 源码的一些总结和认识，如果有不足之处，还希望各位道友能多指点哈！</p>
<hr>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/iOS开发之源码解析 - Masonry/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/iOS开发之源码解析 - Masonry/" itemprop="url">
                  iOS开发之源码解析 - Masonry
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>这是 <em>GitHub</em> 上，<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 官方对 <em>Masonry</em> 的介绍：</strong></p>
<blockquote>
<p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>  is a light-weight layout framework which wraps AutoLayout with a nicer syntax. Masonry has its own layout <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL</a> which provides a chainable way of describing your NSLayoutConstraints which results in layout code that is more concise and readable. Masonry supports iOS and Mac OS X.</p>
</blockquote>
<p>译文如下：</p>
<blockquote>
<p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 是一个轻量级的布局框架，它通过一种友好的语法封装了自动布局。Masonry 通过链式语法 <a href="https://en.wikipedia.org/wiki/Domain-specific_language" target="_blank" rel="noopener">DSL(Domain-specific language)</a> 来封装 NSLayoutConstraints，使布局代码更加地简洁易读。Masonry 支持 iOS 和 Mac OS X。</p>
</blockquote>
<p>在分析 Masonry 源码之前，有必要先说一下 Masonry 的基本使用，而在说 Masonry 的基本使用之前，我们还是先来看看 storyboard 以及 xib 中是如何进行 AutoLayout 的，我截了两张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-a305784e0ac30193.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-a97902c3ba89e176.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>从上图我们可以看出，在 storyboard 和 xib 中，我们可以在可视化界面对控件进行 AutoLayout，操作较为简单方便。Masonry 的实现原理与这很相似，接下来我们就一起看看如何使用 Masonry 进行自动布局。</p>
<p>先看一下 Masonry 支持哪些属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    以下属性返回一个新的 MASViewConstraint</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;      <span class="comment">// 左侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;       <span class="comment">// 上侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;     <span class="comment">// 右侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;    <span class="comment">// 下侧</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;   <span class="comment">// 首部</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;  <span class="comment">// 尾部</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;     <span class="comment">// 宽</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;    <span class="comment">// 高</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;   <span class="comment">// 横向居中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;   <span class="comment">// 纵向居中</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline;  <span class="comment">// 文本基线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  返回一个 block 对象，block 的接收参数是 MASAttribute 类型,返回一个 MASCompositeConstraint 对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *(^attributes)(MASAttribute attrs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    返回一个 MASConstraint 对象，包含上下左右的布局信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *edges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    返回一个 MASConstraint 对象，包含宽高的布局信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    返回一个 MASConstraint 对象，包含 centerX 和 centerY 信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *center;</span><br></pre></td></tr></table></figure>
<p>有了属性之后，怎样添加约束呢？<strong>使用 Masonry 添加约束的函数有三个</strong>，这三个方法我们在文件 <code>View+MASAdditions</code> 中可以查看到：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 新增约束</span></span><br><span class="line"><span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_makeConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 更新约束</span></span><br><span class="line"><span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_updateConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 清除旧约束，只保留新约束</span></span><br><span class="line"><span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_remakeConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br></pre></td></tr></table></figure>
<p>上面这三个方法中最常用的是 <code>- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block</code>。即第一个，接下来我们就尝试一下。</p>
<p>举个栗子：</p>
<p>导入 Masonry 框架之后，添加以下代码：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutViews</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] init];</span><br><span class="line">[imageView setImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"123"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:imageView];</span><br><span class="line"></span><br><span class="line">[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">100</span>);</span><br><span class="line">make.right.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">-100</span>);</span><br><span class="line">make.top.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">250</span>);</span><br><span class="line">make.bottom.equalTo(<span class="keyword">self</span>.view).offset(<span class="number">-250</span>);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这几句代码便可以对 UIImageView 控件进行约束，这里还有两点值得一提。第一点：<strong>下面这三种方式会实现相同的效果</strong><br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 第一种</span></span><br><span class="line">[imageView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line"><span class="built_in">make</span>.left.equalTo(self.<span class="built_in">view</span>).offset(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">make</span>.right.equalTo(self.<span class="built_in">view</span>).offset(<span class="number">-100</span>);</span><br><span class="line"><span class="built_in">make</span>.top.equalTo(self.<span class="built_in">view</span>).offset(<span class="number">250</span>);</span><br><span class="line"><span class="built_in">make</span>.bottom.equalTo(self.<span class="built_in">view</span>).offset(<span class="number">-250</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 第二种</span></span><br><span class="line">[imageView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line"><span class="built_in">make</span>.top.bottom.left.right.equalTo(self.<span class="built_in">view</span>).insets(UIEdgeInsetsMake(<span class="number">250</span>, <span class="number">100</span>, <span class="number">250</span>, <span class="number">100</span>));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 第三种</span></span><br><span class="line">[imageView mas_makeConstraints:^(MASConstraintMaker *<span class="built_in">make</span>) &#123;</span><br><span class="line"><span class="built_in">make</span>.edges.equalTo(self.<span class="built_in">view</span>).insets(UIEdgeInsetsMake(<span class="number">250</span>, <span class="number">100</span>, <span class="number">250</span>, <span class="number">100</span>));</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>三种方式得出的效果图一样：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-ecf24222fa369f6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>第二点：<strong>必须先把控件添加到视图上，才能对控件进行布局，否则程序会崩</strong>。即先 <code>addSubview:</code>，再 <code>mas_makeConstraints:</code> 。</p>
<hr>
<p><strong>以上是对 Masonry 使用的简单介绍。接下来我们开始分析它的源码</strong>。</p>
<p>通过对 Masonry  使用方法的了解，我们可以看出 Masonry 的使用过程还是很简洁的</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">imageView</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line">make.left.equalTo(<span class="name">self.view</span>).offset(<span class="name">100</span>)<span class="comment">;</span></span><br><span class="line">make.right.equalTo(<span class="name">self.view</span>).offset(<span class="name">-100</span>)<span class="comment">;</span></span><br><span class="line">make.top.equalTo(<span class="name">self.view</span>).offset(<span class="name">250</span>)<span class="comment">;</span></span><br><span class="line">make.bottom.equalTo(<span class="name">self.view</span>).offset(<span class="name">-250</span>)<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>那我们就从 <code>mas_makeConstraints:</code> 这个方法开始探寻 Masonry 的源码。上文说到，Masonry 中设置约束最常用的方法是</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 新增约束</span></span><br><span class="line"> <span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_makeConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br></pre></td></tr></table></figure>
<p> 同时，Masonry 还提供两个类方法用于更新和重建约束</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 更新约束</span></span><br><span class="line"> <span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_updateConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 清除旧约束，只保留新约束</span></span><br><span class="line"> <span class="selector-tag">-</span> (NSArray *)<span class="selector-tag">mas_remakeConstraints</span><span class="selector-pseudo">:(void(NS_NOESCAPE</span> ^)(MASConstraintMaker *make))<span class="selector-tag">block</span>;</span><br></pre></td></tr></table></figure>
<p> 这里我们就以  <code>mas_makeConstraints:</code>  为切入点开始分析 Masonry 这个框架。<code>mas_makeConstraints:</code>  这个方法位于分类<code>View+MASAdditions</code>中，方法的实现如下：</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 新增约束</span></span><br><span class="line"> - (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *))block &#123;</span><br><span class="line"> <span class="comment">/// 我们是手动添加约束，因此将自动转换关闭</span></span><br><span class="line"> <span class="keyword">self</span>.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line"> <span class="comment">/// 创建 MASConstraintMaker 对象</span></span><br><span class="line"> MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:<span class="keyword">self</span>];</span><br><span class="line"> <span class="comment">/// 通过 block 进行值的回调</span></span><br><span class="line"> block(constraintMaker);</span><br><span class="line"> <span class="comment">/// 调用 install 方法</span></span><br><span class="line"> <span class="keyword">return</span> [constraintMaker install];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 该方法先去掉 AutoResizing 的自动转换（如果这个属性没有被正确设置，那么视图的约束不会被成功添加），接着初始化一个 MASConstraintMaker 对象，传递到 block 中，执行 block，最后调用 install 方法。</p>
<p> 第一次点击进来看到这个方法之后，我有几处疑问。</p>
<ul>
<li><strong>第一，MASConstraintMaker 类内部做了什么操作？</strong></li>
<li><strong>第二，回调 <code>block(constraintMaker)</code>有什么用？</strong></li>
<li><strong>第三，调用 <code>[constraintMaker install]</code> 方法实现了什么？</strong></li>
</ul>
<p> 我们先来分析一下 MASConstraintMaker 这个类。MASConstraintMaker 是 Masonry 框架整个 DSL 过程的控制中心，它控制着整个添加过程，上文我们总结 Masonry 支持哪些属性时，总结的那些属性就来自 MASConstraintMaker 类。我们知道 Masonry 是基于 AutoLayout 进行的封装，所以接着我们一起来看下 MASConstraintMaker 是如何发挥作用的。下面是 MASConstraintMaker 的初始化</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">///  这里的 MAS_VIEW 是一个宏，#define MAS_VIEW UIView</span></span><br><span class="line"> - (<span class="keyword">id</span>)initWithView:(MAS_VIEW *)view &#123;</span><br><span class="line"> <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">self</span>.view = view;</span><br><span class="line"> <span class="keyword">self</span>.constraints = <span class="built_in">NSMutableArray</span>.new;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 从上边代码中我们可以清晰的看出，<strong>Masonry 在初始化 MASConstraintMaker 时，将当前的 view 赋给 MASConstraintMaker 类，并初始化一个  constraints 的空可变数组，作为约束数组</strong>。</p>
<p> 除此之外 MASConstraintMaker 还做了什么呢？</p>
<p> 先来到 MASConstraintMaker 的头文件 <code>MASConstraintMaker.h</code> 中，下面是一些比较常规的属性</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    以下属性返回一个新的 MASViewConstraint</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;      <span class="comment">// 左侧</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;       <span class="comment">// 上侧</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;     <span class="comment">// 右侧</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;    <span class="comment">// 下侧</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *leading;   <span class="comment">// 首部</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *trailing;  <span class="comment">// 尾部</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *width;     <span class="comment">// 宽</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *height;    <span class="comment">// 高</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerX;   <span class="comment">// 横向居中</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *centerY;   <span class="comment">// 纵向居中</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *baseline;  <span class="comment">// 文本基线</span></span><br></pre></td></tr></table></figure>
<p> 另外可以在 MASConstraintMaker 的 <code>MASConstraintMaker.m</code> 中看到另一个属性 <code>@property (nonatomic, strong) NSMutableArray *constraints</code> ，用来存储 MASConstraint<br> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable">@interface</span> MASConstraintMaker () &lt;MASConstraintDelegate&gt;</span><br><span class="line"> </span><br><span class="line"> <span class="variable">@property</span> (nonatomic, weak) MAS_VIEW *view;</span><br><span class="line"> <span class="comment">/// 存储 MASConstraint</span></span><br><span class="line"> <span class="variable">@property</span> (nonatomic, strong) NSMutableArray *constraints;</span><br><span class="line"> </span><br><span class="line"> <span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>接下来我们通过下面这个例子来分析上面这些属性：</p>
</blockquote>
 <figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> [<span class="name">imageView</span> mas_makeConstraints:^(<span class="name">MASConstraintMaker</span> *make) &#123;</span><br><span class="line"> make.top.bottom.left.right.equalTo(<span class="name">self.view</span>).insets(<span class="name">UIEdgeInsetsMake</span>(<span class="name">250</span>, <span class="number">100</span>, <span class="number">250</span>, <span class="number">100</span>))<span class="comment">;</span></span><br><span class="line"> &#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>block 中首先会执行 <code>make.top</code> ，会先调用一个增加约束的通用方法<code>- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code>  ，接着会调用 MASConstraintMaker 中 MASConstraintDelegate 的 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法。具体代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 重写 getter 方法</span></span><br><span class="line"> - (MASConstraint *)top &#123;</span><br><span class="line"> <span class="keyword">return</span> [self <span class="string">addConstraintWithLayoutAttribute:</span>NSLayoutAttributeTop];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 增加约束的通用方法</span></span><br><span class="line"> - (MASConstraint *)<span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> <span class="keyword">return</span> [self <span class="string">constraint:</span>nil <span class="string">addConstraintWithLayoutAttribute:</span>layoutAttribute];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 NSLayoutAttribute 添加约束</span></span><br><span class="line"> - (MASConstraint *)<span class="string">constraint:</span>(MASConstraint *)constraint <span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 构造 MASViewAttribute</span></span><br><span class="line"> MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] <span class="string">initWithView:</span>self.view <span class="string">layoutAttribute:</span>layoutAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 MASViewAttribute 构造第一个 MASViewConstraint</span></span><br><span class="line"> MASViewConstraint *newConstraint = [[MASViewConstraint alloc] <span class="string">initWithFirstViewAttribute:</span>viewAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint</span></span><br><span class="line"> <span class="keyword">if</span> ([constraint <span class="string">isKindOfClass:</span>MASViewConstraint.<span class="keyword">class</span>]) &#123;</span><br><span class="line"> <span class="comment">//replace with composite constraint</span></span><br><span class="line"> NSArray *children = @[constraint, newConstraint];</span><br><span class="line"> MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] <span class="string">initWithChildren:</span>children];</span><br><span class="line"> compositeConstraint.delegate = self;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 替换原来的 constraint 成新的 MASCompositeConstraint</span></span><br><span class="line"> [self <span class="string">constraint:</span>constraint <span class="string">shouldBeReplacedWithConstraint:</span>compositeConstraint];</span><br><span class="line"> <span class="keyword">return</span> compositeConstraint;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 不存在则设置 constraint 到 self.constraints</span></span><br><span class="line"> <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line"> <span class="comment">/// 设置delegate</span></span><br><span class="line"> newConstraint.delegate = self;</span><br><span class="line"> <span class="comment">/// 将约束添加到self.constraints</span></span><br><span class="line"> [self.constraints <span class="string">addObject:</span>newConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/// 返回刚刚创建的 MASViewConstraint 对象</span></span><br><span class="line"> <span class="keyword">return</span> newConstraint;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是，当调用 <code>make.top</code> 的时候会创建一个只有 firstViewAttribute 的 MASViewConstraint 对象，并且<strong>进入不存在 constraint 的代码部分</strong>，详情见代码块中的注释。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 不存在则设置 constraint 到 self.constraints</span></span><br><span class="line"> <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line"> <span class="comment">/// 设置delegate</span></span><br><span class="line"> <span class="keyword">new</span><span class="type">Constraint</span>.delegate = self;</span><br><span class="line"> <span class="comment">/// 将约束添加到self.constraints</span></span><br><span class="line"> [self.constraints addObject:<span class="type">newConstraint</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/// 返回刚刚创建的 MASViewConstraint 对象</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span><span class="type">Constraint</span>;</span><br></pre></td></tr></table></figure>
<p><strong>在这个方法的实现过程中，<code>make.top</code> 的返回值是 MASViewConstraint 对象</strong>。</p>
</li>
<li><p>当执行到 <code>make.top.bottom</code> 的时候，其实<strong>是对 MASViewConstraint 对象 .bottom 的调用</strong>，会走到 MASViewConstraint 中重写的 <code>- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code>方法，然后最终还是会调用这个代理方法 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> - (MASConstraint *)<span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> NSAssert(!self.hasLayoutRelation, @<span class="string">"Attributes should be chained before defining the constraint relation"</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> [self.delegate <span class="string">constraint:</span>self <span class="string">addConstraintWithLayoutAttribute:</span>layoutAttribute];</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 NSLayoutAttribute 添加约束</span></span><br><span class="line"> - (MASConstraint *)<span class="string">constraint:</span>(MASConstraint *)constraint <span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 构造 MASViewAttribute</span></span><br><span class="line"> MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] <span class="string">initWithView:</span>self.view <span class="string">layoutAttribute:</span>layoutAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 MASViewAttribute 构造第一个 MASViewConstraint</span></span><br><span class="line"> MASViewConstraint *newConstraint = [[MASViewConstraint alloc] <span class="string">initWithFirstViewAttribute:</span>viewAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint</span></span><br><span class="line"> <span class="keyword">if</span> ([constraint <span class="string">isKindOfClass:</span>MASViewConstraint.<span class="keyword">class</span>]) &#123;</span><br><span class="line"> <span class="comment">//replace with composite constraint</span></span><br><span class="line"> NSArray *children = @[constraint, newConstraint];</span><br><span class="line"> MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] <span class="string">initWithChildren:</span>children];</span><br><span class="line"> compositeConstraint.delegate = self;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 替换原来的 constraint 成新的 MASCompositeConstraint</span></span><br><span class="line"> [self <span class="string">constraint:</span>constraint <span class="string">shouldBeReplacedWithConstraint:</span>compositeConstraint];</span><br><span class="line"> <span class="keyword">return</span> compositeConstraint;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 不存在则设置 constraint 到 self.constraints</span></span><br><span class="line"> <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line"> <span class="comment">/// 设置delegate</span></span><br><span class="line"> newConstraint.delegate = self;</span><br><span class="line"> <span class="comment">/// 将约束添加到self.constraints</span></span><br><span class="line"> [self.constraints <span class="string">addObject:</span>newConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/// 返回刚刚创建的 MASViewConstraint 对象</span></span><br><span class="line"> <span class="keyword">return</span> newConstraint;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>和前面的执行过程不同，因为 MASViewConstraint 的 delegate 对象是刚才设置过的 MASConstraintMaker 对象，并且因为 constraint 不是 nil，所以会进入</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint</span></span><br><span class="line"> <span class="keyword">if</span> ([constraint <span class="string">isKindOfClass:</span>MASViewConstraint.<span class="keyword">class</span>]) &#123;</span><br><span class="line"> <span class="comment">//replace with composite constraint</span></span><br><span class="line"> NSArray *children = @[constraint, newConstraint];</span><br><span class="line"> MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] <span class="string">initWithChildren:</span>children];</span><br><span class="line"> compositeConstraint.delegate = self;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 替换原来的 constraint 成新的 MASCompositeConstraint</span></span><br><span class="line"> [self <span class="string">constraint:</span>constraint <span class="string">shouldBeReplacedWithConstraint:</span>compositeConstraint];</span><br><span class="line"> <span class="keyword">return</span> compositeConstraint;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>因此<strong>调用 make.top.bottom 返回的是一个 MASCompositeConstraint 对象</strong>。</p>
</li>
<li><p>当程序执行到 <code>make.top.bottom.left</code> 时，就<strong>是对 MASCompositeConstraint 中 .left 的调用</strong>，会走 MASCompositeConstraint 中的重写方法 <code>- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code>，接着会调用 <code>- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code>方法，最终还是会调用 <code>- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code>。代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> - (MASConstraint *)<span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> [self <span class="string">constraint:</span>self <span class="string">addConstraintWithLayoutAttribute:</span>layoutAttribute];</span><br><span class="line"> <span class="keyword">return</span> self;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> - (MASConstraint *)<span class="string">constraint:</span>(MASConstraint __unused *)constraint <span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> id&lt;MASConstraintDelegate&gt; strongDelegate = self.delegate;</span><br><span class="line"> MASConstraint *newConstraint = [strongDelegate <span class="string">constraint:</span>self <span class="string">addConstraintWithLayoutAttribute:</span>layoutAttribute];</span><br><span class="line"> newConstraint.delegate = self;</span><br><span class="line"> [self.childConstraints <span class="string">addObject:</span>newConstraint];</span><br><span class="line"> <span class="keyword">return</span> newConstraint;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 NSLayoutAttribute 添加约束</span></span><br><span class="line"> - (MASConstraint *)<span class="string">constraint:</span>(MASConstraint *)constraint <span class="string">addConstraintWithLayoutAttribute:</span>(NSLayoutAttribute)layoutAttribute &#123;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 构造 MASViewAttribute</span></span><br><span class="line"> MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] <span class="string">initWithView:</span>self.view <span class="string">layoutAttribute:</span>layoutAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 通过 MASViewAttribute 构造第一个 MASViewConstraint</span></span><br><span class="line"> MASViewConstraint *newConstraint = [[MASViewConstraint alloc] <span class="string">initWithFirstViewAttribute:</span>viewAttribute];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint</span></span><br><span class="line"> <span class="keyword">if</span> ([constraint <span class="string">isKindOfClass:</span>MASViewConstraint.<span class="keyword">class</span>]) &#123;</span><br><span class="line"> <span class="comment">//replace with composite constraint</span></span><br><span class="line"> NSArray *children = @[constraint, newConstraint];</span><br><span class="line"> MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] <span class="string">initWithChildren:</span>children];</span><br><span class="line"> compositeConstraint.delegate = self;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 替换原来的 constraint 成新的 MASCompositeConstraint</span></span><br><span class="line"> [self <span class="string">constraint:</span>constraint <span class="string">shouldBeReplacedWithConstraint:</span>compositeConstraint];</span><br><span class="line"> <span class="keyword">return</span> compositeConstraint;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 不存在则设置 constraint 到 self.constraints</span></span><br><span class="line"> <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line"> newConstraint.delegate = self;</span><br><span class="line"> [self.constraints <span class="string">addObject:</span>newConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> newConstraint;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> <strong>但这次 <code>if ([constraint isKindOfClass:MASViewConstraint.class])</code> 与 <code>if (!constraint)</code> 都不会进入，只直接返回 MASViewConstraint 对象，然后回到 <code>- (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute</code> 方法中设置它的 delegate，并且将对象存入 MASCompositeConstraint 的 childConstraints 中。</strong></p>
<ul>
<li><p>之后再有更多的链式 MASConstraint 的组合（比如执行到 <code>make.top.bottom.left.right</code>），也只是 MASCompositeConstraint 的调用，直接加入 childConstraints 中即可。</p>
</li>
<li><p>至于 <code>equalTo(self.view)</code> 的调用过程，这里有必要说明一下，<code>equalTo(self.view)</code> 在文件 MASConstraint 中执行 <code>- (MASConstraint * (^)(id))equalTo</code> 方法，接着调用 MASViewConstraint 中的 <code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation</code> 方法。代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> <span class="comment">/// MASConstraint 是一个抽象类，其中有很多的方法都必须在子类中覆写。Masonry 中有两个 MASConstraint 的子类，分别是 MASViewConstraint 和 MASCompositeConstraint</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// MASConstraint.m</span></span><br><span class="line"> - (MASConstraint * (^)(<span class="keyword">id</span>))equalTo &#123;</span><br><span class="line"> <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>.equalToWithRelation(attribute, <span class="built_in">NSLayoutRelationEqual</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// MASViewConstraint.m</span></span><br><span class="line"> - (MASConstraint * (^)(<span class="keyword">id</span>, <span class="built_in">NSLayoutRelation</span>))equalToWithRelation &#123;</span><br><span class="line"> <span class="keyword">return</span> ^<span class="keyword">id</span>(<span class="keyword">id</span> attribute, <span class="built_in">NSLayoutRelation</span> relation) &#123;</span><br><span class="line"> <span class="keyword">if</span> ([attribute isKindOfClass:<span class="built_in">NSArray</span>.class]) &#123;</span><br><span class="line"> <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation, <span class="string">@"Redefinition of constraint relation"</span>);</span><br><span class="line"> <span class="built_in">NSMutableArray</span> *children = <span class="built_in">NSMutableArray</span>.new;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">id</span> attr <span class="keyword">in</span> attribute) &#123;</span><br><span class="line"> MASViewConstraint *viewConstraint = [<span class="keyword">self</span> <span class="keyword">copy</span>];</span><br><span class="line"> viewConstraint.layoutRelation = relation;</span><br><span class="line"> viewConstraint.secondViewAttribute = attr;</span><br><span class="line"> [children addObject:viewConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line"> compositeConstraint.delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line"> [<span class="keyword">self</span>.delegate constraint:<span class="keyword">self</span> shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line"> <span class="keyword">return</span> compositeConstraint;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="built_in">NSAssert</span>(!<span class="keyword">self</span>.hasLayoutRelation || <span class="keyword">self</span>.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:<span class="built_in">NSValue</span>.class], <span class="string">@"Redefinition of constraint relation"</span>);</span><br><span class="line"> <span class="keyword">self</span>.layoutRelation = relation;</span><br><span class="line"> <span class="keyword">self</span>.secondViewAttribute = attribute;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> <code>- (MASConstraint * (^)(id))equalTo</code> 方法提供了参数 attribute 和布局关系 NSLayoutRelationEqual，这两个参数会传递到 <code>- (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation</code> 中，设置 constraint 的布局关系和 secondViewAttribute 属性，为 <code>[constraintMaker install]</code> 做准备。</p>
<p> 到这里基本上就把上文的那个例子说完了，通过例子让我们对 MASConstraintMaker 中的一些常规属性有了一定的了解，同时也明白了 <code>block(constraintMaker)</code> 这个方法的作用——<strong>在调用  <code>block(constraintMaker)</code> 时，对 constraintMaker 进行配置</strong>。 MASConstraintMaker 中还有一些别的属性，我们再一起来看看吧</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  返回一个 block 对象，block 的接收参数是 MASAttribute 类型，返回一个 MASCompositeConstraint 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *(^attributes)(MASAttribute attrs);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    返回一个 MASConstraint 对象，包含上下左右的布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *edges;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    返回一个 MASConstraint 对象，包含宽高的布局</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *size;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *    返回一个 MASConstraint 对象，包含 centerX 和 centerY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *center;</span><br></pre></td></tr></table></figure>
<p> 这里只简单的介绍一下上面的几个属性</p>
<blockquote>
<ol>
<li><code>attributes</code>：返回一个 block 对象，block 的接收参数是 MASAttribute 类型，返回 MASCompositeConstraint 对象<ol start="2">
<li><code>edges</code>：返回一个 MASConstraint 对象，同时包含了上下左右的布局</li>
<li><code>size</code>：返回一个 MASConstraint 对象，同时包含了宽高的布局</li>
<li><code>center</code>：返回一个 MASConstraint 对象，同时包含了 centerX 和centerY</li>
</ol>
</li>
</ol>
</blockquote>
<p> <strong>接下来我们来分析 <code>[constraintMaker install]</code> 方法</strong>。</p>
<p> 我们在<code>- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block</code> 方法的最后会调用 <code>[constraintMaker install]</code>  方法来添加所有存储在 <code>self.constraints</code> 数组中的所有约束。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">NSArray</span> *)install &#123;</span><br><span class="line"> <span class="comment">/// 是否需要删除原来的约束</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.removeExisting) &#123;</span><br><span class="line"> <span class="comment">/// 获得所有约束</span></span><br><span class="line"> <span class="built_in">NSArray</span> *installedConstraints = [MASViewConstraint installedConstraintsForView:<span class="keyword">self</span>.view];</span><br><span class="line"> <span class="comment">/// 删除所有约束</span></span><br><span class="line"> <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> installedConstraints) &#123;</span><br><span class="line"> [constraint uninstall];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">NSArray</span> *constraints = <span class="keyword">self</span>.constraints.copy;</span><br><span class="line"> <span class="keyword">for</span> (MASConstraint *constraint <span class="keyword">in</span> constraints) &#123;</span><br><span class="line"> constraint.updateExisting = <span class="keyword">self</span>.updateExisting;</span><br><span class="line"> [constraint install];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/// 去除所有缓存的约束结构体</span></span><br><span class="line"> [<span class="keyword">self</span>.constraints removeAllObjects];</span><br><span class="line"> <span class="keyword">return</span> constraints;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 这个方法会先判断当前视图的约束是否需要删除，如果我们之前调用过 <code>- (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block</code> 这个方法（它会把 removeExisting 的 BOOL 值设为 YES），那么视图中的原有约束就会被全被删除。接着往下走，程序会遍历 constraints 数组，发送 install 消息。</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// MASViewConstraint.m</span></span><br><span class="line"> - (<span class="keyword">void</span>)install &#123;</span><br><span class="line"> <span class="comment">/// 已经有约束</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.hasBeenInstalled) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 支持 active 且已经有约束</span></span><br><span class="line"> <span class="keyword">if</span> ([<span class="keyword">self</span> supportsActiveProperty] &amp;&amp; <span class="keyword">self</span>.layoutConstraint) &#123;</span><br><span class="line"> <span class="comment">/// 激活约束</span></span><br><span class="line"> <span class="keyword">self</span>.layoutConstraint.active = <span class="literal">YES</span>;</span><br><span class="line"> <span class="comment">/// 添加约束缓存</span></span><br><span class="line"> [<span class="keyword">self</span>.firstViewAttribute.view.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 获得 firstLayoutItem, firstLayoutAttribute, secondLayoutItem, secondLayoutAttribute</span></span><br><span class="line"> MAS_VIEW *firstLayoutItem = <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line"> <span class="built_in">NSLayoutAttribute</span> firstLayoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line"> MAS_VIEW *secondLayoutItem = <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line"> <span class="built_in">NSLayoutAttribute</span> secondLayoutAttribute = <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// alignment attributes must have a secondViewAttribute</span></span><br><span class="line"> <span class="comment">// therefore we assume that is refering to superview</span></span><br><span class="line"> <span class="comment">// eg make.left.equalTo(@10)</span></span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute &amp;&amp; !<span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line"> secondLayoutItem = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line"> secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// NSLayoutConstraint 的创建，生成约束，MASLayoutConstraint 其实就是 NSLayoutConstraint 的别名</span></span><br><span class="line"> MASLayoutConstraint *layoutConstraint</span><br><span class="line"> = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line"> attribute:firstLayoutAttribute</span><br><span class="line"> relatedBy:<span class="keyword">self</span>.layoutRelation</span><br><span class="line"> toItem:secondLayoutItem</span><br><span class="line"> attribute:secondLayoutAttribute</span><br><span class="line"> multiplier:<span class="keyword">self</span>.layoutMultiplier</span><br><span class="line"> constant:<span class="keyword">self</span>.layoutConstant];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 设置 priority 和 mas_key</span></span><br><span class="line"> layoutConstraint.priority = <span class="keyword">self</span>.layoutPriority;</span><br><span class="line"> layoutConstraint.mas_key = <span class="keyword">self</span>.mas_key;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 如果 secondViewAttribute 有 view 对象</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line"> <span class="comment">/// 取得两个 view 的最小公共 view</span></span><br><span class="line"> MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line"> <span class="built_in">NSAssert</span>(closestCommonSuperview,</span><br><span class="line"> <span class="string">@"couldn't find a common superview for %@ and %@"</span>,</span><br><span class="line"> <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 设置约束 view 为此 view</span></span><br><span class="line"> <span class="keyword">self</span>.installedView = closestCommonSuperview;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line"> <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 已经存在的约束</span></span><br><span class="line"> MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123; <span class="comment">// 需要更新</span></span><br><span class="line"> existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (existingConstraint) &#123; <span class="comment">// 如果存在则替换约束</span></span><br><span class="line"> <span class="comment">// just update the constant</span></span><br><span class="line"> existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line"> <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">/// 其它情况则直接添加约束</span></span><br><span class="line"> [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line"> <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line"> [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 上面这个方法是为当前视图添加约束的最后的方法，首先这个方法会先获取即将用于初始化 NSLayoutConstraint 的子类的几个属性</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// MASViewConstraint.m</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 获得 firstLayoutItem, firstLayoutAttribute, secondLayoutItem, secondLayoutAttribute</span></span><br><span class="line"> MAS_VIEW *firstLayoutItem = <span class="keyword">self</span>.firstViewAttribute.item;</span><br><span class="line"> <span class="built_in">NSLayoutAttribute</span> firstLayoutAttribute = <span class="keyword">self</span>.firstViewAttribute.layoutAttribute;</span><br><span class="line"> MAS_VIEW *secondLayoutItem = <span class="keyword">self</span>.secondViewAttribute.item;</span><br><span class="line"> <span class="built_in">NSLayoutAttribute</span> secondLayoutAttribute = <span class="keyword">self</span>.secondViewAttribute.layoutAttribute;</span><br></pre></td></tr></table></figure>
<p> 然后判断当前即将添加的约束，如果不是 size 类型并且没有提供 self.secondViewAttribute，会自动将约束添加到 superview 上</p>
 <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> /<span class="regexp">//</span> MASViewConstraint.m</span><br><span class="line"> <span class="keyword">if</span> (!<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute &amp;&amp; !<span class="keyword">self</span>.secondViewAttribute) &#123;</span><br><span class="line"> secondLayoutItem = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line"> secondLayoutAttribute = firstLayoutAttribute;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 接着创建 MASLayoutConstraint 对象</p>
 <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// MASViewConstraint.m</span></span><br><span class="line"> <span class="comment">/// NSLayoutConstraint 的创建，生成约束，MASLayoutConstraint 其实就是 NSLayoutConstraint 的别名</span></span><br><span class="line"> MASLayoutConstraint *layoutConstraint</span><br><span class="line"> = [MASLayoutConstraint constraintWithItem:firstLayoutItem</span><br><span class="line"><span class="symbol"> attribute:</span>firstLayoutAttribute</span><br><span class="line"><span class="symbol"> relatedBy:</span>self.layoutRelation</span><br><span class="line"><span class="symbol"> toItem:</span>secondLayoutItem</span><br><span class="line"><span class="symbol"> attribute:</span>secondLayoutAttribute</span><br><span class="line"><span class="symbol"> multiplier:</span>self.layoutMultiplier</span><br><span class="line"><span class="symbol"> constant:</span>self.layoutConstant];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 设置 priority 和 mas_key</span></span><br><span class="line"> layoutConstraint.priority = self.layoutPriority;</span><br><span class="line"> layoutConstraint.mas_key = self.mas_key;</span><br></pre></td></tr></table></figure>
<p> 创建完约束对象后，我们要寻找该约束添加到那个 View 上。下方的代码段就是获取接收该约束对象的视图。如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。代码实现如下：</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// MASViewConstraint.m</span></span><br><span class="line"> <span class="comment">/// 如果 secondViewAttribute 有 view 对象</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.secondViewAttribute.view) &#123;</span><br><span class="line"> <span class="comment">/// 取得两个 view 的最小公共 view</span></span><br><span class="line"> MAS_VIEW *closestCommonSuperview = [<span class="keyword">self</span>.firstViewAttribute.view mas_closestCommonSuperview:<span class="keyword">self</span>.secondViewAttribute.view];</span><br><span class="line"> <span class="built_in">NSAssert</span>(closestCommonSuperview,</span><br><span class="line"> <span class="string">@"couldn't find a common superview for %@ and %@"</span>,</span><br><span class="line"> <span class="keyword">self</span>.firstViewAttribute.view, <span class="keyword">self</span>.secondViewAttribute.view);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/// 设置约束 view 为此 view</span></span><br><span class="line"> <span class="keyword">self</span>.installedView = closestCommonSuperview;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.firstViewAttribute.isSizeAttribute) &#123;</span><br><span class="line"> <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">self</span>.installedView = <span class="keyword">self</span>.firstViewAttribute.view.superview;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p> 加约束时我们要判断是否需要对约束进行更新，如果需要，就替换约束，如果不需要就直接添加约束即可。添加成功后我们将通过 mas_installedConstraints 属性记录一下本次添加的约束。<br> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// 已经存在的约束</span></span><br><span class="line"> MASLayoutConstraint *existingConstraint = <span class="literal">nil</span>;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">self</span>.updateExisting) &#123; <span class="comment">// 需要更新</span></span><br><span class="line"> existingConstraint = [<span class="keyword">self</span> layoutConstraintSimilarTo:layoutConstraint];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (existingConstraint) &#123; <span class="comment">// 如果存在则替换约束</span></span><br><span class="line"> <span class="comment">// just update the constant</span></span><br><span class="line"> existingConstraint.constant = layoutConstraint.constant;</span><br><span class="line"> <span class="keyword">self</span>.layoutConstraint = existingConstraint;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="comment">/// 其它情况则直接添加约束</span></span><br><span class="line"> [<span class="keyword">self</span>.installedView addConstraint:layoutConstraint];</span><br><span class="line"> <span class="keyword">self</span>.layoutConstraint = layoutConstraint;</span><br><span class="line"> [firstLayoutItem.mas_installedConstraints addObject:<span class="keyword">self</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>到此为止，对 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>  源码的简单介绍已接近尾声了。。。<a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a>  的代码流程简单来讲就是提供给我们一个 MASConstraintMaker，然后我们根据 Masonry 提供的语法，添加约束。最后 Masonry 解析约束，将真正的约束关系添加到相应的视图上。</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/数据结构 -《大话数据结构》读书笔记(1)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/数据结构 -《大话数据结构》读书笔记(1)/" itemprop="url">
                  数据结构 -《大话数据结构》读书笔记(1)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>前公司的经理大哥建议过我，说趁年轻要深入学习算法与数据结构，设计模式， APP 架构，当然也包括 iOS 底层的一些知识……半年多过去了，算法数据结构方面的书多少算是看过一些，但都是走马观花似的一掠而过，根本没留下什么印象……2018 突然就到了……接下来会多读书，并记录下来，算是对自己的督促，更希望对看到的朋友有所帮助。</strong></p>
</blockquote>
<h5 id="文章共分为三篇"><a href="#文章共分为三篇" class="headerlink" title="文章共分为三篇"></a>文章共分为三篇</h5><h5 id="第一篇：数据结构-《大话数据结构》读书笔记-1"><a href="#第一篇：数据结构-《大话数据结构》读书笔记-1" class="headerlink" title="第一篇：数据结构 -《大话数据结构》读书笔记(1)"></a><a href="https://www.jianshu.com/p/72aabf06a450" target="_blank" rel="noopener">第一篇：数据结构 -《大话数据结构》读书笔记(1)</a></h5><p><strong>一、数据结构绪论<br>二、算法<br>三、线性表</strong></p>
<h5 id="第二篇：数据结构-《大话数据结构》读书笔记-2"><a href="#第二篇：数据结构-《大话数据结构》读书笔记-2" class="headerlink" title="第二篇：数据结构 -《大话数据结构》读书笔记(2)"></a><a href="https://www.jianshu.com/p/c7c16110b796" target="_blank" rel="noopener">第二篇：数据结构 -《大话数据结构》读书笔记(2)</a></h5><p><strong>四、栈与队列<br>五、串<br>六、树<br>七、图</strong></p>
<h5 id="第三篇：数据结构-《大话数据结构》读书笔记-3"><a href="#第三篇：数据结构-《大话数据结构》读书笔记-3" class="headerlink" title="第三篇：数据结构 -《大话数据结构》读书笔记(3)"></a><a href="https://www.jianshu.com/p/4fb2481c9b06" target="_blank" rel="noopener">第三篇：数据结构 -《大话数据结构》读书笔记(3)</a></h5><p><strong>八、查找<br>九、排序</strong></p>
<hr>
<h2 id="一、数据结构绪论"><a href="#一、数据结构绪论" class="headerlink" title="一、数据结构绪论"></a>一、数据结构绪论</h2><h4 id="1-1-数据结构"><a href="#1-1-数据结构" class="headerlink" title="1.1 数据结构"></a>1.1 数据结构</h4><p><strong><code>数据结构</code>是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</strong></p>
<h4 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h4><ul>
<li>数据<br><strong><code>数据</code>是描述<code>客观事物</code>的符号，是计算机中可以<code>操作的对象</code>，是能被计算机识别，并输入给计算机处理的<code>符号集合</code>。</strong></li>
</ul>
<p>数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。</p>
<ul>
<li>数据元素<br><strong><code>数据元素</code>是组成数据的、有一定意义的<code>基本单位</code>，在计算机中通常作为整体处理，也被称为<code>记录</code>。</strong></li>
</ul>
<p>比如动物类中，牛、马、羊、鸡、鸭、鹅就是其数据元素。</p>
<ul>
<li>数据项<br><strong>一个<code>数据元素</code>可以由若干<code>数据项</code>组成。数据项是数据不可分割的<code>最小单位</code>。</strong></li>
</ul>
<p>比如人这样的数据元素，有眼、耳、鼻、口、手、脚这些数据项，也可以有姓名、年龄、性别、出生地址、联系电话等数据项，具体哪些数据项，要根据你的系统决定。</p>
<ul>
<li>数据对象<br><strong><code>数据对象</code>是性质相同的<code>数据元素的集合</code>，是<code>数据的子集</code>。</strong></li>
</ul>
<p>所谓性质相同，是指数据元素具有相同数量和类型的数据项，比如人都有姓名，性别，生日等相同的数据项。</p>
<ul>
<li><p>数据结构<br><strong><code>数据结构</code>是相互之间存在<code>一种或多种</code>特定关系的<code>数据元素的集合</code>。</strong></p>
</li>
<li><p>研究数据结构的意义：<br><strong>在计算机中，数据元素不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。为编写一个好的程序，必须分析待处理对象的特性及各处理对象之间存在的关系。这也就是研究数据结构的意义所在。</strong></p>
</li>
</ul>
<h4 id="1-3-逻辑结构和物理结构："><a href="#1-3-逻辑结构和物理结构：" class="headerlink" title="1.3 逻辑结构和物理结构："></a>1.3 逻辑结构和物理结构：</h4><p>按照视点的不同，可以把数据结构分为<code>逻辑结构</code>和<code>物理结构</code>。</p>
<ul>
<li><p>逻辑结构<br><strong><code>逻辑结构</code>是指数据对象中<code>数据元素之间的相互关系</code>。</strong></p>
</li>
<li><p>逻辑结构分为以下四种：</p>
</li>
<li>集合结构：<code>集合结构</code>中的数据元素除了<code>同属于一个集合</code>外，它们之间<code>没有其他关系</code>。各个数据元素是“平等”的，它们的共同属性是<code>同属于一个集合</code>。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-965d331ae5f588a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="集合结构"></li>
<li>线性结构：<code>线性结构</code>中的数据元素是<code>一对一</code>的关系。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-da4601e22a9ea8f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性结构"></li>
<li>树形结构：<code>树形结构</code>中的元素之间存在一种<code>一对多</code>的层次关系。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-f39ac07df093ecd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树形结构"></li>
<li><p>图形结构：<code>图形结构</code>的数据元素是<code>多对多</code>的关系。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-b6c5ce5f746881f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树形结构"></p>
</li>
<li><p>物理结构<br><strong>物理结构（存储结构）：是指数据的<code>逻辑结构</code>在计算机中的<code>存储形式</code>。</strong></p>
</li>
</ul>
<p>数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。<strong>数据的存储结构应正确反映数据元素之间的逻辑关系</strong>，这才是最关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。</p>
<p><strong>数据元素的存储结构形式有两种：<code>顺序存储</code>和<code>链式存储</code>。</strong></p>
<ul>
<li>顺序存储结构<br><strong>顺序存储结构：是把数据元素存放在<code>地址连续的存储单元</code>里，其数据间的<code>逻辑关系和物理关系是一致的</code>。</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-893e98e0fdd324e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="顺序存储结构"></p>
<p>顺序存储结构说白了就是排队占位，大家都按顺序排好，每个人占一小段控件，大家谁也别插谁的队。数组就是这样的顺序存储结构。</p>
<ul>
<li>链式存储结构<br><strong>链式存储结构：是把数据元素存放在<code>任意的存储单元</code>里，这组存储单元<code>可以是连续的，也可以是不连续的</code>。</strong></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-ae6a789dc4f0f54e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="链式存储结构"></p>
<p>数据元素的存储关系并不能反应其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。<strong>链式存储结构比较灵活，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了</strong>。比如现在去银行医院等地方，去了先领一个号，等着叫号，在等待的时候你可以做任何事情，只要及时回来就行。</p>
<h4 id="1-4-抽象数据类型："><a href="#1-4-抽象数据类型：" class="headerlink" title="1.4 抽象数据类型："></a>1.4 抽象数据类型：</h4><ul>
<li>数据类型<br><strong>数据类型：是指一组<code>性质相同的值的集合</code>及定义在此集合上的一些<code>操作的总称</code>。</strong></li>
</ul>
<p>数据类型是按照值的不同进行划分的，在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。</p>
<ul>
<li>抽象<br><strong>抽象：抽象是指<code>抽取出事物具有的普遍性的本质</code>。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。</strong></li>
</ul>
<p>在C语言中，按照取值的不同，数据类型可以分为两类：</p>
<ul>
<li><code>原子类型</code>：是不可以再分解的基本类型，包括整型、实型、字符型等；</li>
<li><p><code>数据类型</code>：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。</p>
</li>
<li><p>抽象数据类型<br><strong>抽象数据类型：是指一个<code>数学模型</code>及<code>定义在该模型上的一组操作</code>。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算及内部如何表示和实现无关。</strong></p>
</li>
</ul>
<p>比如在大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，它们都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。</p>
<h2 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h2><h4 id="2-1-算法定义"><a href="#2-1-算法定义" class="headerlink" title="2.1 算法定义"></a>2.1 算法定义</h4><p><strong>算法是解决待定问题求解<code>步骤的描述</code>，在计算机中表现为<code>指令的有限序列</code>，并且每条指令表示一个或多个操作。</strong></p>
<h4 id="2-2-算法的特性"><a href="#2-2-算法的特性" class="headerlink" title="2.2 算法的特性"></a>2.2 算法的特性</h4><p><strong>算法有五个基本特性：<code>输入</code>、<code>输出</code>、<code>有穷性</code>、<code>确定性</code>和<code>可行性</code>。</strong></p>
<ul>
<li><p>输入输出<br><strong>输入和输出特性比较容易理解，算法具有<code>零个或多个输入</code>。绝大多数算法需要输入参数，但有的是不需要的，不如“hello world”这样的代码，不需要任何参数，因此算法的<code>输入可以是零个</code>。算法至少有<code>一个或多个输出</code>，算法是<code>一定要输出</code>的，不需要输出，那用这个算法干嘛？输出的形式可以使打印输出，也可以是返回一个或多个值。</strong></p>
</li>
<li><p>有穷性<br><strong>有穷性：指算法在执行有限的步骤之后，<code>自动结束</code>而不会出现无限循环，并且每一个步骤在<code>可接受的时间内</code>完成。</strong></p>
</li>
<li><p>确定性：<br><strong>算法的每一步骤都具有确定的含义，不会出现<code>二义性</code>。</strong></p>
</li>
</ul>
<p>算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果，算法的每个步骤被精确定义而无歧义。</p>
<ul>
<li>可行性：<br><strong>算法的每一步都必须是<code>可行的</code>，也就是说，每一步都能够通过执行<code>有限次数</code>完成。</strong></li>
</ul>
<h4 id="2-3-算法设计的要求"><a href="#2-3-算法设计的要求" class="headerlink" title="2.3 算法设计的要求"></a>2.3 算法设计的要求</h4><p>算法不是唯一的，同一个问题，可以有很多种解决问题的算法。好的算法应该具有以下几点要求：</p>
<ul>
<li>正确性：<br><strong>正确性：算法的<code>正确性</code>是指算法至少应该具有<code>输入</code>、<code>输出</code>和<code>加工处理无歧义性</code>、<code>能正确反映问题</code>的需求、能够<code>得到问题的正确答案</code>。</strong></li>
</ul>
<p><strong>算法的“正确”通常在语法上有很大的差别，大体分为以下四个层次。</strong></p>
<ol>
<li>算法程序没有语法错误；</li>
<li>算法程序对于合法的输入数据能够产生满足要求的输出结果；</li>
<li>算法程序对于非法的输入数据能够得出满足规格说明的结果；</li>
<li>算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。</li>
</ol>
<p><strong>一般情况下，我们把层次 3 作为算法是否正确的标准。</strong></p>
<ul>
<li>可读性：<br><strong>可读性：算法设计的另一目的是为了便于<code>阅读、理解和交流</code>。</strong></li>
</ul>
<p>我们写代码的目的，一方面是为了让计算机执行，另一方面是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了什么，<strong>可读性是算法好坏的一个很重要的标志</strong>。</p>
<ul>
<li><p>健壮性<br><strong>健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。</strong></p>
</li>
<li><p>时间效率高和存储量低<br><strong>时间效率指的是<code>算法的执行时间</code>，对于同一个问题，如果有多个算法可以解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的<code>最大存储空间</code>，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足<code>时间效率高</code>和<code>存储量低的需求</code>。</strong></p>
</li>
</ul>
<p><strong>综上，好的算法，应该具有<code>正确性</code>、<code>可读性</code>、<code>健壮性</code>、<code>高效性</code>和<code>低存储量</code>的特点。</strong></p>
<h4 id="2-4-函数的渐进增长"><a href="#2-4-函数的渐进增长" class="headerlink" title="2.4 函数的渐进增长"></a>2.4 函数的渐进增长</h4><ul>
<li>函数的渐进增长：给定两个函数f(n)与g(n)，如果存在一个整数N，使得对于<strong>所有n&gt;N，f(n)总是比g(n)大</strong>，那么，我们说<strong>f(n)的增长渐进快于g(n)</strong>。</li>
</ul>
<p><strong>例子 1：</strong><br>A 算法与 B 算法，A 算法要做 2n+3 次操作；B 算法要做 3n+1 次操作。问哪个执行的更快？<br><img src="http://upload-images.jianshu.io/upload_images/2665449-f0cc0dfaa7208aa0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>由上图可知，当 n = 1，算法 A 效率不如算法 B；当 n = 2 时，两者效率相同；当 n &gt; 2 时，算法A开始优于算法 B了。得出结论，<strong>加法常数可以忽略</strong>。</p>
<p><strong>例子 2：</strong></p>
<p>C 算法与 D 算法，C 算法要做 4n+8 次操作；D 算法要做 2 n*n +1 次操作。问哪个执行的更快？<br><img src="http://upload-images.jianshu.io/upload_images/2665449-b9a0cc927dd5b823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>由上图可知，当 n &lt;= 3 时，算法 C 差于算法 D；当 n &gt; 3 时，算法 C 的优势开始越来越优于算法 D 了。得出结论：<strong>与最高次项相乘的常数并不重要</strong>。</p>
<h4 id="2-5-算法时间复杂度"><a href="#2-5-算法时间复杂度" class="headerlink" title="2.5 算法时间复杂度"></a>2.5 算法时间复杂度</h4><ul>
<li>算法时间复杂度定义<br><strong>算法时间复杂度：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是<code>算法的时间量度</code>，记作：T(n) = O(f(n))。它表示<code>随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度</code>。其中 f(n) 是问题规模 n 的某个函数。</strong></li>
</ul>
<p>这样用大写 O() 来体系那算法时间复杂度的记法，我们称之为大 O 记法。</p>
<p>一般情况下，随着n的增大，<strong>T(n) 增长最慢的算法为最优算法</strong>。</p>
<ul>
<li>常用的算法时间复杂度<br><img src="http://upload-images.jianshu.io/upload_images/2665449-bab7a7f9c8a09ce5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<ul>
<li>推导大 O 阶方法</li>
<li>用常数 1 取代运行时间中的所有加法常数</li>
<li>在修改后的运行次数函数中，只保留最高阶项</li>
<li>如果最高阶项存在且不是 1，则去除与这个项相乘的常数。</li>
</ul>
<p><strong>得到的结果就是大 O 阶</strong>。</p>
<h4 id="2-6-算法空间复杂度"><a href="#2-6-算法空间复杂度" class="headerlink" title="2.6 算法空间复杂度"></a>2.6 算法空间复杂度</h4><ul>
<li>算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，<code>n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数</code>。</li>
</ul>
<p>一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入的数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(n)。</p>
<p>通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指<code>时间复杂度</code>。</p>
<h2 id="三、线性表"><a href="#三、线性表" class="headerlink" title="三、线性表"></a>三、线性表</h2><h4 id="3-1-线性表定义"><a href="#3-1-线性表定义" class="headerlink" title="3.1 线性表定义"></a>3.1 线性表定义</h4><p><strong>零个或多个数据元素的<code>有限序列</code>。</strong></p>
<p>首先它是一个<code>序列</code>。也就是说，元素之间是<code>有顺序</code>的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其它元素都有且只有一个前驱一个后继。</p>
<p>然后，线性表强调是<code>有限的</code>，即元素个数是有限的。</p>
<h4 id="3-2-线性表的抽象数据类型"><a href="#3-2-线性表的抽象数据类型" class="headerlink" title="3.2 线性表的抽象数据类型"></a>3.2 线性表的抽象数据类型</h4><p>对于一个线性表来说，插入或者删除数据都是必须的操作，因此<code>线性表的抽象数据类型</code>定义如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT线性表(List)</span><br><span class="line">Data</span><br><span class="line">线性表的数据对象集合为 (a1, a2, a3, ……, an)， 每个元素的类型均为 DataType。其中，除第一个元素外，每个元素有且只有一个直接前驱元素；除了最后一个元素外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</span><br><span class="line">Operation</span><br><span class="line">InitList (*L) : 初始化操作，建立一个空的线性表L。</span><br><span class="line">ListEmpty (L): 若线性表为空，返回 true，否则返回 false。</span><br><span class="line">ClearList (*L): 将线性表清空。</span><br><span class="line">GetElem (L, <span class="selector-tag">i</span>, *e): 将线性表 L 中的第 <span class="selector-tag">i</span> 个元素值返回给 e。</span><br><span class="line">LocateElem (L, e): 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 <span class="number">0</span> 表示失败。</span><br><span class="line">ListInsert (*L, <span class="selector-tag">i</span>, e):  在线性表 L 中的第 <span class="selector-tag">i</span> 个位置插入新元素 e。</span><br><span class="line">ListDelete (*L, <span class="selector-tag">i</span>, *e): 删除线性表 L 中第 <span class="selector-tag">i</span> 个位置元素，并用 e 返回其值。</span><br><span class="line">ListLength (L): 返回线性表 L 的元素个数。</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。</p>
<h4 id="3-3-线性表的顺序存储结构"><a href="#3-3-线性表的顺序存储结构" class="headerlink" title="3.3 线性表的顺序存储结构"></a>3.3 线性表的顺序存储结构</h4><h6 id="3-3-1-顺序存储定义"><a href="#3-3-1-顺序存储定义" class="headerlink" title="3.3.1 顺序存储定义"></a>3.3.1 顺序存储定义</h6><p>先来看看线性表的两种物理结构的第一种——<code>顺序存储结构</code>。</p>
<ul>
<li>顺序存储结构<br><strong>线性表的顺序存储结构，指的是用一段<code>地址连续</code>的存储单元依次存储线性表的数据元素。</strong></li>
</ul>
<p>线性表的顺序存储示意图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-502f2a91d807ab66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="线性表的顺序存储"></p>
<h6 id="3-3-2-顺序存储方式"><a href="#3-3-2-顺序存储方式" class="headerlink" title="3.3.2 顺序存储方式"></a>3.3.2 顺序存储方式</h6><p>线性表的<code>顺序存储结构</code>，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用 C 语言（其它语言也相同）的<strong>一维数组来实现顺序存储结构</strong>，即<strong>把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。</strong></p>
<ul>
<li><p>线性表顺序存储的结构代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储空间初始分配量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ElemType 类型根据实际情况而定，这里假设为 int */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* 数组存储数据元素，最大值为 MAXSIZE */</span></span><br><span class="line">ElemType data [MAXSIZE];</span><br><span class="line"><span class="comment">/* 线性表当前长度 */</span></span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里我们发现描述顺序存储结构需要三个属性：</p>
</li>
<li>存储空间的起始位置：数组 <code>data</code>， 它的存储位置就是存储空间的存储位置。</li>
<li>线性表的最大存储容量：数组长度 <code>MAXSIZE</code>。</li>
<li>线性表的当前长度：<code>length</code>。</li>
</ul>
<h6 id="3-3-3-数据长度与线性表长度区别"><a href="#3-3-3-数据长度与线性表长度区别" class="headerlink" title="3.3.3 数据长度与线性表长度区别"></a>3.3.3 数据长度与线性表长度区别</h6><ul>
<li><p><code>数组长度</code>指的是存放线性表的存储空间的长度，存储分配后这个量一般是<strong>不变</strong>的（一般高级语言，比如 C，VB， C++都可以用编程手段实现动态分配数组长度，不过这回带来性能上的损耗）。</p>
</li>
<li><p><code>线性表的长度</code>指的是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p>
</li>
</ul>
<p><strong>在任何时刻，线性表的长度都应该小于等于数组的长度。</strong></p>
<h6 id="3-3-4-地址计算方法"><a href="#3-3-4-地址计算方法" class="headerlink" title="3.3.4 地址计算方法"></a>3.3.4 地址计算方法</h6><p>C 语言中的数组是从 0 开始第一个下标的，<strong>线性表的第 i 个元素是要存储在数组下标为<code>i - 1</code>的位置</strong>，即数据元素的序号和存放它的数组下标之间存在对应关系（如下图）。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-85aabcb4d50e6367.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此<strong>分配的数组空间要大于等于当前线性表的长度</strong>。</p>
<ul>
<li>地址<br><strong>存储器中的每个存储单元都有自己的编号，这个编号称为地址。</strong></li>
</ul>
<h4 id="3-4-顺序存储结构的插入和删除"><a href="#3-4-顺序存储结构的插入和删除" class="headerlink" title="3.4 顺序存储结构的插入和删除"></a>3.4 顺序存储结构的插入和删除</h4><h6 id="3-4-1-插入算法的思路"><a href="#3-4-1-插入算法的思路" class="headerlink" title="3.4.1 插入算法的思路"></a>3.4.1 插入算法的思路</h6><ol>
<li>如果插入位置不合理，抛出异常</li>
<li>如果线性表长度大于等于数组长度，则抛出异常或动态增加容量</li>
<li>从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置</li>
<li>将要插入元素填入位置 i 处</li>
<li>表长加 1</li>
</ol>
<h6 id="3-4-2-删除算法的思路"><a href="#3-4-2-删除算法的思路" class="headerlink" title="3.4.2 删除算法的思路"></a>3.4.2 删除算法的思路</h6><ol>
<li>如果删除位置不合理，抛出异常</li>
<li>取出删除元素</li>
<li>从删除元素开始遍历到最后一个元素位置，分别将它们都向前移动一个位置</li>
<li>表长减 1</li>
</ol>
<h6 id="3-4-3-插入和删除的时间复杂度"><a href="#3-4-3-插入和删除的时间复杂度" class="headerlink" title="3.4.3 插入和删除的时间复杂度"></a>3.4.3 插入和删除的时间复杂度</h6><ul>
<li><p>先来看最好情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为<code>O(1)</code>，因为不需要移动元素的。</p>
</li>
<li><p>最坏的情况，就是元素要插入到第一个位置，或者删除第一个元素，此时所有元素都要移动，时间复杂度为 <code>O(n)</code>。</p>
</li>
<li><p>平均移动次数为<code>(n - 1) / 2</code>，可以得出<strong>平均时间复杂度是<code>O(n)</code></strong>。</p>
</li>
</ul>
<h6 id="3-4-4-线性表顺序存储结构的优缺点"><a href="#3-4-4-线性表顺序存储结构的优缺点" class="headerlink" title="3.4.4 线性表顺序存储结构的优缺点"></a>3.4.4 线性表顺序存储结构的优缺点</h6><ul>
<li>优点</li>
<li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以快速地存取表中任一位置的元素。</li>
<li>缺点：</li>
<li>插入和删除操作是需要移动大量元素</li>
<li>当线性表长度变化较大时，难以确定存储空间的容量</li>
<li>造成存储空间的“碎片”。</li>
</ul>
<h4 id="3-5-线性表的链式存储结构"><a href="#3-5-线性表的链式存储结构" class="headerlink" title="3.5 线性表的链式存储结构"></a>3.5 线性表的链式存储结构</h4><h6 id="3-5-1-顺序存储结构的不足"><a href="#3-5-1-顺序存储结构的不足" class="headerlink" title="3.5.1 顺序存储结构的不足"></a>3.5.1 顺序存储结构的不足</h6><p><strong>顺序存储结构最大的缺点就是插入和删除时<code>需要移动大量元素</code>，这显然就需要<code>耗费时间</code>。</strong></p>
<h6 id="3-5-2线性表链式存储结构定义"><a href="#3-5-2线性表链式存储结构定义" class="headerlink" title="3.5.2线性表链式存储结构定义"></a>3.5.2线性表链式存储结构定义</h6><p>线性表的链式存储结构的特点是<strong>用一组任意的存储单元存储线性表的数据元素</strong>，这组存储单元可以是<code>连续</code>的，也可以是<code>不连续</code>的。这就意味着，<strong>这些数据元素可以存在内存未被占用的任意位置</strong>。</p>
<p>在顺序结构中，每个数据元素只需要存<code>数据元素信息</code>就可以了，但在链式结构中，<strong>除了要存<code>数据元素信息</code>外，还要存储它的<code>后继元素的存储地址</code></strong>。</p>
<p><strong>为了表示每个数据元素 <code>a(i)</code> 与其直接后继数据元素 <code>a(i+1)</code> 之间的逻辑关系，对数据元素<code>a(i)</code>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素<code>a(i)</code>的存储映像，称为<code>结点(Node)</code>。</strong></p>
<p><strong>N 个结点链接成一个链表，即为<code>线性表（a1，a2，…，a（n））</code>的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做<code>单链表</code>。</strong>单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-edd35f8195c82839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>对于线性表来说，总得有个头有个尾，链表也不例外。我们把<strong>链表中第一个结点的存储位置叫做<code>头指针</code></strong>，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个结点指针为“空”，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-f995851b8520372a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为<code>头结点</code>。<strong>头结点的数据域可以不存储任何信息，也可以存储诸如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针</strong>。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-e8e8383888b547ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h6 id="3-5-3-头指针与头结点的异同"><a href="#3-5-3-头指针与头结点的异同" class="headerlink" title="3.5.3 头指针与头结点的异同"></a>3.5.3 头指针与头结点的异同</h6><ul>
<li>头指针</li>
<li>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</li>
<li>头指针具有标识作用，所以常用指针冠以链表的名字</li>
<li><p>无论链表是否为空，头指针均不为空，头指针是链表的必要元素。</p>
</li>
<li><p>头结点</p>
</li>
<li>头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）</li>
<li>有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了</li>
<li>头结点不一定是链表必须要素。</li>
</ul>
<h4 id="3-6-单链表的读取"><a href="#3-6-单链表的读取" class="headerlink" title="3.6 单链表的读取"></a>3.6 单链表的读取</h4><p>在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的，但在单链表中，必须得从头开始找。因此，对于单链表实现获取第 i 个元素的数据的操作 GetElem ，在算法上，相对要麻烦一些。</p>
<ul>
<li>获得链表第 i 个数据的算法思路：</li>
</ul>
<ol>
<li>声明一个结点 p 指向链表第一个结点，初始化  j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，返回结点 p 的数据。</li>
</ol>
<h4 id="3-7-单链表的插入和删除"><a href="#3-7-单链表的插入和删除" class="headerlink" title="3.7 单链表的插入和删除"></a>3.7 单链表的插入和删除</h4><h6 id="3-7-1单链表的插入"><a href="#3-7-1单链表的插入" class="headerlink" title="3.7.1单链表的插入"></a>3.7.1单链表的插入</h6><p>假设存储元素 e 的结点为 s，要实现结点 p、p-&gt;next 和 s 之间逻辑关系的变化，只需将结点 s 插入到结点 p 和 p-&gt;next 之间即可。如何插入？</p>
<p>用不着惊动其它结点，只需让 s-&gt;next 和 p-&gt;next 的指针做一点改变即可。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;<span class="keyword">next</span>=p-&gt;<span class="keyword">next</span>; p-&gt;<span class="keyword">next</span>=s;</span><br></pre></td></tr></table></figure></p>
<p>解读代码：<strong>让 p 的后继结点改成 s 的后继结点，再把结点 s 变成 p 的后继结点。</strong></p>
<ul>
<li>单链表第 i 个数据插入结点的算法思路：</li>
</ul>
<ol>
<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，在系统中生成一个空结点 s；</li>
<li>将数据元素 e 赋值给 s-&gt; data；</li>
<li>单链表的插入标准语句 s-&gt;next = p-&gt;next; p-&gt;next=s；</li>
<li>返回成功</li>
</ol>
<h6 id="3-7-2单链表的删除"><a href="#3-7-2单链表的删除" class="headerlink" title="3.7.2单链表的删除"></a>3.7.2单链表的删除</h6><p>假设存储元素 a 的结点为 q，要实现结点 q 删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=p-&gt;<span class="keyword">next</span>; p-&gt;<span class="keyword">next</span>=q-&gt;<span class="keyword">next</span>;</span><br></pre></td></tr></table></figure>
<p>解读代码：<strong>让 p 的后继结的后继结点改成 p 的后继结点。</strong></p>
<ul>
<li>单链表第 i 个数据删除结点的算法思路：</li>
</ul>
<ol>
<li>声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始；</li>
<li>当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1；</li>
<li>若到链表末尾 p 为空，则说明第 i 个元素不存在；</li>
<li>否则查找成功，将欲删除的结点 p-&gt;next 赋值给 q；</li>
<li>单链表的删除标准语句 p-&gt;next=q-&gt;next;</li>
<li>将 q 结点中的数据赋值给 e，作为返回；</li>
<li>释放 q 结点；</li>
<li>返回成功。</li>
</ol>
<h4 id="3-8-单链表的整表创建与删除"><a href="#3-8-单链表的整表创建与删除" class="headerlink" title="3.8 单链表的整表创建与删除"></a>3.8 单链表的整表创建与删除</h4><h6 id="3-8-1-单链表的整表创建"><a href="#3-8-1-单链表的整表创建" class="headerlink" title="3.8.1 单链表的整表创建"></a>3.8.1 单链表的整表创建</h6><p>顺序存储结构的创建，其实就是一个<code>数组的初始化</code>，即声明一个类型和大小的数组并赋值的过程。而链表和顺序存储结构不一样，它不像顺序存储结构这么集中，它可以<code>很散</code>，是一种<code>动态结构</code>。<strong>对每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。</strong></p>
<p>所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始化状态起，依次建立各元素结点，并逐个插入链表。</p>
<ul>
<li>单链表整表创建的算法思路：</li>
</ul>
<ol>
<li>声明一结点 p 和计数器变量 i；</li>
<li>初始化一空链表L；</li>
<li>让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表；</li>
<li>循环：生成一新结点赋值给 p；随机生成一数字赋值给 p 的数据域 p-&gt;data；将 p 插入到头结点与前一新结点之间。</li>
</ol>
<h6 id="3-8-2-单链表的整表删除"><a href="#3-8-2-单链表的整表删除" class="headerlink" title="3.8.2 单链表的整表删除"></a>3.8.2 单链表的整表删除</h6><p>当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便留出空间给其它程序或软件使用。</p>
<ul>
<li>单链表整表删除的算法思路：</li>
</ul>
<ol>
<li>声明一结点 p 和 q；</li>
<li>将第一个结点赋值给 p；</li>
<li>循环：将下一结点赋值给 q；释放 p；将 q 赋值给 p。</li>
</ol>
<h4 id="3-9-单链表结构与顺序存储结构优缺点"><a href="#3-9-单链表结构与顺序存储结构优缺点" class="headerlink" title="3.9 单链表结构与顺序存储结构优缺点"></a>3.9 单链表结构与顺序存储结构优缺点</h4><ul>
<li>链表结构和顺序存储结构对比图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-b6bd7154fc48e218.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>由上图可知，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好哪个不好，需要根据实际情况，来<strong>综合平衡采用哪种数据结构更能满足和达到需求和性能。</strong></li>
</ul>
<hr>
<h5 id="下一篇：数据结构-《大话数据结构》读书笔记-2"><a href="#下一篇：数据结构-《大话数据结构》读书笔记-2" class="headerlink" title="下一篇：数据结构 -《大话数据结构》读书笔记(2)"></a>下一篇：<a href="https://www.jianshu.com/p/c7c16110b796" target="_blank" rel="noopener">数据结构 -《大话数据结构》读书笔记(2)</a></h5>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/数据结构 -《大话数据结构》读书笔记(2)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/数据结构 -《大话数据结构》读书笔记(2)/" itemprop="url">
                  数据结构 -《大话数据结构》读书笔记(2)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="文章共分为三篇"><a href="#文章共分为三篇" class="headerlink" title="文章共分为三篇"></a>文章共分为三篇</h5><h5 id="第一篇：数据结构-《大话数据结构》读书笔记-1"><a href="#第一篇：数据结构-《大话数据结构》读书笔记-1" class="headerlink" title="第一篇：数据结构 -《大话数据结构》读书笔记(1)"></a><a href="https://www.jianshu.com/p/72aabf06a450" target="_blank" rel="noopener">第一篇：数据结构 -《大话数据结构》读书笔记(1)</a></h5><p><strong>一、数据结构绪论<br>二、算法<br>三、线性表</strong></p>
<h5 id="第二篇：数据结构-《大话数据结构》读书笔记-2"><a href="#第二篇：数据结构-《大话数据结构》读书笔记-2" class="headerlink" title="第二篇：数据结构 -《大话数据结构》读书笔记(2)"></a><a href="https://www.jianshu.com/p/c7c16110b796" target="_blank" rel="noopener">第二篇：数据结构 -《大话数据结构》读书笔记(2)</a></h5><p><strong>四、栈与队列<br>五、串<br>六、树<br>七、图</strong></p>
<h5 id="第三篇：数据结构-《大话数据结构》读书笔记-3"><a href="#第三篇：数据结构-《大话数据结构》读书笔记-3" class="headerlink" title="第三篇：数据结构 -《大话数据结构》读书笔记(3)"></a><a href="https://www.jianshu.com/p/4fb2481c9b06" target="_blank" rel="noopener">第三篇：数据结构 -《大话数据结构》读书笔记(3)</a></h5><p><strong>八、查找<br>九、排序</strong></p>
<hr>
<h2 id="四、栈与队列"><a href="#四、栈与队列" class="headerlink" title="四、栈与队列"></a>四、栈与队列</h2><h4 id="4-1-栈的定义"><a href="#4-1-栈的定义" class="headerlink" title="4.1 栈的定义"></a>4.1 栈的定义</h4><ul>
<li>栈<br><strong>栈是限定仅在表尾进行插入和删除操作的线性表。</strong></li>
</ul>
<p>我们把允许插入和删除的一端称为 <strong>栈顶</strong>，另一端称为 <strong>栈底</strong>，不含任何数据元素的栈称为 <strong>空栈</strong>。栈又称为后进先出的 <strong>线性表</strong>，简称 LIFO 结构。</p>
<p>栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终<code>只在栈顶进行</code>。</p>
<ul>
<li><p>栈的插入操作，叫作<code>进栈</code>，也称<code>压栈</code>、<code>入栈</code>。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-2f76b70624c4771e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="进栈"></p>
</li>
<li><p>栈的删除操作，叫作<code>出栈</code>，也有的叫作<code>弹栈</code>。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-c38b3028a8515947.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="出栈"></p>
</li>
</ul>
<h4 id="4-2-栈的应用"><a href="#4-2-栈的应用" class="headerlink" title="4.2 栈的应用"></a>4.2 栈的应用</h4><p><strong>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。</strong></p>
<p>所以现在很多高级语言，比如 Java、C#等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，非常方便。</p>
<h5 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h5><p><strong>在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。</strong></p>
<p>每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。</p>
<p><strong>递归和迭代的区别是</strong>：迭代使用的是<code>循环结构</code>，递归使用的是<code>选择结构</code>。 递归能使程序的结构<code>更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间</code>。但是大量的递归调用会建立函数的副本，<code>会耗费大量的时间和内存</code>。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p>
<p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
<h4 id="4-3-队列定义"><a href="#4-3-队列定义" class="headerlink" title="4.3 队列定义"></a>4.3 队列定义</h4><ul>
<li>队列<br><strong>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</strong></li>
</ul>
<p><strong>队列是一种先进先出的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</strong>假设队列是 q = (a1, a2, ……, an)，那么 a1 就是队头元素，而 an 就是队尾元素。我们在删除时，总是从 a1 开始；插入时，列在最后。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-6353d498dd8fcca7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="队列"></p>
<p>同样是线性表，队列也有类似线性表的各种操作，不同的就是<code>插入数据只能在队尾</code>进行，<code>删除数据只能在队头</code>进行。</p>
<h6 id="4-3-1-循环队列"><a href="#4-3-1-循环队列" class="headerlink" title="4.3.1  循环队列"></a>4.3.1  循环队列</h6><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。<strong>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</strong></p>
<h6 id="4-3-2-队列的链式存储结构及实现"><a href="#4-3-2-队列的链式存储结构及实现" class="headerlink" title="4.3.2 队列的链式存储结构及实现"></a>4.3.2 队列的链式存储结构及实现</h6><p><strong>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。</strong><br>队列的链式存储结构——<code>入队操作</code><br>入队操作时，其实就是在<code>链表尾部</code>插入结点。<br>队列的链式存储结构——<code>出队操作</code><br>出队操作时，就是<code>头结点的后继结点出队</code>，将<code>头结点的后继改为它后面的结点</code>，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。</p>
<h6 id="4-3-3-循环队列与链队列的对比"><a href="#4-3-3-循环队列与链队列的对比" class="headerlink" title="4.3.3 循环队列与链队列的对比"></a>4.3.3 循环队列与链队列的对比</h6><p><strong>对比</strong>：时间上，基本操作都是常数时间，都为 <code>O(1)</code> 的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。空间上，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接收。所以在空间上，链队列更加灵活。</p>
<p><strong>总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</strong></p>
<h2 id="五、串"><a href="#五、串" class="headerlink" title="五、串"></a>五、串</h2><h4 id="5-1-串的定义："><a href="#5-1-串的定义：" class="headerlink" title="5.1 串的定义："></a>5.1 串的定义：</h4><p><strong>串是由零个或多个字符组成的有限序列，又叫字符串。</strong></p>
<p>一般记为 s=“a1a2……an”(n&gt;=0)，其中，s 是串的名字，用双引号括起来的字符序列是串的值，双引号不属于串的内容。a1 可以是字母、数字或其他字符，i 就是该字符在串中的位置。<strong>串中的字符数目 n 称为串的长度</strong>，定义中谈到“有限”，指的是长度 n 是一个有限的数值。零个字符的串称为空串，它的长度为零。所谓序列，说明串的相邻字符之间具有前驱和后继的关系。</p>
<p><code>空格串</code>，是只包含空格的串。空格串与空串不同，空格串是有长度的，而且可以不止一个空格。<br><code>子串</code>和<code>主串</code>，串中任意个数的连续字符组成的子序列称为该串的子串，相应的，包含子串的串称为主串。<br>子串在主串中的位置就是子串的第一个字符在主串中的序号。</p>
<h4 id="5-2-串的比较"><a href="#5-2-串的比较" class="headerlink" title="5.2 串的比较"></a>5.2 串的比较</h4><p><strong>串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。</strong></p>
<p>C 语言中，比较两个串是否相等，必须是它们的串是否相等，必须是它们串的长度以及它们对应位置的字符都相等时，才算是相等。即给定两个串：s=“a1a2……an”，t=“b1b2……bm”，当且仅当 n = m，且 a1 = b1 ，a2 = b2，……，an=bm 时，我们认为 s=t。</p>
<h4 id="5-3-串的存储结构"><a href="#5-3-串的存储结构" class="headerlink" title="5.3 串的存储结构"></a>5.3 串的存储结构</h4><p>串的存储结构与线性表相同，分为两种。</p>
<h5 id="5-3-1-串的顺序存储结构"><a href="#5-3-1-串的顺序存储结构" class="headerlink" title="5.3.1 串的顺序存储结构"></a>5.3.1 串的顺序存储结构</h5><p><strong>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。</strong></p>
<h5 id="5-3-2-串的链式存储结构"><a href="#5-3-2-串的链式存储结构" class="headerlink" title="5.3.2 串的链式存储结构"></a>5.3.2 串的链式存储结构</h5><p><strong>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。</strong>因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被栈占满时，可以用“#”或其他非串值字符补全，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-3a1c0ee15aa92630.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里一个结点存多少字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。</p>
<p><strong>但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</strong></p>
<h2 id="六、树"><a href="#六、树" class="headerlink" title="六、树"></a>六、树</h2><h4 id="6-1-树的定义"><a href="#6-1-树的定义" class="headerlink" title="6.1 树的定义"></a>6.1 树的定义</h4><p><strong>树是 n (n &gt;= 0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树种：（1）有且仅有一个特定的称为根的结点；（2）当 n&gt;1 时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。</strong>如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-5a655ef8ac83dc0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="树"></p>
<h5 id="6-1-1-结点分类"><a href="#6-1-1-结点分类" class="headerlink" title="6.1.1 结点分类"></a>6.1.1 结点分类</h5><p><strong>树的结点包含一个数据元素及若干指向子树的分支。结点拥有的子树称为结点的度。度为 0 的结点称为叶节点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也成为内部结点。树的度是树内各结点的度的最大值。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-e4d9f87bdc6bf1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>如上图，这棵树结点的度的最大值是结点 D 的度，为 3，所以树的度也为 3。</p>
<h5 id="6-1-2-结点间关系"><a href="#6-1-2-结点间关系" class="headerlink" title="6.1.2 结点间关系"></a>6.1.2 结点间关系</h5><p><strong>结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。结点的祖先是从根到该结点所经分支上的所有结点。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-60024b167326428c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>如上图，对于 H 来说，D、B、A 都是它的祖先。反之，<strong>以某结点为根的子树中的任一结点都称为该结点的子孙。</strong>B 的子孙有 D、G、H、I。</p>
<h5 id="6-1-3-树的其它相关概念"><a href="#6-1-3-树的其它相关概念" class="headerlink" title="6.1.3 树的其它相关概念"></a>6.1.3 树的其它相关概念</h5><p><strong>结点的层次从根开始定义起，根为第一层，根的孩子为第二层。</strong>若某结点在第 i 层，则其子树的根就在第 i + 1 层。其<strong>双亲在同一层的结点互为堂兄弟</strong>。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-05c7bf711e42ab95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在上图中，D、E、F 是堂兄弟，G、H、I、J 也是。<strong>树中结点的最大层次称为树的深度或高度</strong>，当期树的深度为 4。</p>
<p><strong>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则为无序树。</strong></p>
<p><strong>森林是 m (m&gt;=0) 棵互不相交的树的集合。</strong>对树中每个结点而言，其子树的集合即为森林。<br>对比线性表与树的结构，它们有很大的不同，如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-83ddf429606042c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="6-2-二叉树"><a href="#6-2-二叉树" class="headerlink" title="6.2 二叉树"></a>6.2 二叉树</h4><h5 id="6-2-1-二叉树定义"><a href="#6-2-1-二叉树定义" class="headerlink" title="6.2.1 二叉树定义"></a>6.2.1 二叉树定义</h5><p><strong>二叉树是 n (n&gt;=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</strong><br><img src="http://upload-images.jianshu.io/upload_images/2665449-1131ac10a03084a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树"></p>
<h5 id="6-2-2-二叉树特点："><a href="#6-2-2-二叉树特点：" class="headerlink" title="6.2.2 二叉树特点："></a>6.2.2 二叉树特点：</h5><ul>
<li>每个结点最多有两棵子树，所以二叉树不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一颗子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li>
</ul>
<h5 id="6-2-3-二叉树具有五种基本形态："><a href="#6-2-3-二叉树具有五种基本形态：" class="headerlink" title="6.2.3 二叉树具有五种基本形态："></a>6.2.3 二叉树具有五种基本形态：</h5><ul>
<li>空二叉树</li>
<li>只有一个根结点</li>
<li>根结点只有左子树</li>
<li>根结点只有右子树</li>
<li>根结点既有左子树又有右子树</li>
</ul>
<h5 id="6-2-4-特殊二叉树"><a href="#6-2-4-特殊二叉树" class="headerlink" title="6.2.4 特殊二叉树"></a>6.2.4 特殊二叉树</h5><ul>
<li><ol>
<li>斜树<br>所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。</li>
</ol>
</li>
<li><ol start="2">
<li>满二叉树<br>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-701a90b549f0e4ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="满二叉树"></li>
</ol>
</li>
<li><ol start="3">
<li>完全二叉树<br>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 &lt;= i &lt;= n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-b5c5d63cc2e64d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="完全二叉树"></li>
</ol>
</li>
</ul>
<h4 id="6-3-遍历二叉树"><a href="#6-3-遍历二叉树" class="headerlink" title="6.3 遍历二叉树"></a>6.3 遍历二叉树</h4><p><strong>二叉树的遍历是指从根结点出发，按照某种<code>次序</code>依次<code>访问</code>二叉树所有结点，使得每个结点被访问一次且仅被访问一次。</strong></p>
<h5 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h5><ul>
<li>前序遍历<br>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-875aee89b8c25022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></li>
</ul>
<p>前序遍历次序：ABDGHCEIF</p>
<ul>
<li>中序遍历<br>若二叉树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-b59c9776915baece.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>中序遍历次序：GDHBAEICF</p>
<ul>
<li>后序遍历<br>若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-3bd4db95a7047a2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>后序遍历次序：GHDBIEFCA</p>
<ul>
<li>层次遍历<br>若二叉树为空，则空操作返回，否则从树的第一层，</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-00f2e056c0d449da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>层次遍历次序：ABCDEFGHI</p>
<h2 id="七、图"><a href="#七、图" class="headerlink" title="七、图"></a>七、图</h2><h4 id="7-1-图的定义"><a href="#7-1-图的定义" class="headerlink" title="7.1 图的定义"></a>7.1 图的定义</h4><p><strong>图是由顶点的有穷非空集和顶点之间边的集合，通常表示为：G(V. E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。</strong></p>
<ul>
<li>在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。</li>
<li>在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。</li>
<li>图是一种较线性表和树更加复杂的数据结构，在图结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</li>
</ul>
<p>线性表中我们把数据元素叫元素；树种将数据元素叫结点；<strong>在图中数据元素，我们称之为顶点。</strong></p>
<p>线性表中可以没有数据元素，称为空表；树种可以没有结点，叫做空树；但<strong>在图结构中，不允许没有顶点。在定义中，若 V 是顶点的集合，则顶点集合 V 有穷非空。</strong></p>
<p>线性表中，相邻的元素之间具有线性关系；树结构中，相邻两层的结点具有层次关系；而<strong>图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。</strong></p>
<h4 id="7-2-各种图定义"><a href="#7-2-各种图定义" class="headerlink" title="7.2 各种图定义"></a>7.2 各种图定义</h4><ul>
<li><p>无向边：若顶点 V1 到 V2 之间的边没有方向，则称这条边为无向边，用无序偶对来表示。如果途中任意两个顶点之间都是无向边，则称该图为无向图。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-a77da36aac3034a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无向图"><br>由于是无方向的，连接顶点 A 与 D 的边，可以表示成无序对 (A，D)，也可以表示成 (D，A)。</p>
</li>
<li><p>有向边：若顶点 V1 到 V2 的边有方向，则称这条边为有向边，也称为弧。用有序偶&lt;Vi, Vj&gt; 来表示，Vi 称为弧尾，Vj 称为弧头。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-b5c8c88da82a9709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有向图"></p>
</li>
<li><p>连接顶点 A 到 D 的有向边就是弧，A 是弧尾，D 是弧头，&lt;A, D&gt; 表示弧，注意不能写成&lt;D, A&gt;。</p>
</li>
</ul>
<p><strong>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。</strong>含有 n 个顶点的无向完全图有 n * (n - 1) / 2 条边。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-4fb6bb09ca3bdf99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="无向完全图"></p>
<p><strong>在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。</strong>含有 n 个顶点的有向完全图有 n * (n - 1) 条边。<br><img src="http://upload-images.jianshu.io/upload_images/2665449-06f8eccca0abfd94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="有向完全图"></p>
<p><strong>从这里可以得出结论，对于具有 n 个顶点和 e 条边数的图，无向图 0&lt;= e &lt;= n(n-1)/2，有向图 0 &lt;= e &lt;= n(n-1)。</strong></p>
<h4 id="7-3-图的遍历"><a href="#7-3-图的遍历" class="headerlink" title="7.3 图的遍历"></a>7.3 图的遍历</h4><p><strong>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。</strong></p>
<h5 id="7-3-1-深度优先遍历"><a href="#7-3-1-深度优先遍历" class="headerlink" title="7.3.1 深度优先遍历"></a>7.3.1 深度优先遍历</h5><p><strong>深度优先遍历，也有称为深度优先搜索，简称 DFS。它从图中某个顶点 V 出发，访问此顶点，然后从 V 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 V 有路径相通的顶点都被访问到。</strong></p>
<h5 id="7-3-2-广度优先遍历"><a href="#7-3-2-广度优先遍历" class="headerlink" title="7.3.2 广度优先遍历"></a>7.3.2 广度优先遍历</h5><p><strong>广度优先遍历，又称为广度优先搜索，简称 BFS。</strong></p>
<p>对比图的深度优先遍历和广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。</p>
<hr>
<h5 id="下一篇：数据结构-《大话数据结构》读书笔记-3"><a href="#下一篇：数据结构-《大话数据结构》读书笔记-3" class="headerlink" title="下一篇：数据结构 -《大话数据结构》读书笔记(3)"></a>下一篇：<a href="https://www.jianshu.com/p/4fb2481c9b06" target="_blank" rel="noopener">数据结构 -《大话数据结构》读书笔记(3)</a></h5>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘朋坤</p>
              <p class="site-description motion-element" itemprop="description">iOS 修炼中...</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘朋坤</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
