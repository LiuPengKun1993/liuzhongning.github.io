<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.1.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.1.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="iOS 修炼中...">
<meta property="og:type" content="website">
<meta property="og:title" content="以梦为马">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="以梦为马">
<meta property="og:description" content="iOS 修炼中...">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="以梦为马">
<meta name="twitter:description" content="iOS 修炼中...">






  <link rel="canonical" href="http://yoursite.com/page/5/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>以梦为马</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">以梦为马</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">谨以此纪念岁月</p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-主页">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />主页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-归档">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/数据结构 -《大话数据结构》读书笔记(3)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/数据结构 -《大话数据结构》读书笔记(3)/" itemprop="url">
                  数据结构 -《大话数据结构》读书笔记(3)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="文章共分为三篇"><a href="#文章共分为三篇" class="headerlink" title="文章共分为三篇"></a>文章共分为三篇</h5><h5 id="第一篇：数据结构-《大话数据结构》读书笔记-1"><a href="#第一篇：数据结构-《大话数据结构》读书笔记-1" class="headerlink" title="第一篇：数据结构 -《大话数据结构》读书笔记(1)"></a><a href="https://www.jianshu.com/p/72aabf06a450" target="_blank" rel="noopener">第一篇：数据结构 -《大话数据结构》读书笔记(1)</a></h5><p><strong>一、数据结构绪论<br>二、算法<br>三、线性表</strong></p>
<h5 id="第二篇：数据结构-《大话数据结构》读书笔记-2"><a href="#第二篇：数据结构-《大话数据结构》读书笔记-2" class="headerlink" title="第二篇：数据结构 -《大话数据结构》读书笔记(2)"></a><a href="https://www.jianshu.com/p/c7c16110b796" target="_blank" rel="noopener">第二篇：数据结构 -《大话数据结构》读书笔记(2)</a></h5><p><strong>四、栈与队列<br>五、串<br>六、树<br>七、图</strong></p>
<h5 id="第三篇：数据结构-《大话数据结构》读书笔记-3"><a href="#第三篇：数据结构-《大话数据结构》读书笔记-3" class="headerlink" title="第三篇：数据结构 -《大话数据结构》读书笔记(3)"></a><a href="https://www.jianshu.com/p/4fb2481c9b06" target="_blank" rel="noopener">第三篇：数据结构 -《大话数据结构》读书笔记(3)</a></h5><p><strong>八、查找<br>九、排序</strong></p>
<hr>
<h2 id="八、查找"><a href="#八、查找" class="headerlink" title="八、查找"></a>八、查找</h2><h4 id="8-1-查找概论"><a href="#8-1-查找概论" class="headerlink" title="8.1 查找概论"></a>8.1 查找概论</h4><p><strong>所有需要被查的数据所在的集合，我们给它一个统称叫<code>查找表</code>。</strong></p>
<p><strong>查找表是由同一类型的<code>数据元素</code>（或记录）构成的集合。</strong></p>
<p><strong><code>关键字</code>是数据元素中某个数据项的值，又称为键值，</strong>用它可以标识一个数据元素，也可以标识一个记录的某个数据项，我们称为<code>关键码</code>。</p>
<p><strong>若此关键字可以唯一地表示一个记录，则称此关键字为<code>主关键字</code>。</strong>这也意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为<code>主关键码</code>。</p>
<p><strong>对于那些可以识别多个数据元素（或记录）的关键字，我们称之为<code>次关键字</code>，</strong>次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是<code>次关键码</code>。</p>
<p><code>查找</code>就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）。</p>
<p>若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，或指示该记录在查找表中的位置。若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。<br>查找表按照操作方式来分有两大种：<strong>静态查找表</strong> 和 <strong>动态查找表</strong>。</p>
<ul>
<li><strong>静态查找表：只查找操作的查找表。</strong>它的主要操作有：</li>
<li>查询某个“特定的”数据元素是否在查找表中。</li>
<li>检索某个“特定的”数据元素和各种属性。</li>
</ul>
<ul>
<li><strong>动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</strong>显然动态查找表的操作就是两个：</li>
<li>查找时插入数据元素。</li>
<li>查找时删除数据元素。</li>
</ul>
<p>为了提高查找的效率，我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为<code>查找结构</code>。</p>
<h4 id="8-2-顺序表查找"><a href="#8-2-顺序表查找" class="headerlink" title="8.2 顺序表查找"></a>8.2 顺序表查找</h4><p><strong>顺序查找</strong> 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。</p>
<h4 id="8-3-有序表查找"><a href="#8-3-有序表查找" class="headerlink" title="8.3 有序表查找"></a>8.3 有序表查找</h4><h5 id="8-3-1-折半查找"><a href="#8-3-1-折半查找" class="headerlink" title="8.3.1 折半查找"></a>8.3.1 折半查找</h5><p><strong>折半查找技术，又称为<code>二分查找</code>。它的前提是线性表中的记录必须是<code>关键码有序</code>（通常从小到大有序），线性表必须采用<code>顺序存储</code>。折半查找的基本思想是：在有序表中，取中间记录为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，知道查找成功，或所有查找区域无记录，查找失败为止。</strong></p>
<h5 id="8-3-2-插值查找"><a href="#8-3-2-插值查找" class="headerlink" title="8.3.2 插值查找"></a>8.3.2 插值查找</h5><p><strong>插值查找是根据要查找的关键字 <code>key</code> 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于差值的计算公式 <code>(key - a[low])/(a[high] - a[low])</code>。</strong>从时间复杂度来看，它也是 <code>O(logn)</code>，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似 <code>{0,1,2,2000,2001,……,999998,999999}</code> 这种极端不均匀的数据，用插值查找未必是很合适的选择。</p>
<h5 id="8-3-3-斐波那契查找"><a href="#8-3-3-斐波那契查找" class="headerlink" title="8.3.3 斐波那契查找"></a>8.3.3 斐波那契查找</h5><p>斐波那契查找算法的核心在于：</p>
<ol>
<li>当 <code>key=a[mid]</code> 时，查找就成功；</li>
<li>当 <code>key&lt;a[mid]</code> 时，新范围是第 <code>low</code> 个到第 <code>mid-1</code> 个，此时范围个数为 <code>F[k-1]-1</code> 个；</li>
<li>当 <code>key&gt;a[mid]</code> 时，新范围是第 <code>m+1</code> 个到第 <code>high</code> 个，此时范围个数为 <code>F[k-2]-1</code> 个；</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-971dd2974bd26b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="8-4-线性索引查找"><a href="#8-4-线性索引查找" class="headerlink" title="8.4 线性索引查找"></a>8.4 线性索引查找</h4><p>数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。<strong>索引就是把一个关键字与它对应的记录相关联的过程，</strong>一个索引由若干个索引项构成，每个索引项至少应该包含关键字和其对应的记录在存储器中的位置等信息。<br>索引按照结构可以分为<code>线性索引</code>、<code>树形索引</code>和<code>多级索引</code>。我们这里只介绍线性索引技术。<strong>所谓线性索引就是将索引项集合组织为<code>线性结构</code>，也称为<code>索引表</code>。</strong>这里介绍三种线性索引：<code>稠密索引</code>、<code>分块索引</code>和<code>倒排索引</code>。</p>
<h5 id="8-4-1-稠密索引"><a href="#8-4-1-稠密索引" class="headerlink" title="8.4.1 稠密索引"></a>8.4.1 稠密索引</h5><p><strong>稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项</strong>，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-f3d3641df5f0a4ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="稠密索引"></p>
<p><strong>对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。</strong></p>
<p>索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这是稠密索引的优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。</p>
<h5 id="8-4-2-分块索引"><a href="#8-4-2-分块索引" class="headerlink" title="8.4.2 分块索引"></a>8.4.2 分块索引</h5><p>稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。</p>
<p><strong>分块有序，是把数据记得记录分成了若干块，并且这些块需要满足两个条件。</strong></p>
<ul>
<li><strong>块内无序，</strong>即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。</li>
<li><strong>块间有序，</strong>例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。</li>
</ul>
<p>对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2665449-56e6f31aaf3c8b9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分块索引"></p>
<ul>
<li>分块索引的索引项结构分为三个数据项：</li>
<li>最大关键码，它存储每一块中的最大关键字，这样的好处是可以使得在他之后的下一块中的最小关键字也能比这一块最大的关键字更大；</li>
<li>存储了块中的记录个数，以便于循环时使用；</li>
<li>用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。</li>
</ul>
<h5 id="8-4-3-倒排索引"><a href="#8-4-3-倒排索引" class="headerlink" title="8.4.3 倒排索引"></a>8.4.3 倒排索引</h5><p><strong>索引表的通用结构是：次关键码；记录号表。</strong><br><strong>其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。</strong>倒排索引源于实际应用中需要根据属性和具有该属性值得各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。</p>
<p>倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长。</p>
<h4 id="8-5-二叉排序树"><a href="#8-5-二叉排序树" class="headerlink" title="8.5 二叉排序树"></a>8.5 二叉排序树</h4><p><strong>二叉排序树，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。</strong></p>
<ul>
<li><strong>若它的左子树不空，则左子树上所有的结点的值均小于它的跟结构的值；</strong></li>
<li><strong>若它的右子树不空，则右子树上所有的节点的值均大于它的根结点的值；</strong></li>
<li><strong>它的左、右子树也分别为二叉排序树。</strong></li>
</ul>
<p>从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。</p>
<p>构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。</p>
<h4 id="8-6-散列表查找（哈希表）概述"><a href="#8-6-散列表查找（哈希表）概述" class="headerlink" title="8.6 散列表查找（哈希表）概述"></a>8.6 散列表查找（哈希表）概述</h4><p><strong>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系<code>f</code> ，使得每个关键字 <code>key</code> 对应一个存储位置 <code>f (key)</code>。</strong>查找时，根据这个确定的对应关系找到给定值<code>key</code>的影射<code>f(key)</code>，若查找集合中存在这个记录，则必定在<code>f(key)</code> 的位置上。</p>
<p><strong>这里我们把这种对应关系 f 称为散列函数，又称为哈希函数。</strong>按这个思想，<strong>采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。</strong>那么关键字对应的记录存储位置我们称为散列地址。</p>
<ul>
<li>整个散列过程其实就两步：</li>
</ul>
<ol>
<li>在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。</li>
<li>当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。<br>所以说，<strong>散列技术既是一种存储方法，也是一种查找方法。</strong></li>
</ol>
<h2 id="九、排序"><a href="#九、排序" class="headerlink" title="九、排序"></a>九、排序</h2><h4 id="9-1-排序的基本概念与分类"><a href="#9-1-排序的基本概念与分类" class="headerlink" title="9.1 排序的基本概念与分类"></a>9.1 排序的基本概念与分类</h4><p><strong>假设含有 <code>n</code> 个记录的序列为 <code>{r1, r2, ……, rn}</code>，其对应的关键字分别为 <code>{k1, k2, ……, kn}</code>，需确定 <code>1，2，……，n</code> 的一种排列 <code>p1，p2，……，pn</code>，使其相应的关键字满足 <code>k(p1)&lt;=k(p2)&lt;=……&lt;=k(pn)</code>（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列 <code>{r(p1)，r(p2)，……，r(pn)}</code>，这样的操作就称为排序。</strong></p>
<h5 id="9-1-1-排序的稳定性"><a href="#9-1-1-排序的稳定性" class="headerlink" title="9.1.1 排序的稳定性"></a>9.1.1 排序的稳定性</h5><p>假设 <code>k(i)=k(j)(1&lt;=i&lt;=n，1&lt;=j&lt;=n，i!=j)</code>，且在排序前的序列中 <code>r(n)</code> 领先于 <code>r(j)</code>（即i&lt;j）。如果排序后 <code>r(i)</code>仍领先于 <code>r(j)</code>，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 <code>r(j)</code> 领先于 <code>r(i)</code>，则称所用的排序方法是不稳定的。</p>
<h5 id="9-1-2-内排序与外排序"><a href="#9-1-2-内排序与外排序" class="headerlink" title="9.1.2 内排序与外排序"></a>9.1.2 内排序与外排序</h5><p>根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。<br><strong><code>内排序</code>是在排序整个过程中，<code>待排序</code>的所有记录全部被放置在内存中。<code>外排序</code>是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外村之间多粗交换数据才能进行。</strong></p>
<ul>
<li>对于内排序，排序算法的性能主要是受 3 个方面影响；</li>
</ul>
<ol>
<li>时间性能<br>排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免。总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</li>
<li>辅助空间<br>评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。</li>
<li>算法的复杂性<br>注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。</li>
</ol>
<p>根据排序过程借助的主要操作，我们把内排序分为：<code>插入排序</code>、<code>交换排序</code>、<code>选择排序</code>和<code>归并排序</code>。</p>
<h4 id="9-2-几种排序算法"><a href="#9-2-几种排序算法" class="headerlink" title="9.2 几种排序算法"></a>9.2 几种排序算法</h4><h5 id="9-2-1-冒泡排序"><a href="#9-2-1-冒泡排序" class="headerlink" title="9.2.1 冒泡排序"></a>9.2.1 冒泡排序</h5><p><strong>冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</strong></p>
<ul>
<li>冒泡排序复杂度分析<br>最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是 <code>n-1</code> 次的比较，没有数据交换，时间复杂度为 <code>O(n)</code>；当最坏的情况，即待排序表是逆序的情况，此时需要比较<code>n(n-1)</code>次，并作等数量级的记录移动。因此，总的时间复杂度为 <code>O(n*n)</code>。</li>
</ul>
<h5 id="9-2-2-简单选择排序"><a href="#9-2-2-简单选择排序" class="headerlink" title="9.2.2 简单选择排序"></a>9.2.2 简单选择排序</h5><p><strong>简单选择排序法就是通过 <code>n-i</code> 次关键字间的比较，从 <code>n-i+1</code> 个记录选出关键字最小的记录，并和第 <code>i (1&lt;=i&lt;=n)</code>个记录交换之。</strong></p>
<ul>
<li>简单选择排序复杂度分析<br>从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 <code>i</code>趟排序需要进行<code>n-i</code>次关键字的比较，此时需要比较 <code>n(n-1)/2</code> 次。而对于交换次数而言，当最好的时候，交换为<code>0</code> 次，最差的时候，也就初始降序时，交换次数为 <code>n-1</code>次，基于最终的排序时间是比较与交换的次数的综合，因此，总的时间复杂度依然为 <code>O(n*n)</code>。</li>
</ul>
<h5 id="9-2-3-直接插入排序"><a href="#9-2-3-直接插入排序" class="headerlink" title="9.2.3 直接插入排序"></a>9.2.3 直接插入排序</h5><p><strong>直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。</strong></p>
<ul>
<li>直接插入排序复杂度分析<br>当最好的情况，也就是要排序的表本身就是有序的，没有移动的记录，时间复杂度为 <code>O(n)</code>；当最坏的情况，即待排序表示逆序的情况，此时需要比较 <code>(n+2)(n-1)/2</code> 次，而记录的移动次数也达到最大值<code>(n+4)(n-1)/2</code>次；如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 <code>n*n/4</code>次。因此我们得出直接插入排序法的时间复杂度为<code>O(n*n)</code>。从这里也可以看出，同样的时间复杂度，直接插入排序法比冒泡和简单排序的性能要好一些。</li>
</ul>
<h5 id="9-2-4-希尔排序"><a href="#9-2-4-希尔排序" class="headerlink" title="9.2.4 希尔排序"></a>9.2.4 希尔排序</h5><ul>
<li>算法步骤：<br>1）选择一个增量序列<code>t1，t2，…，tk</code>，其中<code>ti&gt;tj</code>，<code>tk=1</code>；<br>2）按增量序列个数<code>k</code>，对序列进行<code>k</code> 趟排序；<br>3）每趟排序，根据对应的增量<code>ti</code>，将待排序列分割成若干长度为<code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为<code>1</code> 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h5 id="9-2-5-堆排序"><a href="#9-2-5-堆排序" class="headerlink" title="9.2.5 堆排序"></a>9.2.5 堆排序</h5><p><strong>堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</strong></p>
<p>堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 <code>n-1</code> 个序列重新构造成一个堆，这样就会得到<code>n</code>个元素中的次小值。如此反复执行，便能得到一个有序序列了。</p>
<h5 id="9-2-6-快速排序"><a href="#9-2-6-快速排序" class="headerlink" title="9.2.6 快速排序"></a>9.2.6 快速排序</h5><p><strong>快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</strong></p>
<ul>
<li>几种排序算法对比：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-60505d0e355b8bc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="排序算法对比"></p>
<hr>
<h5 id="相关文章：算法-几种排序算法-OC-版"><a href="#相关文章：算法-几种排序算法-OC-版" class="headerlink" title="相关文章：算法-几种排序算法 OC 版"></a>相关文章：<a href="https://www.jianshu.com/p/168462a3ce0b" target="_blank" rel="noopener">算法-几种排序算法 OC 版</a></h5><h5 id="代码传送门：排序算法-OC-版"><a href="#代码传送门：排序算法-OC-版" class="headerlink" title="代码传送门：排序算法 OC 版"></a>代码传送门：<a href="https://github.com/liuzhongning/NNSort" target="_blank" rel="noopener">排序算法 OC 版</a></h5><p>结束语：由于个人能力有限，这三篇读书笔记难免有错误或不足之处，还望各位道友能不吝赐教，谢谢。</p>
<p>最后安利一下这本书：<a href="https://pan.baidu.com/s/1jJdV2OQ" target="_blank" rel="noopener">PDF版</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色/" itemprop="url">
                  用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><code>UITextView</code> 实现占位文本的方式有很多种，网上一搜一大把，，这里只介绍 <strong>最简单</strong> 的一种，如标题所述：<strong>用 <code>RunTime</code> 为 <code>UITextView</code> 设置占位文本并实时改变文本框占位文本的颜色。</strong></p>
</blockquote>
<blockquote>
<p>对 <code>RunTime</code> 不太了解的童鞋可以简单看下这篇文章：<a href="http://www.jianshu.com/p/d92452217f68" target="_blank" rel="noopener">iOS开发之 - Runtime</a>，懒得点击鼠标的话我这里也简单的说下，<code>Runtime 简称运行时，是苹果官方的一套比较底层的纯 C 语言 API, 用它可以做很多底层操作（比如访问隐藏的成员变量和方法）。</code></p>
</blockquote>
<p>OK，足够了，接下来我们就抓紧时间来看看如何用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色。。。</p>
<h5 id="首先我们利用-RunTime-获取一下-UITextView-中一些隐藏的成员变量"><a href="#首先我们利用-RunTime-获取一下-UITextView-中一些隐藏的成员变量" class="headerlink" title="首先我们利用 RunTime 获取一下 UITextView 中一些隐藏的成员变量"></a>首先我们利用 RunTime 获取一下 UITextView 中一些隐藏的成员变量</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  获取 UITextView 中所有的成员变量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UITextView</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">Ivar ivar = ivars[i];</span><br><span class="line"><span class="comment">// ivar_getName(ivar) 意思是获取成员变量名字，如果想获得成员变量的类型用这个 ivar_getTypeEncoding(ivar)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</span><br><span class="line"><span class="built_in">NSString</span> *objcName = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"    %d     %@    "</span>, i, objcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">free(ivars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="打印结果如下（这里直接放截图）"><a href="#打印结果如下（这里直接放截图）" class="headerlink" title="打印结果如下（这里直接放截图）"></a>打印结果如下（这里直接放截图）</h5><p><img src="http://upload-images.jianshu.io/upload_images/2665449-065666a1bd7773b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UITextView 中的属性"></p>
<p>从上面的截图中我们可以看出，打印的结果里有一个 <code>placeHolderLabel</code> 的私有变量，即 <strong>UITextView 类内部有一个名为“_placeHolderLabel”的私有成员变量</strong>。那么就简单多了，我们现在就对这个私有变量进行操作。具体的步骤如下：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)setupTextView &#123;</span><br><span class="line">_textView = [[UITextView alloc] initWithFrame:CGRectMake(<span class="number">0</span>, <span class="number">50</span>, [UIScreen mainScreen].<span class="keyword">bounds.size.width, </span><span class="number">200</span>)]<span class="comment">;</span></span><br><span class="line">_textView.delegate = self<span class="comment">;</span></span><br><span class="line">_textView.tintColor = [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">_textView.font = [UIFont systemFontOfSize:<span class="number">15</span>.f]<span class="comment">;</span></span><br><span class="line">_textView.<span class="keyword">backgroundColor </span>=[UIColor grayColor]<span class="comment">;</span></span><br><span class="line">[self.view <span class="keyword">addSubview:_textView];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">UILabel </span>*placeholderLabel = [[UILabel alloc] init]<span class="comment">;</span></span><br><span class="line">placeholderLabel<span class="meta">.text</span> = @<span class="string">"请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容"</span><span class="comment">;</span></span><br><span class="line">placeholderLabel.font = [UIFont systemFontOfSize:<span class="number">15</span>.f]<span class="comment">;</span></span><br><span class="line">placeholderLabel.textColor = [UIColor whiteColor]<span class="comment">;</span></span><br><span class="line">placeholderLabel.numberOfLines = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">[placeholderLabel sizeToFit]<span class="comment">;</span></span><br><span class="line">[_textView <span class="keyword">addSubview:placeholderLabel];</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">[_textView </span>setValue:placeholderLabel forKey:@<span class="string">"_placeholderLabel"</span>]<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码做的事情，<strong>无非是创建一个 UITextView 和一个 UILabel 控件，然后通过键值对的原理给 UITextView 中的 _placeholderLabel 这一属性赋值</strong>，，，就不详细注释了，重要的是这种思想。。。只需上面这段代码，我们就已经完成了利用 RunTime 为 UITextView 设置占位文本。效果图如下，比较丑但很实用😂：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-85668f6a6f72ba93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="为 UITextView 设置占位文本"></p>
<h5 id="接下来我们开始实时改变文本框占位文本的颜色。"><a href="#接下来我们开始实时改变文本框占位文本的颜色。" class="headerlink" title="接下来我们开始实时改变文本框占位文本的颜色。"></a>接下来我们开始实时改变文本框占位文本的颜色。</h5><p>举个栗子：当我们开始输入时占位文本是白色，结束输入时占位文本是灰色。那我们在哪里设置比较好呢？我在 UITextViewDelegate 中找到了两个方法，可以解决我们的需求</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>textViewShouldBeginEditing:<span class="params">(UITextView *)</span>textView;</span><br><span class="line">- <span class="params">(BOOL)</span>textViewShouldEndEditing:<span class="params">(UITextView *)</span>textView;</span><br></pre></td></tr></table></figure>
<p>看名字就能猜到这俩方法是干嘛的了，这里不再多说，，，我们需要在这两个方法里进行一些操作，先贴代码。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - UITextViewDelegate</span></span><br><span class="line"><span class="meta">#pragma mark - 开始编辑 UITextView</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldBeginEditing:(<span class="built_in">UITextView</span> *)textView &#123;</span><br><span class="line"><span class="comment">// 设置高亮时，占位文字颜色为白色</span></span><br><span class="line">[_textView setValue:[<span class="built_in">UIColor</span> whiteColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br><span class="line"><span class="comment">// 设置光标颜色为白色</span></span><br><span class="line">_textView.tintColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 结束编辑 UITextView</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldEndEditing:(<span class="built_in">UITextView</span> *)textView &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非高亮状态下，占位文字颜色为 lightGrayColor</span></span><br><span class="line">[_textView setValue:[<span class="built_in">UIColor</span> lightGrayColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br><span class="line"><span class="comment">// 设置光标颜色为 lightGrayColor</span></span><br><span class="line">_textView.tintColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上文设置占位文本的思想一样，这里也是 <strong>根据键值对的原理给 _placeholderLabel.textColor 赋值</strong>，开始编辑时设置为白色，结束编辑时设置为 lightGrayColor，具体请看代码中的注释。</p>
<p>到这里实时改变文本框占位文本的颜色也搞定了，是不是觉得很简单，先看下效果图（比较丑但很使用😂），文章结尾我会再次贴出完整的代码。。。自己以后看着方便，也可以帮助有需要的道友少走弯路，，不过文章如果有需要改正或改进的地方，还希望各位同行能多多指点。</p>
<h5 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h5><p><img src="http://upload-images.jianshu.io/upload_images/2665449-f89dfd4f1b745501.gif?imageMogr2/auto-orient/strip" alt="为 UITextView 设置占位文本并实时改变文本框占位文本的颜色"></p>
<h5 id="在需要-UITextView-的页面进行设置，NNViewController-h-中没有相关操作，直接在NNViewController-m-中进行设置即可，当然如果项目中用到-UITextView-这个类比较多的话，你也可以简单封装一下，以便多次利用。。。以下是全部代码"><a href="#在需要-UITextView-的页面进行设置，NNViewController-h-中没有相关操作，直接在NNViewController-m-中进行设置即可，当然如果项目中用到-UITextView-这个类比较多的话，你也可以简单封装一下，以便多次利用。。。以下是全部代码" class="headerlink" title="在需要 UITextView  的页面进行设置，NNViewController.h 中没有相关操作，直接在NNViewController.m 中进行设置即可，当然如果项目中用到 UITextView 这个类比较多的话，你也可以简单封装一下，以便多次利用。。。以下是全部代码"></a>在需要 <code>UITextView</code>  的页面进行设置，<code>NNViewController.h</code> 中没有相关操作，直接在<code>NNViewController.m</code> 中进行设置即可，当然如果项目中用到 <code>UITextView</code> 这个类比较多的话，你也可以简单封装一下，以便多次利用。。。以下是全部代码</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NNViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NNViewController</span> ()&lt;<span class="title">UITextViewDelegate</span>&gt; </span>&#123;</span><br><span class="line"><span class="built_in">UITextView</span> *_textView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NNViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line"><span class="comment">//  获取 UITextView 中所有的成员变量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">Ivar *ivars = class_copyIvarList([<span class="built_in">UITextView</span> <span class="keyword">class</span>], &amp;count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i ++) &#123;</span><br><span class="line">Ivar ivar = ivars[i];</span><br><span class="line"><span class="comment">// ivar_getName(ivar) 意思是获取成员变量名字，如果想获得成员变量的类型用这个 ivar_getTypeEncoding(ivar)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(ivar);</span><br><span class="line"><span class="built_in">NSString</span> *objcName = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"    %d     %@    "</span>, i, objcName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">free(ivars);</span><br><span class="line">[<span class="keyword">self</span> setupTextView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupTextView &#123;</span><br><span class="line">_textView = [[<span class="built_in">UITextView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">50</span>, [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width, <span class="number">200</span>)];</span><br><span class="line">_textView.delegate = <span class="keyword">self</span>;</span><br><span class="line">_textView.tintColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">_textView.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.</span>f];</span><br><span class="line">_textView.backgroundColor =[<span class="built_in">UIColor</span> grayColor];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:_textView];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *placeholderLabel = [[<span class="built_in">UILabel</span> alloc] init];</span><br><span class="line">placeholderLabel.text = <span class="string">@"请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容"</span>;</span><br><span class="line">placeholderLabel.font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15.</span>f];</span><br><span class="line">placeholderLabel.textColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">placeholderLabel.numberOfLines = <span class="number">0</span>;</span><br><span class="line">[placeholderLabel sizeToFit];</span><br><span class="line">[_textView addSubview:placeholderLabel];</span><br><span class="line"></span><br><span class="line">[_textView setValue:placeholderLabel forKey:<span class="string">@"_placeholderLabel"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - UITextViewDelegate</span></span><br><span class="line"><span class="meta">#pragma mark - 开始编辑 UITextView</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldBeginEditing:(<span class="built_in">UITextView</span> *)textView &#123;</span><br><span class="line"><span class="comment">// 设置高亮时，占位文字颜色为白色</span></span><br><span class="line">[_textView setValue:[<span class="built_in">UIColor</span> whiteColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br><span class="line"><span class="comment">// 设置光标颜色为白色</span></span><br><span class="line">_textView.tintColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 结束编辑 UITextView</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)textViewShouldEndEditing:(<span class="built_in">UITextView</span> *)textView &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非高亮状态下，占位文字颜色为 lightGrayColor</span></span><br><span class="line">[_textView setValue:[<span class="built_in">UIColor</span> lightGrayColor] forKeyPath:<span class="string">@"_placeholderLabel.textColor"</span>];</span><br><span class="line"><span class="comment">// 设置光标颜色为 lightGrayColor</span></span><br><span class="line">_textView.tintColor = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - 点击空白页面时收回键盘</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">[<span class="keyword">self</span>.view endEditing:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/算法-几种排序算法 OC 版/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/算法-几种排序算法 OC 版/" itemprop="url">
                  算法-几种排序算法 OC 版
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>如果你交给某人一个程序，你将“折磨”他一整天；如果你教某人如何编写程序，你将“折磨”他一辈子。——《大话数据结构》</p>
</blockquote>
<p>这阵子抽空看了一些算法与数据结构相关的东西，不得不说算法数据结构这些思想真的是博大精深，作为 iOS 开发人员，为什么要学习算法？说实话很多开发人员可能不会算法，但照样能做 App，有位大家都熟悉的大神在几个月前写了篇文章，我也是无意间读到的，<a href="http://chuansong.me/n/1331276728735" target="_blank" rel="noopener">搞 iOS 的学算法有意义吗？</a>，大家有兴趣的话可以去读读。</p>
<blockquote>
<p>这两天看了八大排序算法，并试着用 OC 语言写了几种，给大家分享下！</p>
</blockquote>
<h3 id="算法一：冒泡排序"><a href="#算法一：冒泡排序" class="headerlink" title="算法一：冒泡排序"></a>算法一：冒泡排序</h3><p>个人觉得冒泡排序是最简单的排序了</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pragma mark - 冒泡排序</span></span><br><span class="line">+ (void)<span class="keyword">bubbleSort:(NSMutableArray </span>*)mutableArray &#123;</span><br><span class="line">if(mutableArray == nil <span class="title">||</span> mutableArray.count == <span class="number">0</span>)</span><br><span class="line">return<span class="comment">;</span></span><br><span class="line">NSLog(@<span class="string">"冒泡排序之前: %@"</span>, mutableArray)<span class="comment">;</span></span><br><span class="line">for (NSInteger i = <span class="number">0</span><span class="comment">; i &lt; mutableArray.count; i++) &#123;</span></span><br><span class="line">for (NSInteger <span class="keyword">j </span>= <span class="number">0</span><span class="comment">; j &lt; mutableArray.count - i - 1; j++) &#123;</span></span><br><span class="line">if ([mutableArray[<span class="keyword">j </span>+ <span class="number">1</span>] floatValue] &lt; [mutableArray[<span class="keyword">j] </span>floatValue]) &#123;</span><br><span class="line">CGFloat tempFloat = [mutableArray[<span class="keyword">j] </span>floatValue]<span class="comment">;</span></span><br><span class="line">mutableArray[<span class="keyword">j] </span>= mutableArray[<span class="keyword">j </span>+ <span class="number">1</span>]<span class="comment">;</span></span><br><span class="line">mutableArray[<span class="keyword">j </span>+ <span class="number">1</span>] = [NSNumber numberWithFloat:tempFloat]<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@<span class="string">"冒泡排序之后: %@"</span>, mutableArray)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法步骤：<br>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。<br>3）针对所有的元素重复以上的步骤，除了最后一个。<br>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="算法二：直接插入排序"><a href="#算法二：直接插入排序" class="headerlink" title="算法二：直接插入排序"></a>算法二：直接插入排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 直接插入排序</span></span><br><span class="line">+ (<span class="keyword">void</span>)insertSort:(<span class="built_in">NSMutableArray</span> *)mutableArray &#123;</span><br><span class="line"><span class="keyword">if</span>(mutableArray == <span class="literal">nil</span> || mutableArray.count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"直接插入排序之前: %@"</span>, mutableArray);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; mutableArray.count; i++) &#123;</span><br><span class="line"><span class="built_in">CGFloat</span> tempFloat = [mutableArray[i] floatValue];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; tempFloat &lt; [mutableArray[j] floatValue]; j--) &#123;</span><br><span class="line">mutableArray[j + <span class="number">1</span>] = mutableArray[j];</span><br><span class="line">mutableArray[j] = [<span class="built_in">NSNumber</span> numberWithFloat:tempFloat];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"直接插入排序之后: %@"</span>, mutableArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法步骤：<br>1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<h3 id="算法三：选择排序"><a href="#算法三：选择排序" class="headerlink" title="算法三：选择排序"></a>算法三：选择排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 选择排序</span></span><br><span class="line">+ (<span class="keyword">void</span>)chooseSort:(<span class="built_in">NSMutableArray</span> *)mutableArray &#123;</span><br><span class="line"><span class="keyword">if</span>(mutableArray == <span class="literal">nil</span> || mutableArray.count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"选择排序之前: %@"</span>, mutableArray);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; mutableArray.count; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> j = i + <span class="number">1</span>; j &lt; mutableArray.count; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ([mutableArray[i] floatValue] &gt; [mutableArray[j] floatValue]) &#123;</span><br><span class="line"><span class="built_in">CGFloat</span> tempFloat = [mutableArray[i] floatValue];</span><br><span class="line">mutableArray[i] = mutableArray[j];</span><br><span class="line">mutableArray[j] = [<span class="built_in">NSNumber</span> numberWithFloat:tempFloat];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"选择排序之后: %@"</span>, mutableArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法步骤：<br>1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>3）重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h3 id="算法四：折半插入排序"><a href="#算法四：折半插入排序" class="headerlink" title="算法四：折半插入排序"></a>算法四：折半插入排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 折半插入排序</span></span><br><span class="line">+ (<span class="keyword">void</span>)binaryInsertSort:(<span class="built_in">NSMutableArray</span> *)mutableArray &#123;</span><br><span class="line"><span class="keyword">if</span>(mutableArray == <span class="literal">nil</span> || mutableArray.count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"折半插入排序之前: %@"</span>, mutableArray);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSInteger</span> i = <span class="number">1</span> ; i &lt; mutableArray.count ; i++) &#123;</span><br><span class="line"><span class="built_in">CGFloat</span> tempFloat = [[mutableArray objectAtIndex:i] floatValue];</span><br><span class="line"><span class="built_in">NSInteger</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">NSInteger</span> right = i - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line"><span class="built_in">CGFloat</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tempFloat &lt; [[mutableArray objectAtIndex:middle] floatValue])&#123;</span><br><span class="line">right = middle - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSInteger</span> j = i ; j &gt; left; j--) &#123;</span><br><span class="line">[mutableArray replaceObjectAtIndex:j withObject:[mutableArray objectAtIndex:j - <span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">[mutableArray replaceObjectAtIndex:left withObject:[<span class="built_in">NSNumber</span> numberWithFloat:tempFloat]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"折半插入排序之后: %@"</span>, mutableArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>折半插入排序是对插入排序算法的一种改进，排序算法过程，就是不断的依次将元素插入前面已排好序的序列中。</li>
</ul>
<h3 id="算法五：希尔排序"><a href="#算法五：希尔排序" class="headerlink" title="算法五：希尔排序"></a>算法五：希尔排序</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 希尔排序</span></span><br><span class="line">+ (<span class="keyword">void</span>)shellSort:(<span class="built_in">NSMutableArray</span> *)mutableArray &#123;</span><br><span class="line"><span class="keyword">if</span>(mutableArray == <span class="literal">nil</span> || mutableArray.count == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"希尔排序之前: %@"</span>, mutableArray);</span><br><span class="line"><span class="built_in">NSInteger</span> shellValue = mutableArray.count / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (shellValue &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">NSInteger</span> i = shellValue; i &lt; mutableArray.count; i++) &#123;</span><br><span class="line"><span class="built_in">CGFloat</span> tempFloat = [[mutableArray objectAtIndex:i] floatValue];</span><br><span class="line"><span class="built_in">NSInteger</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= shellValue &amp;&amp; tempFloat &lt; [[mutableArray objectAtIndex:(j - shellValue)] floatValue]) &#123;</span><br><span class="line">[mutableArray replaceObjectAtIndex:j withObject:[mutableArray objectAtIndex:j - shellValue]];</span><br><span class="line">j -= shellValue;</span><br><span class="line">&#125;</span><br><span class="line">[mutableArray replaceObjectAtIndex:j withObject:[<span class="built_in">NSNumber</span> numberWithFloat:tempFloat]];</span><br><span class="line">&#125;</span><br><span class="line">shellValue = shellValue / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"希尔排序之后: %@"</span>, mutableArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>算法步骤：<br>1）选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；<br>2）按增量序列个数k，对序列进行k 趟排序；<br>3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<blockquote>
<p>排序算法就先总结到这里，需要看代码打印效果的童鞋可以到这里下载代码：<a href="https://github.com/liuzhongning/NNSort" target="_blank" rel="noopener">代码传送门</a></p>
</blockquote>
<p>另外分享一篇很不错的博文，<a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a>，下面是各种排序算法的时间复杂度空间复杂度以及稳定性的展示图表：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-60505d0e355b8bc1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自博文八大排序算法"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/15/设计模式-《重构》读书笔记及 APP 重构心得/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘朋坤">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="以梦为马">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/15/设计模式-《重构》读书笔记及 APP 重构心得/" itemprop="url">
                  设计模式-《重构》读书笔记及 APP 重构心得
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
                
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T12:30:20+08:00">2018-04-15</time>
            

            
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前段时间和一同事一起重构了两个 APP，正好想写一些重构心得，前天又在知乎上看到一前辈推荐《重构》这本书，据说是程序员的必读书籍，于是就粗略的读了一遍，对重构有了更深层次的认识了。这里结合 iOS 项目的重构，谈谈与重构相关的问题，做一下记录及分享。</p>
</blockquote>
<h2 id="一、《重构》读书笔记"><a href="#一、《重构》读书笔记" class="headerlink" title="一、《重构》读书笔记"></a>一、《重构》读书笔记</h2><h4 id="1-1-重构的定义"><a href="#1-1-重构的定义" class="headerlink" title="1.1 重构的定义"></a>1.1 重构的定义</h4><ul>
<li>“重构”这个词有两种不同的定义：</li>
<li>第一个定义是名词形式：<br><strong>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</strong></li>
<li>第二个定义是动词形式：<br><strong>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</strong></li>
</ul>
<p>重构的定义说明了两点，第一，重构的目的是使软件更容易被理解和修改；第二，重构不会改变软件可观察的行为——重构之后软件功能一如既往。</p>
<h4 id="1-2-为何重构？"><a href="#1-2-为何重构？" class="headerlink" title="1.2 为何重构？"></a>1.2 为何重构？</h4><ul>
<li><p><strong>重构可以帮你始终良好的控制自己的代码，它可以用于以下几个目的：</strong></p>
</li>
<li><p><strong>重构改进软件设计</strong><br>如果没有重构，程序的设计会逐渐腐败变质。当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，程序员越来越难通过阅读源码而理解原来的设计。<br>完成同一件事情，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事情。因此改进设计的一个重要方向就是消除重复代码。</p>
</li>
<li><p><strong>重构使软件更容易理解</strong><br>书的前面有这么一句话：“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”而重构可以使代码结构更清晰，使代码更容易被理解。</p>
</li>
<li><p><strong>重构帮助找到 bug</strong><br>对代码进行重构，可以深入理解代码的作为，并恰到好处地把新的理解反馈回去，在重构的同时，我们可以发现某些代码逻辑写的不严谨或有问题。</p>
</li>
<li><p><strong>重构提高编程速度</strong><br>良好设计师维持软件开发速度的根本，重构可以帮你更快速地开发软件，因为它阻止系统腐败变质，它甚至还可以提高设计质量。</p>
</li>
</ul>
<h4 id="1-3-何时重构？"><a href="#1-3-何时重构？" class="headerlink" title="1.3 何时重构？"></a>1.3 何时重构？</h4><ul>
<li><p>怎样安排重构时间表？是不是应该每两个月就专门安排两个星期来进行重构呢？这里需要说明，重构不是一件应该特别拨出时间做的事情，重构应该随时随地进行。不应该为重构而重构，我们之所以重构，是因为想做别的事情，而重构可以帮助我们把那些事做好。</p>
</li>
<li><p><strong>三次法则（事不过三，三则重构）</strong><br>第一次做某件事时只管去做；第二次做类似的事情会产生反感，但还是可以去做；第三次再做类似的事情，就应该重构了。</p>
</li>
<li><p><strong>添加功能时重构</strong><br>最常见的重构时机就是我们想给软件添加新特性的时候，此时，重构的直接原因往往是为了帮助我们理解需要修改的代码——这些代码可能是别人写的，也可能是自己写的。</p>
</li>
<li><p><strong>修补错误时重构</strong><br>调试过程中重构，多半是为了让代码更具有可读性。</p>
</li>
<li><p><strong>复审代码时重构</strong><br>代码复审对于编写清晰代码很重要，比如我的代码也许对我自己来说很清晰，但对他人则不然，这是无法避免的，代码复审会让更多人有机会提出有用的建议，然后考虑是否可以通过重构来轻松的实现它们。</p>
</li>
</ul>
<h4 id="1-4-重构的基本技巧："><a href="#1-4-重构的基本技巧：" class="headerlink" title="1.4 重构的基本技巧："></a>1.4 重构的基本技巧：</h4><ul>
<li><strong>小步前进、频繁测试</strong></li>
</ul>
<h2 id="二、结合-iOS-项目重构心得"><a href="#二、结合-iOS-项目重构心得" class="headerlink" title="二、结合 iOS 项目重构心得"></a>二、结合 iOS 项目重构心得</h2><h4 id="2-1-项目目录结构"><a href="#2-1-项目目录结构" class="headerlink" title="2.1 项目目录结构"></a>2.1 项目目录结构</h4><p>项目的目录结构是开发中最基础的，但也是很重要的，清晰的目录结构能够让人一眼就看懂该项目的业务及功能，目录结构也能反应一个开发者的经验及架构水平。项目目录结构比较常规的有两种，第一种是按照业务分类，第二种是按照模块分类。当然具体还得根据具体的业务需求来做，适合自己的才是最好的。</p>
<p>这里有一篇关于项目目录结构的文章，有兴趣的童鞋可以读下：<a href="https://www.jianshu.com/p/77a948bcbc38" target="_blank" rel="noopener">iOS 项目的目录结构能看出你的开发经验</a></p>
<h4 id="2-2-业务与-UI"><a href="#2-2-业务与-UI" class="headerlink" title="2.2 业务与 UI"></a>2.2 业务与 UI</h4><p>这里不讨论 MVC 架构与 MVVM 架构，关于架构模式之间的争论有很多，个人比较赞同一个观点：<a href="https://www.jianshu.com/p/8c4679073393" target="_blank" rel="noopener">不要局限于 MVC、MVVM、MVP 等等一些架构模式，万变不离其宗，真正适用于项目的架构才是最好的架构。</a>刚接手的旧项目在设计初期以及开发过程中，没有进行合理的规划，以至于一些控制器过于臃肿，代码量很多都是超过了 1000 行，有的甚至超过了 1500 行，而且写的很乱。重构的目的，就是提高代码的可读性以及便于以后的维护，我这里按照 MVC 的架构模式，将 UI 部分进行抽离，将工具代码（比如计算球面两点之间的距离）进行封装，并放到了相关的工具类中，又对控制器中的冗余代码进行了整理，使得控制器中的代码减少至之前的三分之一以下。分享一张 cocoa 上的 MVC 架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2665449-afbd6c99f54d9c04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MVC 架构"></p>
<h4 id="2-3-代码还是-xib、-storyboard？"><a href="#2-3-代码还是-xib、-storyboard？" class="headerlink" title="2.3 代码还是 xib、 storyboard？"></a>2.3 代码还是 xib、 storyboard？</h4><p>写 UI 界面用代码还是用 xib 一直是 iOS 界的争论，有的人倾向于使用代码，有的人倾向于使用 xib，巧神之前在博客中也讨论过这个问题，并给出了一些建议（个人比较赞同👍）：</p>
<ul>
<li>对于复杂的、动态生成的界面，建议使用手工编写界面。</li>
<li>对于需要统一风格的按钮或 UI 控件，建议使用手工用代码来构造。方便之后的修改和复用。</li>
<li>对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。</li>
<li>对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。</li>
</ul>
<p>这里是巧神关于写 UI 用代码还是用 xib 的相关讨论： <a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/" title="iOS 开发中的争议（二）" target="_blank" rel="noopener">iOS 开发中的争议（二）</a></p>
<h4 id="2-4-模块化设计"><a href="#2-4-模块化设计" class="headerlink" title="2.4 模块化设计"></a>2.4 模块化设计</h4><p>什么是模块化？比如我们刚开始码代码的时候，有一个经常用的方法（比如还是计算球面两点之间的距离），由于这个方法经常用，我们会把这段代码拿出来放到一个公共类里，以便实现代码的复用，这就是简单的模块化。关于模块化设计的原则，一位阿里大神的建议如下：</p>
<ul>
<li>越底层的模块，应该越稳定，越抽象，越具有高复用度。</li>
<li>不要让稳定的模块依赖不稳定的模块， 减少依赖。</li>
<li>每个模块只做好一件事情，不要让 Common 出现（避免一大堆不相干的代码放进一个模块）。</li>
<li>按照架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象<br>业务模块之间也尽量不要耦合。</li>
</ul>
<p>对模块化设计感兴趣的童鞋可以看下这篇文章，绝对干货！<a href="https://blog.cnbluebox.com/blog/2015/11/28/module-and-decoupling/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="noopener">模块化与解耦</a></p>
<h4 id="2-5-代码规范"><a href="#2-5-代码规范" class="headerlink" title="2.5 代码规范"></a>2.5 代码规范</h4><p>关于代码规范，每个程序员遵守的代码规范多多少少都会有些不同（比如什么时候该空格，常量变量的命名方式等等），之前听一前辈说过，尽量遵守那些“约定俗成”的代码规范，另外在编码时，要保证自己的代码规范始终一致，别给人一种你写的代码是几个人共写的错觉。</p>
<ul>
<li>命名规范<br>iOS 命名主要注意两个方面，第一是可读性高，别人一看这个名字就知道它的含义及作用；第二是防止命名冲突，命名时应遵循驼峰式命名法则，另外要加前缀，比如常量命名一般会在前面加上字母 k。</li>
<li><p>编码规范<br>关于编码规范有很多细节需要注意，比如函数方法一般不能过长；比如实例变量的修饰符要注意；再比如尽可能保证 .h 文件简洁，API 尽量写在实现文件里……编码时还有其它一些应该注意的，比如写 delegate 的时候类型应该为 weak，以避免循环引用；再比如经典的圆角问题，过多的使用 layer.masksToBounds 对系统的开销非常大，会使页面变的卡顿等等……这些编码细节有很多需要注意，就不一一列举了。</p>
</li>
<li><p>写注释<br>写注释写注释写注释，重要的事情说三遍😂。注释可以帮助其他同事更好的理解你写的代码，还方便自己以后的阅读。</p>
</li>
</ul>
<p>代码规范方面，这里也推荐一篇不错的文章：<a href="https://www.jianshu.com/p/b6dc945957fc" target="_blank" rel="noopener">iOS开发-代码细节优化(长期更新)</a></p>
<p>再安利一本书，《编写高质量 iOS 与 OS X 代码的 52 个有效方法》，这本书对编码时应注意的细节写的很全面，之前读过一遍，过几天会再读一遍，并记录。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘朋坤</p>
              <p class="site-description motion-element" itemprop="description">iOS 修炼中...</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘朋坤</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.1.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
