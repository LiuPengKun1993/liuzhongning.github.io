<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-《重构》读书笔记及 APP 重构心得]]></title>
    <url>%2F2018%2F05%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%8F%8A%20APP%20%E9%87%8D%E6%9E%84%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[前段时间和一同事一起重构了两个 APP，正好想写一些重构心得，前天又在知乎上看到一前辈推荐《重构》这本书，据说是程序员的必读书籍，于是就粗略的读了一遍，对重构有了更深层次的认识了。这里结合 iOS 项目的重构，谈谈与重构相关的问题，做一下记录及分享。 一、《重构》读书笔记1.1 重构的定义 “重构”这个词有两种不同的定义： 第一个定义是名词形式：重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 第二个定义是动词形式：重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 重构的定义说明了两点，第一，重构的目的是使软件更容易被理解和修改；第二，重构不会改变软件可观察的行为——重构之后软件功能一如既往。 1.2 为何重构？ 重构可以帮你始终良好的控制自己的代码，它可以用于以下几个目的： 重构改进软件设计如果没有重构，程序的设计会逐渐腐败变质。当人们只为短期目的，或是在完全理解整体设计之前，就贸然修改代码，程序将逐渐失去自己的结构，程序员越来越难通过阅读源码而理解原来的设计。完成同一件事情，设计不良的程序往往需要更多代码，这常常是因为代码在不同的地方使用完全相同的语句做同样的事情。因此改进设计的一个重要方向就是消除重复代码。 重构使软件更容易理解书的前面有这么一句话：“任何一个傻瓜都能写出计算机可以理解的代码，唯有写出人类容易理解的代码，才是优秀的程序员。”而重构可以使代码结构更清晰，使代码更容易被理解。 重构帮助找到 bug对代码进行重构，可以深入理解代码的作为，并恰到好处地把新的理解反馈回去，在重构的同时，我们可以发现某些代码逻辑写的不严谨或有问题。 重构提高编程速度良好设计师维持软件开发速度的根本，重构可以帮你更快速地开发软件，因为它阻止系统腐败变质，它甚至还可以提高设计质量。 1.3 何时重构？ 怎样安排重构时间表？是不是应该每两个月就专门安排两个星期来进行重构呢？这里需要说明，重构不是一件应该特别拨出时间做的事情，重构应该随时随地进行。不应该为重构而重构，我们之所以重构，是因为想做别的事情，而重构可以帮助我们把那些事做好。 三次法则（事不过三，三则重构）第一次做某件事时只管去做；第二次做类似的事情会产生反感，但还是可以去做；第三次再做类似的事情，就应该重构了。 添加功能时重构最常见的重构时机就是我们想给软件添加新特性的时候，此时，重构的直接原因往往是为了帮助我们理解需要修改的代码——这些代码可能是别人写的，也可能是自己写的。 修补错误时重构调试过程中重构，多半是为了让代码更具有可读性。 复审代码时重构代码复审对于编写清晰代码很重要，比如我的代码也许对我自己来说很清晰，但对他人则不然，这是无法避免的，代码复审会让更多人有机会提出有用的建议，然后考虑是否可以通过重构来轻松的实现它们。 1.4 重构的基本技巧： 小步前进、频繁测试 二、结合 iOS 项目重构心得2.1 项目目录结构项目的目录结构是开发中最基础的，但也是很重要的，清晰的目录结构能够让人一眼就看懂该项目的业务及功能，目录结构也能反应一个开发者的经验及架构水平。项目目录结构比较常规的有两种，第一种是按照业务分类，第二种是按照模块分类。当然具体还得根据具体的业务需求来做，适合自己的才是最好的。 这里有一篇关于项目目录结构的文章，有兴趣的童鞋可以读下：iOS 项目的目录结构能看出你的开发经验 2.2 业务与 UI这里不讨论 MVC 架构与 MVVM 架构，关于架构模式之间的争论有很多，个人比较赞同一个观点：不要局限于 MVC、MVVM、MVP 等等一些架构模式，万变不离其宗，真正适用于项目的架构才是最好的架构。刚接手的旧项目在设计初期以及开发过程中，没有进行合理的规划，以至于一些控制器过于臃肿，代码量很多都是超过了 1000 行，有的甚至超过了 1500 行，而且写的很乱。重构的目的，就是提高代码的可读性以及便于以后的维护，我这里按照 MVC 的架构模式，将 UI 部分进行抽离，将工具代码（比如计算球面两点之间的距离）进行封装，并放到了相关的工具类中，又对控制器中的冗余代码进行了整理，使得控制器中的代码减少至之前的三分之一以下。分享一张 cocoa 上的 MVC 架构图： 2.3 代码还是 xib、 storyboard？写 UI 界面用代码还是用 xib 一直是 iOS 界的争论，有的人倾向于使用代码，有的人倾向于使用 xib，巧神之前在博客中也讨论过这个问题，并给出了一些建议（个人比较赞同👍）： 对于复杂的、动态生成的界面，建议使用手工编写界面。 对于需要统一风格的按钮或 UI 控件，建议使用手工用代码来构造。方便之后的修改和复用。 对于需要有继承或组合关系的 UIView 类或 UIViewController 类，建议用代码手工编写界面。 对于那些简单的、静态的、非核心功能界面，可以考虑使用 xib 或 storyboard 来完成。 这里是巧神关于写 UI 用代码还是用 xib 的相关讨论： iOS 开发中的争议（二） 2.4 模块化设计什么是模块化？比如我们刚开始码代码的时候，有一个经常用的方法（比如还是计算球面两点之间的距离），由于这个方法经常用，我们会把这段代码拿出来放到一个公共类里，以便实现代码的复用，这就是简单的模块化。关于模块化设计的原则，一位阿里大神的建议如下： 越底层的模块，应该越稳定，越抽象，越具有高复用度。 不要让稳定的模块依赖不稳定的模块， 减少依赖。 每个模块只做好一件事情，不要让 Common 出现（避免一大堆不相干的代码放进一个模块）。 按照架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象业务模块之间也尽量不要耦合。 对模块化设计感兴趣的童鞋可以看下这篇文章，绝对干货！模块化与解耦 2.5 代码规范关于代码规范，每个程序员遵守的代码规范多多少少都会有些不同（比如什么时候该空格，常量变量的命名方式等等），之前听一前辈说过，尽量遵守那些“约定俗成”的代码规范，另外在编码时，要保证自己的代码规范始终一致，别给人一种你写的代码是几个人共写的错觉。 命名规范iOS 命名主要注意两个方面，第一是可读性高，别人一看这个名字就知道它的含义及作用；第二是防止命名冲突，命名时应遵循驼峰式命名法则，另外要加前缀，比如常量命名一般会在前面加上字母 k。 编码规范关于编码规范有很多细节需要注意，比如函数方法一般不能过长；比如实例变量的修饰符要注意；再比如尽可能保证 .h 文件简洁，API 尽量写在实现文件里……编码时还有其它一些应该注意的，比如写 delegate 的时候类型应该为 weak，以避免循环引用；再比如经典的圆角问题，过多的使用 layer.masksToBounds 对系统的开销非常大，会使页面变的卡顿等等……这些编码细节有很多需要注意，就不一一列举了。 写注释写注释写注释写注释，重要的事情说三遍😂。注释可以帮助其他同事更好的理解你写的代码，还方便自己以后的阅读。 代码规范方面，这里也推荐一篇不错的文章：iOS开发-代码细节优化(长期更新) 再安利一本书，《编写高质量 iOS 与 OS X 代码的 52 个有效方法》，这本书对编码时应注意的细节写的很全面，之前读过一遍，过几天会再读一遍，并记录。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>APP 重构心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 -《大话数据结构》读书笔记(3)]]></title>
    <url>%2F2018%2F04%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%2F</url>
    <content type="text"><![CDATA[文章共分为三篇[第一篇：数据结构 -《大话数据结构》读书笔记(1)]一、数据结构绪论二、算法三、线性表 [第二篇：数据结构 -《大话数据结构》读书笔记(2)]四、栈与队列五、串六、树七、图 [第三篇：数据结构 -《大话数据结构》读书笔记(3)]八、查找九、排序 八、查找8.1 查找概论所有需要被查的数据所在的集合，我们给它一个统称叫查找表。 查找表是由同一类型的数据元素（或记录）构成的集合。 关键字是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素，也可以标识一个记录的某个数据项，我们称为关键码。 若此关键字可以唯一地表示一个记录，则称此关键字为主关键字。这也意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码。 对于那些可以识别多个数据元素（或记录）的关键字，我们称之为次关键字，次关键字也可以理解为是不以唯一标识一个数据元素（或记录）的关键字，它对应的数据项就是次关键码。 查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值得数据元素（或记录）。 若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录的信息，或指示该记录在查找表中的位置。若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给出一个“空”记录或“空”指针。查找表按照操作方式来分有两大种：静态查找表 和 动态查找表。 静态查找表：只查找操作的查找表。它的主要操作有： 查询某个“特定的”数据元素是否在查找表中。 检索某个“特定的”数据元素和各种属性。 动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个： 查找时插入数据元素。 查找时删除数据元素。 为了提高查找的效率，我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为查找结构。 8.2 顺序表查找顺序查找 又叫线性查找，是最基本的查找技术，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。 8.3 有序表查找8.3.1 折半查找折半查找技术，又称为二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录为比较对象，若给定值与中间记录的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，知道查找成功，或所有查找区域无记录，查找失败为止。 8.3.2 插值查找插值查找是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于差值的计算公式 (key - a[low])/(a[high] - a[low])。从时间复杂度来看，它也是 O(logn)，但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多。反之，数组中如果分布类似 {0,1,2,2000,2001,……,999998,999999} 这种极端不均匀的数据，用插值查找未必是很合适的选择。 8.3.3 斐波那契查找斐波那契查找算法的核心在于： 当 key=a[mid] 时，查找就成功； 当 key&lt;a[mid] 时，新范围是第 low 个到第 mid-1 个，此时范围个数为 F[k-1]-1 个； 当 key&gt;a[mid] 时，新范围是第 m+1 个到第 high 个，此时范围个数为 F[k-2]-1 个； 8.4 线性索引查找数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应该包含关键字和其对应的记录在存储器中的位置等信息。索引按照结构可以分为线性索引、树形索引和多级索引。我们这里只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。这里介绍三种线性索引：稠密索引、分块索引和倒排索引。 8.4.1 稠密索引稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如下图： 对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这是稠密索引的优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。 8.4.2 分块索引稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大，为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 分块有序，是把数据记得记录分成了若干块，并且这些块需要满足两个条件。 块内无序，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。 块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来效率。 对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。如下图： 分块索引的索引项结构分为三个数据项： 最大关键码，它存储每一块中的最大关键字，这样的好处是可以使得在他之后的下一块中的最小关键字也能比这一块最大的关键字更大； 存储了块中的记录个数，以便于循环时使用； 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。 8.4.3 倒排索引索引表的通用结构是：次关键码；记录号表。其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。倒排索引源于实际应用中需要根据属性和具有该属性值得各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。 倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长。 8.5 二叉排序树二叉排序树，又称为二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。 若它的左子树不空，则左子树上所有的结点的值均小于它的跟结构的值； 若它的右子树不空，则右子树上所有的节点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。 从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。 构造一棵二叉排序树的目的，其实并不是为了排序，而是为了提高查找和插入删除关键字的速度。 8.6 散列表查找（哈希表）概述散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f ，使得每个关键字 key 对应一个存储位置 f (key)。查找时，根据这个确定的对应关系找到给定值key的影射f(key)，若查找集合中存在这个记录，则必定在f(key) 的位置上。 这里我们把这种对应关系 f 称为散列函数，又称为哈希函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。那么关键字对应的记录存储位置我们称为散列地址。 整个散列过程其实就两步： 在存储时，通过散列函数计算记录的散列地址，并按此散列地址存储该记录。 当查找记录时，我们通过同样的散列函数计算记录的散列地址，按此散列地址访问该记录。所以说，散列技术既是一种存储方法，也是一种查找方法。 九、排序9.1 排序的基本概念与分类假设含有 n 个记录的序列为 {r1, r2, ……, rn}，其对应的关键字分别为 {k1, k2, ……, kn}，需确定 1，2，……，n 的一种排列 p1，p2，……，pn，使其相应的关键字满足 k(p1)&lt;=k(p2)&lt;=……&lt;=k(pn)（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列 {r(p1)，r(p2)，……，r(pn)}，这样的操作就称为排序。 9.1.1 排序的稳定性假设 k(i)=k(j)(1&lt;=i&lt;=n，1&lt;=j&lt;=n，i!=j)，且在排序前的序列中 r(n) 领先于 r(j)（即i&lt;j）。如果排序后 r(i)仍领先于 r(j)，则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中 r(j) 领先于 r(i)，则称所用的排序方法是不稳定的。 9.1.2 内排序与外排序根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和外排序。内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外村之间多粗交换数据才能进行。 对于内排序，排序算法的性能主要是受 3 个方面影响； 时间性能排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免。总之，高效率的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。 辅助空间评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于复杂也会影响排序的性能。 根据排序过程借助的主要操作，我们把内排序分为：插入排序、交换排序、选择排序和归并排序。 9.2 几种排序算法9.2.1 冒泡排序冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 冒泡排序复杂度分析最好的情况，也就是要排序的表本身就是有序的，那么我们比较次数，根据最后改进的代码，可以推断出就是 n-1 次的比较，没有数据交换，时间复杂度为 O(n)；当最坏的情况，即待排序表是逆序的情况，此时需要比较n(n-1)次，并作等数量级的记录移动。因此，总的时间复杂度为 O(n*n)。 9.2.2 简单选择排序简单选择排序法就是通过 n-i 次关键字间的比较，从 n-i+1 个记录选出关键字最小的记录，并和第 i (1&lt;=i&lt;=n)个记录交换之。 简单选择排序复杂度分析从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 i趟排序需要进行n-i次关键字的比较，此时需要比较 n(n-1)/2 次。而对于交换次数而言，当最好的时候，交换为0 次，最差的时候，也就初始降序时，交换次数为 n-1次，基于最终的排序时间是比较与交换的次数的综合，因此，总的时间复杂度依然为 O(n*n)。 9.2.3 直接插入排序直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。 直接插入排序复杂度分析当最好的情况，也就是要排序的表本身就是有序的，没有移动的记录，时间复杂度为 O(n)；当最坏的情况，即待排序表示逆序的情况，此时需要比较 (n+2)(n-1)/2 次，而记录的移动次数也达到最大值(n+4)(n-1)/2次；如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 n*n/4次。因此我们得出直接插入排序法的时间复杂度为O(n*n)。从这里也可以看出，同样的时间复杂度，直接插入排序法比冒泡和简单排序的性能要好一些。 9.2.4 希尔排序 算法步骤：1）选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；2）按增量序列个数k，对序列进行k 趟排序；3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 9.2.5 堆排序堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。 9.2.6 快速排序快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 几种排序算法对比： 代码传送门：排序算法 OC 版结束语：由于个人能力有限，这三篇读书笔记难免有错误或不足之处，还望各位道友能不吝赐教，谢谢。 最后安利一下这本书：PDF版]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《大话数据结构》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 -《大话数据结构》读书笔记(2)]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[文章共分为三篇[第一篇：数据结构 -《大话数据结构》读书笔记(1)]一、数据结构绪论二、算法三、线性表 [第二篇：数据结构 -《大话数据结构》读书笔记(2)]四、栈与队列五、串六、树七、图 [第三篇：数据结构 -《大话数据结构》读书笔记(3)]八、查找九、排序 四、栈与队列4.1 栈的定义 栈栈是限定仅在表尾进行插入和删除操作的线性表。 我们把允许插入和删除的一端称为 栈顶，另一端称为 栈底，不含任何数据元素的栈称为 空栈。栈又称为后进先出的 线性表，简称 LIFO 结构。 栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。 栈的插入操作，叫作进栈，也称压栈、入栈。 栈的删除操作，叫作出栈，也有的叫作弹栈。 4.2 栈的应用栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。 所以现在很多高级语言，比如 Java、C#等都有对栈结构的封装，你可以不用关注它的实现细节，就可以直接使用 Stack 的 push 和 pop 方法，非常方便。 栈的应用——递归在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。 每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。 递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。 递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。 在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。 4.3 队列定义 队列队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。 队列是一种先进先出的线性表，简称 FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。假设队列是 q = (a1, a2, ……, an)，那么 a1 就是队头元素，而 an 就是队尾元素。我们在删除时，总是从 a1 开始；插入时，列在最后。如下图： 同样是线性表，队列也有类似线性表的各种操作，不同的就是插入数据只能在队尾进行，删除数据只能在队头进行。 4.3.1 循环队列解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。 4.3.2 队列的链式存储结构及实现队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。队列的链式存储结构——入队操作入队操作时，其实就是在链表尾部插入结点。队列的链式存储结构——出队操作出队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将 rear 指向头结点。 4.3.3 循环队列与链队列的对比对比：时间上，基本操作都是常数时间，都为 O(1) 的，不过循环队列是事先申请好空间，使用期间不释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差异。空间上，循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接收。所以在空间上，链队列更加灵活。 总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。 五、串5.1 串的定义：串是由零个或多个字符组成的有限序列，又叫字符串。 一般记为 s=“a1a2……an”(n&gt;=0)，其中，s 是串的名字，用双引号括起来的字符序列是串的值，双引号不属于串的内容。a1 可以是字母、数字或其他字符，i 就是该字符在串中的位置。串中的字符数目 n 称为串的长度，定义中谈到“有限”，指的是长度 n 是一个有限的数值。零个字符的串称为空串，它的长度为零。所谓序列，说明串的相邻字符之间具有前驱和后继的关系。 空格串，是只包含空格的串。空格串与空串不同，空格串是有长度的，而且可以不止一个空格。子串和主串，串中任意个数的连续字符组成的子序列称为该串的子串，相应的，包含子串的串称为主串。子串在主串中的位置就是子串的第一个字符在主串中的序号。 5.2 串的比较串的比较是通过组成串的字符之间的编码来进行的，而字符的编码指的是字符在对应字符集中的序号。 C 语言中，比较两个串是否相等，必须是它们的串是否相等，必须是它们串的长度以及它们对应位置的字符都相等时，才算是相等。即给定两个串：s=“a1a2……an”，t=“b1b2……bm”，当且仅当 n = m，且 a1 = b1 ，a2 = b2，……，an=bm 时，我们认为 s=t。 5.3 串的存储结构串的存储结构与线性表相同，分为两种。 5.3.1 串的顺序存储结构串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。 5.3.2 串的链式存储结构对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被栈占满时，可以用“#”或其他非串值字符补全，如下图：这里一个结点存多少字符才合适就变得很重要，这会直接影响着串处理的效率，需要根据实际情况做出选择。 但串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。 六、树6.1 树的定义树是 n (n &gt;= 0) 个结点的有限集。n=0 时称为空树。在任意一棵非空树种：（1）有且仅有一个特定的称为根的结点；（2）当 n&gt;1 时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集，其中每一个集合本身又是一棵树，并且称为根的子树。如下图所示： 6.1.1 结点分类树的结点包含一个数据元素及若干指向子树的分支。结点拥有的子树称为结点的度。度为 0 的结点称为叶节点或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也成为内部结点。树的度是树内各结点的度的最大值。 如上图，这棵树结点的度的最大值是结点 D 的度，为 3，所以树的度也为 3。 6.1.2 结点间关系结点的子树的根称为该结点的孩子，相应的，该结点称为孩子的双亲。同一个双亲的孩子之间互称兄弟。结点的祖先是从根到该结点所经分支上的所有结点。 如上图，对于 H 来说，D、B、A 都是它的祖先。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。B 的子孙有 D、G、H、I。 6.1.3 树的其它相关概念结点的层次从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 i 层，则其子树的根就在第 i + 1 层。其双亲在同一层的结点互为堂兄弟。 在上图中，D、E、F 是堂兄弟，G、H、I、J 也是。树中结点的最大层次称为树的深度或高度，当期树的深度为 4。 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则为无序树。 森林是 m (m&gt;=0) 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。对比线性表与树的结构，它们有很大的不同，如下图： 6.2 二叉树6.2.1 二叉树定义二叉树是 n (n&gt;=0) 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 6.2.2 二叉树特点： 每个结点最多有两棵子树，所以二叉树不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一颗子树都是可以的。 左子树和右子树是有顺序的，次序不能任意颠倒。 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。 6.2.3 二叉树具有五种基本形态： 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 6.2.4 特殊二叉树 斜树所有的结点都只有左子树的二叉树叫左斜树。所有结点都只有右子树的二叉树叫右斜树。 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 完全二叉树对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i (1 &lt;= i &lt;= n) 的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 6.3 遍历二叉树二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树所有结点，使得每个结点被访问一次且仅被访问一次。 二叉树遍历方法 前序遍历若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 前序遍历次序：ABDGHCEIF 中序遍历若二叉树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。 中序遍历次序：GDHBAEICF 后序遍历若二叉树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 后序遍历次序：GHDBIEFCA 层次遍历若二叉树为空，则空操作返回，否则从树的第一层， 层次遍历次序：ABCDEFGHI 七、图7.1 图的定义图是由顶点的有穷非空集和顶点之间边的集合，通常表示为：G(V. E)，其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继。 在树形结构中，数据元素之间有着明显的层次关系，并且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。 图是一种较线性表和树更加复杂的数据结构，在图结构中，节点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。 线性表中我们把数据元素叫元素；树种将数据元素叫结点；在图中数据元素，我们称之为顶点。 线性表中可以没有数据元素，称为空表；树种可以没有结点，叫做空树；但在图结构中，不允许没有顶点。在定义中，若 V 是顶点的集合，则顶点集合 V 有穷非空。 线性表中，相邻的元素之间具有线性关系；树结构中，相邻两层的结点具有层次关系；而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。 7.2 各种图定义 无向边：若顶点 V1 到 V2 之间的边没有方向，则称这条边为无向边，用无序偶对来表示。如果途中任意两个顶点之间都是无向边，则称该图为无向图。如下图：由于是无方向的，连接顶点 A 与 D 的边，可以表示成无序对 (A，D)，也可以表示成 (D，A)。 有向边：若顶点 V1 到 V2 的边有方向，则称这条边为有向边，也称为弧。用有序偶&lt;Vi, Vj&gt; 来表示，Vi 称为弧尾，Vj 称为弧头。如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。如下图： 连接顶点 A 到 D 的有向边就是弧，A 是弧尾，D 是弧头，&lt;A, D&gt; 表示弧，注意不能写成&lt;D, A&gt;。 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有 n 个顶点的无向完全图有 n * (n - 1) / 2 条边。 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。含有 n 个顶点的有向完全图有 n * (n - 1) 条边。 从这里可以得出结论，对于具有 n 个顶点和 e 条边数的图，无向图 0&lt;= e &lt;= n(n-1)/2，有向图 0 &lt;= e &lt;= n(n-1)。 7.3 图的遍历从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。 7.3.1 深度优先遍历深度优先遍历，也有称为深度优先搜索，简称 DFS。它从图中某个顶点 V 出发，访问此顶点，然后从 V 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 V 有路径相通的顶点都被访问到。 7.3.2 广度优先遍历广度优先遍历，又称为广度优先搜索，简称 BFS。 对比图的深度优先遍历和广度优先遍历算法，它们在时间复杂度上是一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《大话数据结构》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构 -《大话数据结构》读书笔记(1)]]></title>
    <url>%2F2018%2F04%2F14%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20-%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[前公司的经理大哥建议过我，说趁年轻要深入学习算法与数据结构，设计模式， APP 架构，当然也包括 iOS 底层的一些知识……半年多过去了，算法数据结构方面的书多少算是看过一些，但都是走马观花似的一掠而过，根本没留下什么印象……2018 突然就到了……接下来会多读书，并记录下来，算是对自己的督促，更希望对看到的朋友有所帮助。 文章共分为三篇[第一篇：数据结构 -《大话数据结构》读书笔记(1)]一、数据结构绪论二、算法三、线性表 [第二篇：数据结构 -《大话数据结构》读书笔记(2)]四、栈与队列五、串六、树七、图 [第三篇：数据结构 -《大话数据结构》读书笔记(3)]八、查找九、排序 一、数据结构绪论1.1 数据结构数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。 1.2 基本概念和术语 数据数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据不仅仅包括整形、实型等数值类型，还包括字符及声音、图像、视频等非数值类型。 数据元素数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 比如动物类中，牛、马、羊、鸡、鸭、鹅就是其数据元素。 数据项一个数据元素可以由若干数据项组成。数据项是数据不可分割的最小单位。 比如人这样的数据元素，有眼、耳、鼻、口、手、脚这些数据项，也可以有姓名、年龄、性别、出生地址、联系电话等数据项，具体哪些数据项，要根据你的系统决定。 数据对象数据对象是性质相同的数据元素的集合，是数据的子集。 所谓性质相同，是指数据元素具有相同数量和类型的数据项，比如人都有姓名，性别，生日等相同的数据项。 数据结构数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 研究数据结构的意义：在计算机中，数据元素不是孤立、杂乱无序的，而是具有内在联系的数据集合。数据元素之间存在的一种或多种特定关系，也就是数据的组织形式。为编写一个好的程序，必须分析待处理对象的特性及各处理对象之间存在的关系。这也就是研究数据结构的意义所在。 1.3 逻辑结构和物理结构：按照视点的不同，可以把数据结构分为逻辑结构和物理结构。 逻辑结构逻辑结构是指数据对象中数据元素之间的相互关系。 逻辑结构分为以下四种： 集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。各个数据元素是“平等”的，它们的共同属性是同属于一个集合。 线性结构：线性结构中的数据元素是一对一的关系。 树形结构：树形结构中的元素之间存在一种一对多的层次关系。 图形结构：图形结构的数据元素是多对多的关系。 物理结构物理结构（存储结构）：是指数据的逻辑结构在计算机中的存储形式。 数据是数据元素的集合，那么根据物理结构的定义，实际上就是如何把数据元素存储到计算机的存储器中。数据的存储结构应正确反映数据元素之间的逻辑关系，这才是最关键的，如何存储数据元素之间的逻辑关系，是实现物理结构的重点和难点。 数据元素的存储结构形式有两种：顺序存储和链式存储。 顺序存储结构顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 顺序存储结构说白了就是排队占位，大家都按顺序排好，每个人占一小段控件，大家谁也别插谁的队。数组就是这样的顺序存储结构。 链式存储结构链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。 数据元素的存储关系并不能反应其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。链式存储结构比较灵活，数据存在哪里不重要，只要有一个指针存放了相应的地址就能找到它了。比如现在去银行医院等地方，去了先领一个号，等着叫号，在等待的时候你可以做任何事情，只要及时回来就行。 1.4 抽象数据类型： 数据类型数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 数据类型是按照值的不同进行划分的，在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。 抽象抽象：抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。 在C语言中，按照取值的不同，数据类型可以分为两类： 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等； 数据类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。 抽象数据类型抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算及内部如何表示和实现无关。 比如在大型机、小型机、PC、平板电脑、PDA，甚至智能手机都拥有“整数”类型，也需要整数间的运算，那么整型其实就是一个抽象数据类型，尽管它在上面提到的这些在不同计算机中实现方法上可能不一样，但由于其定义的数学特性相同，在计算机编程者看来，它们都是相同的。因此，“抽象”的意义在于数据类型的数学抽象特性。 二、算法2.1 算法定义算法是解决待定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 2.2 算法的特性算法有五个基本特性：输入、输出、有穷性、确定性和可行性。 输入输出输入和输出特性比较容易理解，算法具有零个或多个输入。绝大多数算法需要输入参数，但有的是不需要的，不如“hello world”这样的代码，不需要任何参数，因此算法的输入可以是零个。算法至少有一个或多个输出，算法是一定要输出的，不需要输出，那用这个算法干嘛？输出的形式可以使打印输出，也可以是返回一个或多个值。 有穷性有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。 确定性：算法的每一步骤都具有确定的含义，不会出现二义性。 算法在一定条件下，只有一条执行路径，相同的输入只能有唯一的输出结果，算法的每个步骤被精确定义而无歧义。 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。 2.3 算法设计的要求算法不是唯一的，同一个问题，可以有很多种解决问题的算法。好的算法应该具有以下几点要求： 正确性：正确性：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。 算法的“正确”通常在语法上有很大的差别，大体分为以下四个层次。 算法程序没有语法错误； 算法程序对于合法的输入数据能够产生满足要求的输出结果； 算法程序对于非法的输入数据能够得出满足规格说明的结果； 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。 一般情况下，我们把层次 3 作为算法是否正确的标准。 可读性：可读性：算法设计的另一目的是为了便于阅读、理解和交流。 我们写代码的目的，一方面是为了让计算机执行，另一方面是为了便于他人阅读，让人理解和交流，自己将来也可能阅读，如果可读性不好，时间长了自己都不知道写了什么，可读性是算法好坏的一个很重要的标志。 健壮性健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。 时间效率高和存储量低时间效率指的是算法的执行时间，对于同一个问题，如果有多个算法可以解决，执行时间短的算法效率高，执行时间长的效率低。存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。设计算法应该尽量满足时间效率高和存储量低的需求。 综上，好的算法，应该具有正确性、可读性、健壮性、高效性和低存储量的特点。 2.4 函数的渐进增长 函数的渐进增长：给定两个函数f(n)与g(n)，如果存在一个整数N，使得对于所有n&gt;N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐进快于g(n)。 例子 1：A 算法与 B 算法，A 算法要做 2n+3 次操作；B 算法要做 3n+1 次操作。问哪个执行的更快？ 由上图可知，当 n = 1，算法 A 效率不如算法 B；当 n = 2 时，两者效率相同；当 n &gt; 2 时，算法A开始优于算法 B了。得出结论，加法常数可以忽略。 例子 2： C 算法与 D 算法，C 算法要做 4n+8 次操作；D 算法要做 2 n*n +1 次操作。问哪个执行的更快？ 由上图可知，当 n &lt;= 3 时，算法 C 差于算法 D；当 n &gt; 3 时，算法 C 的优势开始越来越优于算法 D 了。得出结论：与最高次项相乘的常数并不重要。 2.5 算法时间复杂度 算法时间复杂度定义算法时间复杂度：在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模n的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。 这样用大写 O() 来体系那算法时间复杂度的记法，我们称之为大 O 记法。 一般情况下，随着n的增大，T(n) 增长最慢的算法为最优算法。 常用的算法时间复杂度 推导大 O 阶方法 用常数 1 取代运行时间中的所有加法常数 在修改后的运行次数函数中，只保留最高阶项 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。 得到的结果就是大 O 阶。 2.6 算法空间复杂度 算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n 为问题的规模，f(n) 为语句关于 n 所占存储空间的函数。 一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。若输入数据所占空间只取决于问题本身，和算法无关，这样只需要分析该算法在实现时所需的辅助单元即可。若算法执行时所需的辅助空间相对于输入的数据量而言是个常数，则称此算法为原地工作，空间复杂度为 O(n)。 通常，我们都使用“时间复杂度”来指运行时间的需求，使用“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。 三、线性表3.1 线性表定义零个或多个数据元素的有限序列。 首先它是一个序列。也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其它元素都有且只有一个前驱一个后继。 然后，线性表强调是有限的，即元素个数是有限的。 3.2 线性表的抽象数据类型对于一个线性表来说，插入或者删除数据都是必须的操作，因此线性表的抽象数据类型定义如下： 1234567891011121314ADT线性表(List)Data线性表的数据对象集合为 (a1, a2, a3, ……, an)， 每个元素的类型均为 DataType。其中，除第一个元素外，每个元素有且只有一个直接前驱元素；除了最后一个元素外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。OperationInitList (*L) : 初始化操作，建立一个空的线性表L。ListEmpty (L): 若线性表为空，返回 true，否则返回 false。ClearList (*L): 将线性表清空。GetElem (L, i, *e): 将线性表 L 中的第 i 个元素值返回给 e。LocateElem (L, e): 在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回 0 表示失败。ListInsert (*L, i, e): 在线性表 L 中的第 i 个位置插入新元素 e。ListDelete (*L, i, *e): 删除线性表 L 中第 i 个位置元素，并用 e 返回其值。ListLength (L): 返回线性表 L 的元素个数。endADT 对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。 3.3 线性表的顺序存储结构3.3.1 顺序存储定义先来看看线性表的两种物理结构的第一种——顺序存储结构。 顺序存储结构线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 线性表的顺序存储示意图如下： 3.3.2 顺序存储方式线性表的顺序存储结构，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用 C 语言（其它语言也相同）的一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置。 线性表顺序存储的结构代码： 123456789101112/* 存储空间初始分配量 */#define MAXSIZE 20/* ElemType 类型根据实际情况而定，这里假设为 int */typedef int ElemType;typedef struct &#123;/* 数组存储数据元素，最大值为 MAXSIZE */ElemType data [MAXSIZE];/* 线性表当前长度 */int length;&#125;SqList; 这里我们发现描述顺序存储结构需要三个属性： 存储空间的起始位置：数组 data， 它的存储位置就是存储空间的存储位置。 线性表的最大存储容量：数组长度 MAXSIZE。 线性表的当前长度：length。 3.3.3 数据长度与线性表长度区别 数组长度指的是存放线性表的存储空间的长度，存储分配后这个量一般是不变的（一般高级语言，比如 C，VB， C++都可以用编程手段实现动态分配数组长度，不过这回带来性能上的损耗）。 线性表的长度指的是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 在任何时刻，线性表的长度都应该小于等于数组的长度。 3.3.4 地址计算方法C 语言中的数组是从 0 开始第一个下标的，线性表的第 i 个元素是要存储在数组下标为i - 1的位置，即数据元素的序号和存放它的数组下标之间存在对应关系（如下图）。 用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度。 地址存储器中的每个存储单元都有自己的编号，这个编号称为地址。 3.4 顺序存储结构的插入和删除3.4.1 插入算法的思路 如果插入位置不合理，抛出异常 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置 将要插入元素填入位置 i 处 表长加 1 3.4.2 删除算法的思路 如果删除位置不合理，抛出异常 取出删除元素 从删除元素开始遍历到最后一个元素位置，分别将它们都向前移动一个位置 表长减 1 3.4.3 插入和删除的时间复杂度 先来看最好情况，如果元素要插入到最后一个位置，或者删除最后一个元素，此时时间复杂度为O(1)，因为不需要移动元素的。 最坏的情况，就是元素要插入到第一个位置，或者删除第一个元素，此时所有元素都要移动，时间复杂度为 O(n)。 平均移动次数为(n - 1) / 2，可以得出平均时间复杂度是O(n)。 3.4.4 线性表顺序存储结构的优缺点 优点 无须为表示表中元素之间的逻辑关系而增加额外的存储空间 可以快速地存取表中任一位置的元素。 缺点： 插入和删除操作是需要移动大量元素 当线性表长度变化较大时，难以确定存储空间的容量 造成存储空间的“碎片”。 3.5 线性表的链式存储结构3.5.1 顺序存储结构的不足顺序存储结构最大的缺点就是插入和删除时需要移动大量元素，这显然就需要耗费时间。 3.5.2线性表链式存储结构定义线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素可以存在内存未被占用的任意位置。 在顺序结构中，每个数据元素只需要存数据元素信息就可以了，但在链式结构中，除了要存数据元素信息外，还要存储它的后继元素的存储地址。 为了表示每个数据元素 a(i) 与其直接后继数据元素 a(i+1) 之间的逻辑关系，对数据元素a(i)来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a(i)的存储映像，称为结点(Node)。 N 个结点链接成一个链表，即为线性表（a1，a2，…，a（n））的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起。如下图所示： 对于线性表来说，总得有个头有个尾，链表也不例外。我们把链表中第一个结点的存储位置叫做头指针，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。最后一个结点指针为“空”，如下图所示： 有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储诸如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。如下图所示： 3.5.3 头指针与头结点的异同 头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 头指针具有标识作用，所以常用指针冠以链表的名字 无论链表是否为空，头指针均不为空，头指针是链表的必要元素。 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了 头结点不一定是链表必须要素。 3.6 单链表的读取在线性表的顺序存储结构中，我们要计算任意一个元素的存储位置是很容易的，但在单链表中，必须得从头开始找。因此，对于单链表实现获取第 i 个元素的数据的操作 GetElem ，在算法上，相对要麻烦一些。 获得链表第 i 个数据的算法思路： 声明一个结点 p 指向链表第一个结点，初始化 j 从 1 开始； 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1； 若到链表末尾 p 为空，则说明第 i 个元素不存在； 否则查找成功，返回结点 p 的数据。 3.7 单链表的插入和删除3.7.1单链表的插入假设存储元素 e 的结点为 s，要实现结点 p、p-&gt;next 和 s 之间逻辑关系的变化，只需将结点 s 插入到结点 p 和 p-&gt;next 之间即可。如何插入？ 用不着惊动其它结点，只需让 s-&gt;next 和 p-&gt;next 的指针做一点改变即可。1s-&gt;next=p-&gt;next; p-&gt;next=s; 解读代码：让 p 的后继结点改成 s 的后继结点，再把结点 s 变成 p 的后继结点。 单链表第 i 个数据插入结点的算法思路： 声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始； 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一结点，j 累加 1； 若到链表末尾 p 为空，则说明第 i 个元素不存在； 否则查找成功，在系统中生成一个空结点 s； 将数据元素 e 赋值给 s-&gt; data； 单链表的插入标准语句 s-&gt;next = p-&gt;next; p-&gt;next=s； 返回成功 3.7.2单链表的删除假设存储元素 a 的结点为 q，要实现结点 q 删除单链表的操作，其实就是将它的前继结点的指针绕过，指向它的后继结点即可。 1q=p-&gt;next; p-&gt;next=q-&gt;next; 解读代码：让 p 的后继结的后继结点改成 p 的后继结点。 单链表第 i 个数据删除结点的算法思路： 声明一结点 p 指向链表第一个结点，初始化 j 从 1 开始； 当 j &lt; i 时，就遍历链表，让 p 的指针向后移动，不断指向下一个结点，j 累加 1； 若到链表末尾 p 为空，则说明第 i 个元素不存在； 否则查找成功，将欲删除的结点 p-&gt;next 赋值给 q； 单链表的删除标准语句 p-&gt;next=q-&gt;next; 将 q 结点中的数据赋值给 e，作为返回； 释放 q 结点； 返回成功。 3.8 单链表的整表创建与删除3.8.1 单链表的整表创建顺序存储结构的创建，其实就是一个数组的初始化，即声明一个类型和大小的数组并赋值的过程。而链表和顺序存储结构不一样，它不像顺序存储结构这么集中，它可以很散，是一种动态结构。对每个链表来说，它所占用空间的大小和位置是不需要预先分配划定的，可以根据系统的情况和实际的需求即时生成。 所以创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始化状态起，依次建立各元素结点，并逐个插入链表。 单链表整表创建的算法思路： 声明一结点 p 和计数器变量 i； 初始化一空链表L； 让 L 的头结点的指针指向 NULL，即建立一个带头结点的单链表； 循环：生成一新结点赋值给 p；随机生成一数字赋值给 p 的数据域 p-&gt;data；将 p 插入到头结点与前一新结点之间。 3.8.2 单链表的整表删除当我们不打算使用这个单链表时，我们需要把它销毁，其实也就是在内存中将它释放掉，以便留出空间给其它程序或软件使用。 单链表整表删除的算法思路： 声明一结点 p 和 q； 将第一个结点赋值给 p； 循环：将下一结点赋值给 q；释放 p；将 q 赋值给 p。 3.9 单链表结构与顺序存储结构优缺点 链表结构和顺序存储结构对比图：由上图可知，线性表的顺序存储结构和单链表结构各有其优缺点，不能简单的说哪个好哪个不好，需要根据实际情况，来综合平衡采用哪种数据结构更能满足和达到需求和性能。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《大话数据结构》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(3)]]></title>
    <url>%2F2018%2F03%2F26%2FiOS%20%E5%BC%80%E5%8F%91%20-%E3%80%8A52%20%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)%2F</url>
    <content type="text"><![CDATA[文章共分为三篇：第一篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(1)]第二篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(2)]第三篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(3)] 第 6 章 块与大中枢派发第 35 条：理解 “块”这一概念blcok和函数类似，它是直接定义在另一个函数里的，和定义它的那个函数共享同一个范围的东西。用^来表示，后面接一对大括号，括号里是blcok的实现代码。 格式： 返回类型 （^blockName）(参数){实现代码}; 1234567891011121314151617// 无返回值无参数void(^testBlcok)(void) = ^&#123;NSLog(@&quot;testBlcok&quot;);&#125;;testBlcok(); // print：&quot;testBlcok&quot;// 无返回值有参数void(^testBlcok)(int a) = ^(int a) &#123;NSLog(@&quot;%d&quot;, a);&#125;;testBlcok(5); // print：&quot;5&quot;// 有返回值有参数int (^addBlock)(int a, int b) = ^(int a, int b) &#123;return a + b;&#125;;NSLog(@&quot;%d&quot;, addBlock(13, 6)); // print：&quot;19&quot; block可以访问局部变量，但是不能修改，如果修改局部变量，需要加__block 12345678__block NSInteger count = 0;int additional = 5;int (^addBlock)(int a, int b) = ^(int a, int b) &#123;count = count + 10;return a + b + additional;&#125;;NSLog(@&quot;addBlock = %d&quot;, addBlock(13, 6)); // print：&quot;24&quot;NSLog(@&quot;count = %ld&quot;, count); // print：&quot;10&quot; 另外关于block的修饰符应该注意：1.如果用copy修饰Block，该Block就会存储在堆空间。则会对Block的内部对象进行强引用，导致循环引用。内存无法释放。解决方法：新建一个指针(__weak typeof(Target) weakTarget = Target )指向Block代码块里的对象，然后用weakTarget进行操作。就可以解决循环引用问题。2.如果用weak修饰Block，该Block就会存放在栈空间。不会出现循环引用问题。 第 36 条：为常用的块类型创建 typedef为常用的块类型创建 typedef，主要是为了代码的易读性，用的时候也较为方便。请看下面代码对比：12345678// 第一种写法- (void)testWithBlockString:(NSString *)string withBlock:(void(^)(id dataSource))block;/* 这种写法非常难记，也很难懂，用的时候不方便 */// 第二种写法typedef void (^testBlock)(id dataSource);- (void)testWithBlockString:(NSString *)string withBlockName:(testBlock)block;/* 用 typedef 关键字，为常用的块类型起个别名，方便易懂 */ 第 37 条：用 handler 块降低代码分散程度在iOS开发中，我们经常会异步处理一些任务，然后等任务执行结束后通知相关方法。实现此需求的方法有很多，比如可以选择代理委托，也可以选择block。block更轻型，使用更简单，能够直接访问上下文，这样类中不需要存储临时数据，使用block的代码通常会在同一个地方，这样使代码更连贯，可读性好。12typedef void (^testBlock)(id dataSource);- (void)testWithBlockString:(NSString *)string withBlockName:(testBlock)block; 第 38 条：用块引用其所属对象时不要出现保留环这条讲的比较基础，是iOS中block的循环引用问题。所谓循环引用，就是两个对象相互持有，这样就会造成循环引用。 请看下面代码： 12345678910typedef void (^testBlock)(id dataSource);@property (copy, nonatomic) testBlock block;@property (nonatomic, copy) NSString *blockString;- (void)testBlock &#123;self.block = ^(id dataSource) &#123;NSString *blockString = self.blockString;NSLog(@&quot;blockString = %@&quot;, blockString);&#125;;&#125; 代码截图： 解决方法：1234567- (void)testBlock &#123;__weak typeof(self) weakSelf = self;self.block = ^(id dataSource) &#123;NSString *blockString = weakSelf.blockString;NSLog(@&quot;blockString = %@&quot;, blockString);&#125;;&#125; 但并非所有 block 都会造成循环引用，在开发中，一些同学只要有block的地方就会用__weak来修饰对象，其实没有必要，以下几种block是不会造成循环引用的： 大部分GCD方法1234dispatch_async(dispatch_get_main_queue(), ^&#123;NSString *blockString = self.blockString;NSLog(@&quot;blockString = %@&quot;, blockString);&#125;); 代码解读：因为self并没有对GCD中的block进行持有，所以不会形成循环引用。 block 属于另外一个类 1234[NNHomeViewController testWithBlockName:^(id dataSource) &#123;NSString *blockString = self.blockString;NSLog(@&quot;blockString = %@&quot;, blockString);&#125;]; 代码解读：同上，block不是被self所持有的。 block并不是属性值，而是临时变量1234567891011- (void)viewDidLoad &#123;[super viewDidLoad];[self testWithBlock:^&#123;NSString *blockString = self.blockString;NSLog(@&quot;blockString = %@&quot;, blockString);&#125;];&#125;- (void)testWithBlock:(void(^)(void))block &#123;block();&#125; 第 39 条：多用派发队列，少用同步锁在 OC 中，如果有多个线程要执行同一份代码，有时可能会出问题。这种情况下，通常要使用锁来实现某种同步机制。 GCD 出现之前通常使用两种方法： 第一种：内置的“同步块” 12345- (void)synchronizedMethod &#123;@synchronized(self) &#123;// safe&#125;&#125; 这种写法会根据给定的对象，自动创建一个锁，并等待块中代码执行完毕。执行到这段代码结尾处，锁就释放了。但滥用@synchronized(self)会很大程度上降低代码效率，因此不推荐使用。 第二种：直接使用 NSLock 对象(也可以使用 NSRecursiveLock 递归锁)1234567_lock = [[NSLock alloc] init];- (void)synchronizedMethod &#123;[_lock lock];// safe[_lock unlock];&#125; 这种写法也有缺陷，在极端情况下，同步块会导致死锁，另外与 GCD 相比效率也很低。 推荐：GCD 方式12345678910111213- (NSString *)testString &#123;__block NSString *localTestString;dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;localTestString = self.testString;&#125;);return localTestString;&#125;- (void)setTestString:(NSString *)testString &#123;dispatch_barrier_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;self.testString = testString;&#125;);&#125; 使用同步队列及栅栏块，可以令同步行为更加高效。 第 40 条：多用 GCD，少用 performSelector 系列方法在 GCD 出现之前，开发者延迟调用一些方法，或者指定运行方法的线程会用 performSelector，但是在 GCD 出来之后就不需要再使用performSelector了。 performSelector 系列的方法： 12345678910111213- (id)performSelector:(SEL)aSelector;- (id)performSelector:(SEL)aSelector withObject:(id)object;- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg; performSelector 方法存在的缺点 内存管理问题：在ARC下使用performSelector编译器经常出现警告，因为它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。 performSelector系列方法所能处理的选择子太过于局限，performSelector的返回值只能是void或对象类型；而且它无法处理带有多个参数的选择子，最多只能处理两个参数。 用 GCD 代替 performSelector 系列方法 延迟调用方法： 1234567// GCDdispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC)); dispatch_after(time, dispatch_get_main_queue(), ^(void)&#123;[self doSomething];&#125;);// performSelector[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0]; 指定运行方法的线程： 1234567// GCDdispatch_async(dispatch_get_main_queue(), ^&#123;[self doSomething];&#125;);// performSelector[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO]; 第 41 条：掌握 GCD 及操作队列的使用时机这条讲的是什么时候该用 GCD，什么时候不该用GCD。GCD技术确实很棒，但GCD并不总是最佳解决方案。比如当我们想取消队列中的某个操作时，或者需要后台执行任务时，这时我们可以用NSOperationQueue，其实NSOperationQueue跟GCD有很多相像之处。NSOperationQueue在GCD之前就已经有了，GCD就是在其某些原理上构建的。GCD是C层次的API，而NSOperation是重量级的OC对象。 使用NSOperation及NSOperationQueue的好处如下： 取消某个操作。 指定操作间的依赖关系。 通过键值观察机制监控NSOperation对象的属性。 指定操作的优先级。 重用NSOperation对象。 第 42 条：通过 Dispatch Group 机制，根据系统资源状况来执行任务dispatch group是GCD的一项特性，能够把任务分组。调用者可以等待这组任务执行完毕，也可以在提供回调函数之后继续往下执行，这组任务完成时，调用者会得到通知，开发者可以拿到结果然后继续下一步操作。 请看以下代码： 12345678910111213141516171819dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 创建一个队列组dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123;// 添加操作...NSLog(@&quot;1%@&quot;, [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123;// 添加操作...NSLog(@&quot;2%@&quot;, [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123;// 添加操作...NSLog(@&quot;3%@&quot;, [NSThread currentThread]);&#125;);// 收到通知，回到主线程刷新UIdispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;回到主线程刷新UI&quot;);&#125;); 多个任务可归入一个dispatch group之中。开发者可以在这组任务执行完毕时获得通知。 第 43 条：使用 dispatch_once 来执行只需运行一次的线程安全代码这条讲的单例模式，即常用的dispatch_once。使用 dispatch_once 可以简化代码并且彻底保证线程安全，我们根本无须担心加锁或同步，另外它没有使用重量级的同步机制，所以也更高效。 12345678+ (id)shareInstance &#123;static EOCClass *sharedInstance = nil;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;sharedInstance = [[self alloc] init];&#125;);return sharedInstance;&#125; 第 44 条：不要使用 dispatch_get_current_queue dispatch_get_current_queue 函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用。 由于GCD是按层级来组织的，所以无法单用某个队列对象来描述”当前队列”这一概念。 dispatch_get_current_queue 函数用于解决由不可以重入的代码所引发的死锁，然后能用此函数解决的问题，通常也可以用”队列特定数据”来解决。 第 7 章 系统框架第 45 条：熟悉系统框架开发者会碰到的主要框架就是Fundation。另外还有个与Fundation相伴的框架，叫做CoreFoundation。除了Fundation与CoreFoundation，还有很多系统库，其中包括但不限于下面列出的这些： CFNetwork：此框架提供了 C 语言级别的网络通信能力，它将 BSD 套接字(BSD socket)抽象成易于使用的网络接口。而 Foundation 则将该框架里的部分内容封装为OC语言的接口，以便进行网络通信。 CoreAudio：此框架所提供的C语言API可以用来操作设备上的音频硬件。 AVFoundation：此框架所提供的OC对象可用来回访并录制音频及视频，比如能够在UI视图类里播放视频。 CoreData：此框架所提供的OC接口可以将对象放入数据库，将数持久保存。 CoreText：此框架提供的C语言接口可以高效执行文字排版以及渲染操作。 要点： 许多系统框架都可以直接使用。其中最重要的是Fundation与CoreFoundation，这两个框架提供了构架应用程序所需的许多核心功能。 很多常见任务都能用框架来做。例如音频与视频处理、网络通信、数据管理等。 用纯C写成的框架与用OC写成的一样重要，若想成为优秀的OC开发者，应该掌握C语言的核心概念。 第 46 条：多用块枚举，少用 for 循环遍历collection有四种方式。最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新最先进的方式则是“块枚举法”。 四种遍历方法：12345678910111213141516171819202122232425262728NSArray *testArray = @[@1, @2, @3, @4, @5];// for 循环遍历for (int i = 0; i &lt; testArray.count; i ++) &#123;NSLog(@&quot;testArray[%d] = %@&quot;, i, testArray[i]);&#125;// NSEnumerator遍历法NSEnumerator *enumerator = [testArray objectEnumerator];id object;while ((object = [enumerator nextObject]) != nil) &#123;NSLog(@&quot;object = %@&quot;, object);&#125;// 快速遍历for (NSObject *obj in testArray) &#123;NSLog(@&quot;obj = %@&quot;, obj);&#125;// 块枚举遍历数组[testArray enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;NSLog(@&quot;idx = %zd, obj = %@&quot;, idx, obj);&#125;];// 块枚举遍历字典NSDictionary *testDic = @&#123;@&quot;name&quot;:@&quot;liu zhong ning&quot;,@&quot;age&quot;:@&quot;25&quot;&#125;;[testDic enumerateKeysAndObjectsUsingBlock:^(NSString * key,id object,BOOL * stop)&#123;NSLog(@&quot;testDic[%@] = %@&quot;, key, object);&#125;]; 块枚举法拥有其他遍历方式都具备的优势，而且还能带来更多好处，在遍历字典的时候，还可以同时提供键和值，而且还有选项可以开启并发迭代功能，所以多写点代码还是值的。 第 47 条：对自定义其内存管理语义的collection使用无缝桥接通过无缝桥接技术，可以在Foundation框架中的OC对象与CoreFoundation框架中的C语言数据结构之间来回转换。 简单的无缝桥接示例： 1234NSArray *testNSArray = @[@1, @2, @3, @4, @5];CFArrayRef testCFArray = (__bridge CFArrayRef)testNSArray;NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(testCFArray));// Output：Size of array = 5 __bridge：ARC仍然具备这个Objective对象的所有权。 __bridge_retained:ARC将交出对象的所有权。 __bridge_transfer：C转化为OC 想深入了解无缝桥接技术的童鞋可以点击这里：iOS无缝桥接官方文档 第 48 条：构建缓存时选用 NSCache 而非 NSDictionary 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。 可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”，他们仅对NSCache起指导作用。 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。 如果缓存使用得当，那么应用程序的相应速度就能提高。只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 第 49 条：精简 initialize 与 load 的实现代码 当程序启动的时候，类和分类，必定会调动且仅调用一次load方法。先调用类的load方法，再调用分类的load方法。先调用超类的load方法，再调用子类的load方法。load方法需要实现得精简一些，因为整个应用程序会在执行load方法时都会阻塞。 initialize方法会在程序首次用该类之前调用，且只调用一次。initialize是“懒加载”的，如果某个类一直都没有使用，就不会执行该类的initialize方法。initialize方法可以安全使用并调用任意类中的任意方法。initialize方法只应该用来设置内部数据，不应该在其中调用其他方法。 在加载阶段，如果类实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。 首次使用某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。 load与initialize 方法都应该实现的精简一点，这样有助于保持应用程序的响应能力，也可以减少引入依赖环的几率。 无法在编译器设定的全局变量，可以放在initialize方法里初始化。 第 50 条：别忘了 NSTimer 会保留其目标对象开发中经常会用到NSTimer，由于定时器NSTimer会保留其目标对象，所以反复执行任务通常会导致应用程序出问题，也就是说很容易造成循环引用。请看以下代码： 12345678910111213141516171819202122232425262728293031323334353637383940#import &lt;Foundation/Foundation.h&gt;@interface NNTimer: NSObject- (void)startPolling;- (void)stopPolling;@end@implementation NNTimer &#123;NSTimer *_pollTimer;&#125;- (id)init &#123;return [super init];&#125;- (void)dealloc &#123;[_pollTimer invalidate];&#125;- (void)stopPolling &#123;[_pollTimer invalidate];_pollTimer = nil;&#125;- (void)startPolling &#123;_pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0target:selfselector:@selector(p_doPoll)userInfo:nilrepeats:YES];&#125;- (void)p_doPoll &#123;// Poll the resource&#125;@end 上面这段代码是存在问题的。如果创建了本类的实例，并调用其startPolling方法，那么会如何呢？创建计时器的时候，由于目标对象是self，所以要保留此实例。然而，因为计时器是用实例变量存放的，所以实例也保留了计时器，于是就产生了保留环。 单从计时器本身入手，你会发现很难解决这个问题，那么如何解决这个问题呢？我们可以通过“块”来解决。虽然计时器当前不直接支持块，但是可以用下面这段代码为其添加此功能：.h文件：12345@interface NSTimer (NNBlocksSupport)+ (NSTimer *)nn_scheduledTimerWithTimeInterval:(NSTimeInterval)intervalblock:(void(^)(void))blockrepeats:(BOOL)repeats;@end .m文件：1234567891011121314151617181920212223#import &quot;NSTimer+NNBlocksSupport.h&quot;@implementation NSTimer (NNBlocksSupport)+ (NSTimer *)nn_scheduledTimerWithTimeInterval:(NSTimeInterval)intervalblock:(void(^)(void))blockrepeats:(BOOL)repeats &#123;return [self scheduledTimerWithTimeInterval:intervaltarget:selfselector:@selector(nn_blockInvoke:)userInfo:[block copy]repeats:repeats];&#125;+ (void)nn_blockInvoke:(NSTimer *)timer &#123;void (^block)(void) = timer.userInfo;if (block) &#123;block();&#125;&#125;@end 结束语：由于个人能力有限，这三篇读书笔记难免有错误或不足之处，还望各位道友能不吝赐教，谢谢。 最后安利一下这本书：PDF版]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《52 个有效方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(2)]]></title>
    <url>%2F2018%2F03%2F19%2FiOS%20%E5%BC%80%E5%8F%91%20-%E3%80%8A52%20%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)%2F</url>
    <content type="text"><![CDATA[文章共分为三篇：第一篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(1)]第二篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(2)]第三篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(3)] 第 3 章：接口与 API 设计第 13 条：用前缀避免命名空间冲突OC没有其他语言那种内置的命名空间机制。因此我们起名时要设法避免潜在的命名冲突，否则很容易重名，引发命名冲突（naming clash）。避免此问题的唯一方法就是变相实现命名空间：为所有名称都加上适当前缀。所选前缀可以是与公司、应用程序或二者皆有关联之名。另外，Apple宣称其保留使用所有“两字母前缀”，所以我们一般还是三个字母开头比较好。 第 14 条：提供“全能初始化方法”能够为对象提供必要信息以便其完成工作的初始化方法叫做“全能初始化方法”。 如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。这当然很好，不过仍然要在其中选定一个作为全能初始化方法，令其它初始化方法都来调用它。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。 NSDate就是一个例子，其初始化方法如下：123456- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date; 在上面几个初始化方法中，initWithTimeIntervalSinceReferenceDate:是全能初始化方法，也就是说，其余的初始化方法都要调用它。只有在全能初始化方法中，才会存储内部数据。 第 15 条：实现 description 方法调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都输出到日志中。不过最常用的做法还是像下面这样： 1NSLog(@&quot;object = %@&quot;, object); 这样直接打印我们的对象它会输出 &lt;Object:0x*****&gt;，这并不是我们想要的，所以当我们重写description的时候才可能满足我们调试的需求。 123- (NSString *)description &#123;return [NSString stringWithFormat:@&quot;%@ : %@, %@&quot;, [self class], self, @&quot;你需要的属性&quot;];&#125; 若想在调试时打印出更详尽的对象描述信息，则应实现 - (NSString *)debugDescription;方法，再与po命令一起使用配合调试。 第 16 条：尽量使用不可变对象这条主要讲的是，尽量使用不可变的对象。简单来说，我们设计出来一个类，其实是不希望别人更改其属性的，因此应该尽量把对外公布出来的属性设置为只读，而且只在确有必要时才将属性对外公布。 第 17 条：使用清晰而协调的命名方式类、方法及变量的命名是 OC 编程的重要环节。这点就不用多说了，具体可以看下官方的命名规则：Coding Guidelines for Cocoa 第 18 条：为私有方法名加前缀这样有助于调试，也很容易让我们将公共方法和私有方法区分开，另外便于修改方法名。但是要注意不要但用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司的。 第 19 条：理解 Objective-C 错误模型当前很多种编程语言都有异常处理机制，OC也不例外。在OC中异常只用于处理严重错误(fatal error)，出现“不那么严重的错误(nonfatal error)”时，OC语言的处理方式是：令方法返回 nil/0，或者使用NSError，以表明有错误发生。 第 20 条：理解 NSCopying 协议在 OC 中，拷贝对象通过copy方法完成，如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法：1- (id)copyWithZone:(NSZone*)zone 当然如果要求返回对象是可变的类型就要用到NSMutableCopying协议，相应方法： 1- (id)mutableCopyWithZone:(NSZone *)zone 在拷贝对象时，需要注意拷贝执行的是深拷贝还是浅拷贝。 深拷贝的意思就是：在拷贝对象自身时，会将对象的底层数据也进行复制。 浅拷贝是只拷贝容器对象本身，而不拷贝其中数据。Foundation 框架中所有的collection 类在默认情况下都执行浅拷贝。 要点： 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。 如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。 第 4 章：协议与分类第 21 条：通过委托与数据源协议进行对象间通信简单来说，这条讲的是使用delegate，protocal进行数据传递。此模式可将数据与业务逻辑解耦。需要注意的是：修饰delegate的属性一定要定义成weak，而非strong，因为两者之间必须为“非拥有关系”。 第 22 条：将类的实现代码分散到便于管理的数个分类之中这条讲的是使用分类。类中经常容易填满各种方法，而这些方法的代码则全部堆在一个巨大的实现文件里。有时这么做是合理的，因为即便通过重构把这个类打散，效果也不会更好。在此情况下，可以通过OC的“分类”机制，将类代码按逻辑划入几个分区中，这对开发与调试都有好处。 第 23 条：总是为第三方类的分类名称加前缀这条也很容易理解，就是给分类名加前缀，比如NSString分类， 12345678@interface NSString (HTTP)@end// 加前缀@interface NSString (ABC_HTTP)@end 给分类加上前缀，易于区分，并且能避免不必要的错误。 第 24 条：勿在分类中声明属性除了 Class-continuation分类，其他分类无法向类中新增实例变量，这样就无法把实现属性所需要的实例变量合成出来，即无法生成实例变量，如下图： 第 25 条：使用 “Class-continuation分类” 隐藏实现细节Class-continuation分类和普通的分类不同，它必须定义在其所接续的那个类的实现文件里。 123456789#import &quot;NNTestClass.h&quot;@interface NNTestClass ()// 写你所需要的私有变量或方法@end@implementation NNTestClass// 实现@end 这条和之前的描述也有点类似，总之就是在说尽量不要在公共接口中暴露太多内容，隐藏其实现细节。 第 26 条：通过协议提供匿名对象 协议可以在某种程度上提供匿名对象，例如id&lt;someProtocal&gt; object。object对象的类型不限，只要能遵从这个协议即可，在这个协议里面定义了这个对象所应该实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能否处理好一些特定的方法，那么就可以使用这种协议匿名对象来完成。 第 5 章：内存管理第 27 条：理解引用计数OC 使用引用计数器来管理内存，每个对象都有个可以递增或递减的计数器。对象创建好之后，其保留计数至少为1，若保留计数为正，则对象继续存活，当保留计数降为0时，对象被销毁。在对象的生命周期中，其余对象通过引用来保留或释放此对象。保留或释放操作分别会递增或递减保留计数。 注意retain,release,autorelease,这三个方法操作计数器。 retain递增保留计数。 release递减保留计数。 autorelease待稍后清理“自动释放池”时，再递减保留计数。 第 28 条：以 ARC 简化引用计数ARC，即自动管理计数器，理解起来很容易。ARC会自动执行retain,release,autorelease等操作，所以直接在ARC中调用这些内存管理方法是非法的。具体来说，ARC不能调用以下方法: retain release autorelease dealloc 在ARC中，变量的内存管理语义可以通过修饰符指明，而原来则需手工执行”保留“及释放操作;(__strong,__weak,一个保留值，一个不保留值)。注意的是ARC只负责管理OC对象的内存。注意：CoreFoundation对象不归ARC管理，必须适时调用CFRetain/CFRelease。 第 29 条：在 dealloc 方法中只释放引用并解除监听不要在delloc方法中调用其它方法，尤其是需要异步执行某些任务又要回调的方法，这样是很危险的行为，很可能异步执行完回调的时候该对象已经被销毁了，crash了。 在delloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的键值观测（KVO）或NSNotificationCenter等通知，不要做其它事情。 123- (void)dealloc &#123;[[NSNotificationCenter defaultCenter] removeObserver:self];&#125; 第 30 条：编写 “异常安全代码” 时留意内存管理问题这条也和上面说过的类似，有两点需要注意： 捕获异常时，一定要注意将try块内所创立的对象清理干净。 123456@try &#123; // 可能会出现崩溃的代码&#125;@catch (NSException *exception) &#123; // 捕获到的异常 exception&#125;@finally &#123; // 结果处理,也可以去掉&#125; 在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 第 31 条：以弱引用避免保留环这个也很容易理解，保留环就是我们常说的循环引用。就是有时候我们需要将某些引用设为weak，避免出现“保留环”。 第 32 条：以“自动释放池块”降低内存峰值合理运用自动释放池，可降低应用程序的内存峰值。 请看下面几行代码：123456NSArray *dataArray = /*****/;NSMutableArray *testArray = [NSMutableArray array];for(NSDictionary *recordDic in dataArray) &#123;TestPerson *person = [[TestPerson alloc] initWithRecord:recordDic];[testArray addObject:person];&#125; 当循环长度无法预估，需要创建很多对象时，上面代码会创造数量无法预估的临时对象，即内存中会出现很多不必要的临时对象，他们本该提早回收的。这时我们可以给这段代码增加一个释放池： 12345678NSArray *dataArray = /*****/;NSMutableArray *testArray = [NSMutableArray array];for(NSDictionary *recordDic in dataArray) &#123;@autoreleasepool &#123;TestPerson *person = [[TestPerson alloc] initWithRecord:recordDic];[testArray addObject:person];&#125;&#125; 这样临时对象就可以及时回收了，有一点需要注意：不要把for循环放到释放池里面，特别是循环长度特别长的时候。 第 33 条：用“僵尸对象”调试内存管理问题 如上图，启动这项调试功能之后，运行期系统在回收对象时，会把它的isa指针指向特殊的僵尸类，而不是真正的回收他们。系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容以及其接收者的消息，然后终止应用程序。 第 34 条：不要使用 retainCountretainCount，对象的保留计数，ARC环境下已经正式废弃，在MRC下还可以正常使用。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《52 个有效方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(1)]]></title>
    <url>%2F2018%2F03%2F13%2FiOS%20%E5%BC%80%E5%8F%91%20-%E3%80%8A52%20%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)%2F</url>
    <content type="text"><![CDATA[《Effective Objective-C 2.0: 编写高质量 iOS 与 OS X 代码的 52 个有效方法》是一本非常经典的 OC 书籍。这本书从语法、接口与 API 设计、内存管理、框架等 7 大方面总结和探讨了 OC 编程中的 52 个特性与陷阱，很值得读。 第一篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(1)]第二篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(2)]第三篇：[iOS 开发 -《Effective Objective-C 2.0:编写高质量 iOS 与 OS X 代码的 52 个有效方法》读书笔记(3)] 文章目录： 第 1 章：熟悉 OC第 2 章：对象、消息、运行期第 3 章：接口与 API 设计第 4 章：协议与分类第 5 章：内存管理第 6 章：块与大中枢派发（block 与 GCD）第 7 章：系统框架 第 1 章：熟悉 OC第 1 条 - 在类的头文件中尽量少引入其他头文件OC 中应尽量避免在头文件中引用其他类，即比如我们有两个类，NNListViewController 以及 NNHomeViewController，应避免在 NNListViewController.h 中引用 NNHomeViewController，如果非要在 NNListViewController.h 中引入 NNHomeViewController，如下面代码： 1234567#import &lt;UIKit/UIKit.h&gt;@interface NNListViewController : UIViewController@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *age;@property (nonatomic, strong) NNHomeViewController *homeVC;@end 这时程序会报错，因为 NNHomeViewController 类并不可见，这时常见的做法是在 NNListViewController.h 中加入下面这行代码 1#import &quot;NNHomeViewController.h&quot; 这种方法可行，但是不够优雅。在编译 NNListViewController 类时，不需要知道 NNHomeViewController 类的全部细节，只需要知道有一个类名叫 NNHomeViewController 就好，所以我们应该这样写： 1@class NNHomeViewController; 这叫做“向前声明”该类。现在 NNListViewController.h 变成了这样：123456789#import &lt;UIKit/UIKit.h&gt;@class NNHomeViewController;@interface NNListViewController : UIViewController@property (nonatomic, copy) NSString *name;@property (nonatomic, copy) NSString *age;@property (nonatomic, strong) NNHomeViewController *homeVC;@end NNListViewController 的实现文件需要引入 NNHomeViewController.h，因为若要使用后者，就必须知道其所有接口细节。于是 NNListViewController.m 就是： 123456#import &quot;NNListViewController.h&quot;#import &quot;NNHomeViewController.h&quot;@implementation NNListViewController@end 利用向前声明这种写法，有两个好处： 减少编译时间。在头文件中使用向前声明，不会引入 NNHomeViewController 中的所有内容，只在确有需要的时候才引入，这样会缩减编译时间。 解决了两个类互相引用的问题。假设 NNHomeViewController 类与 NNListViewController 类互相引用，使用 #import 而非 #include 指令虽然不会造成死循环，但会使两个类里有一个无法被正确编译。这个时候我们使用向前声明，就可以解决这个问题。 第 2 条 - 多用字面量语法，少用与之等价的方法编写 OC 代码总会用到几个类，NSString、NSArray、NSNumber、NSDictionary，从类名上即可看出各自所表达的数据结构。NSString 对象有一种简单的创建方式，叫做“字符串字面量”，其语法如下： 1NSString string = @&quot;Liu Zhong Ning&quot;; 如果不用这种语法，就要以常见的alloc 及 init 方法来分配并初始化 NSString 对象了。同样也能用字面量语法声明 NSArray、NSNumber、NSDictionary 类的实例。使用字面量语法可以缩减代码长度，使其更为易读。 非字面量语法： 1234567891011121314// NSNumberNSNumber *intNumber = [NSNumber numberWithInt:1];NSNumber *floatNumber = [NSNumber numberWithFloat:6.6f];NSNumber *charNumber = [NSNumber numberWithChar:&apos;a&apos;];// NSArrayNSArray *animals = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, nil];// 取下标NSString *dog = [animals objectAtIndex:1];// NSDictionaryNSDictionary *personDic = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Liu Zhong Ning&quot;, @&quot;name&quot;, 25, @&quot;age&quot;, nil];// 访问字典NSString *name = [personDic objectForKey:@&quot;name&quot;]; 字面量语法： 123456789101112131415// NSNumberNSNumber *intNumber = @1;NSNumber *floatNumber = @6.6f;NSNumber *charNumber = @&apos;a&apos;;// NSArrayNSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;];// 取下标NSString *dog = animals[1];// NSDictionaryNSDictionary *personDic = @&#123;@&quot;name&quot; : @&quot;Liu Zhong Ning&quot;,@&quot;age&quot; : @25&#125;;// 访问字典NSString *name = personDic[@&quot;name&quot;]; 注意点：用字面量语法创建数组或字典时，若值中有 nil，则会抛出异常。因此，务必确保值里不包含 nil。 第 3 条 - 多用类型常量，少用 #define 预处理指令 定义常量时，有时会用这种方法： 1#define ANIMATION_DURATION 0.3 用预处理指令也可以达到我们想要的效果，但这样定义出来的常量 没有类型信息；另外，预处理过程会把碰到的所有 ANIMATION_DURATION 换成 0.3，这样的话，假设此指令声明在某头文件，那么 所有引入了这个头文件的代码，其ANIMATION_DURATION 都会被替换。有个办法比用预处理指令来定义常量更好： 1static const NSTimeInterval kAnimationDuration = 0.3; 可以看出，上面方式定义的常量包含类型信息，可知该常量类型为 NSTimeInterval，这种方式能令阅读代码的人更易理解其意图。另外还应注意常量名称：若常量只用在实现文件，则在前面加字母 k；若常量在类之外可见，则通常以类名为前缀。 变量一定要同时用 static 与 const 来声明。如果试图修改由 const 修饰符所声明的变量，那么编译器就会报错。而 static 修饰符意味着该变量仅在定义此变量的实现文件中可见。如果不加 static，则编译器会为它创建一个“外部符号”，此时若另一个类中也声明了同名变量，那么编译器就会抛出一条错误消息。 要点： 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。 在实现文件中使用 static const 定义“只在编译单元内可见的常量”。由于此类常量不再全局符号表中，所以无须为其名称加前缀。 第 4 条 - 用枚举表示状态、选项、状态码 枚举是一种常量命名方式。当一个对象如果有多种状态时，就可以定义为一个枚举集。 比如UITableView 中的 UITableViewStyle 就是一个枚举： 1234typedef NS_ENUM(NSInteger, UITableViewStyle) &#123;UITableViewStylePlain, // regular table viewUITableViewStyleGrouped // preferences style table view&#125;; 由于每种状态都用一个便于理解的值来表示，所以这样写出来的代码更易读懂。编译器会为枚举分配一个独有的编号，从 0 开始，每个枚举递增 1。 在 switch 中使用枚举： 12345678910111213141516171819202122232425262728293031// 定义typedef enum : NSUInteger &#123;NNAccountStateInitial = 0, // 初始NNAccountStateWaitReviewed, // 待审核NNAccountStatePassed, // 已通过NNAccountStateNoPassed, // 未通过NNAccountStateDeactivated, // 停用NNAccountStateFreeze, // 冻结&#125; NNAccountState;// 使用switch (self.accountState) &#123;case NNAccountStateInitial:break;case NNAccountStateWaitReviewed:break;case NNAccountStatePassed:break;case NNAccountStateNoPassed:break;case NNAccountStateDeactivated:break;case NNAccountStateFreeze:break;&#125; 要点： 应该用枚举表示状态，给这些值起个易懂的名字。 在处理枚举类型的 switch 语句中，不要实现 default 分支，这样，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有的枚举。 第 2 章：对象、消息、运行期第 5 条 - 在对象内部尽量直接访问实例变量请看下边这个类。 .h 文件1234567891011#import &lt;UIKit/UIKit.h&gt;@interface NNListViewController : UIViewController@property (nonatomic, copy) NSString *lastName;@property (nonatomic, copy) NSString *firstName;- (NSString *)fullName;- (void)setFullName:(NSString *)fullName;@end .m 文件1234567891011121314151617@implementation NNListViewController- (void)viewDidLoad &#123;[super viewDidLoad];&#125;- (NSString *)fullName &#123;return [NSString stringWithFormat:@&quot;%@ %@&quot;, self.firstName, self.lastName];&#125;- (void)setFullName:(NSString *)fullName &#123;NSArray *compoents = [fullName componentsSeparatedByString:@&quot; &quot;];self.firstName = [compoents objectAtIndex:0];self.firstName = [compoents objectAtIndex:1];&#125;@end 在 fullName 的获取方法与设置方法中，我们使用点语法，通过存取方法来访问相关的实例变量。现在假设重写这两个方法，不经由存取方法，而是直接访问实例变量： 123456789- (NSString *)fullName &#123;return [NSString stringWithFormat:@&quot;%@ %@&quot;, _firstName, _lastName];&#125;- (void)setFullName:(NSString *)fullName &#123;NSArray *compoents = [fullName componentsSeparatedByString:@&quot; &quot;];_firstName = [compoents objectAtIndex:0];_firstName = [compoents objectAtIndex:1];&#125; 这两种写法有几个区别： 由于不经过 OC 方法派发步骤，所以直接访问实例变量的速度当然比较快，在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。 直接访问实例变量不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。 如果直接访问实例变量，那么不会触发“键值观测”通知，这样做是否会产生问题，还取决于具体的对象行为。 通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”或“设置方法”中新增“断点”，监控该属性的调用者及其访问时机。 第 6 条 - 理解“对象等同性”这一概念根据“等同性”来比较对象是一个非常有用的功能，请看下面这段代码，并思考会输出什么：123456NSString *foo = @&quot;Badger 123&quot;;NSString *bar = [NSString stringWithFormat:@&quot;Badger %d&quot;, 123];BOOL equalA = (foo == bar);BOOL equalB = [foo isEqual:bar];BOOL equalC = [foo isEqualToString:bar];NSLog(@&quot;equalA = %d, equalB = %d, equalC = %d&quot;, equalA, equalB, equalC); 这里是输出结果：equalA = 0, equalB = 1, equalC = 1 大家可以看到 == 与等同性判断方法之间的差别(== 操作符只是比较了两个指针，而不是指针所指的对象)，NSString 实现了一个自己独有的判断方法，isEqualToString。调用该方法比调用 isEqual 方法快，后者还要执行额外的步骤，因此它不知道受测对象的类型。 第 7 条 - 以“类族模式”隐藏实现细节“类族”是一种很有用的模式，可以隐藏“抽象基类”背后的实现细节。OC 的系统框架中普遍使用此模式。比如创建 UIButton 时需要调用下面这个方法：1+ (instancetype)buttonWithType:(UIButtonType)buttonType; 该方法所返回的对象，其类型取决于传入的按钮类型，然而，不管返回什么类型的对象，它们都继承自同一个基类：UIButton。这么做的意义在于：UIButton 类的使用者无须关心创建出来的按钮具体属于哪个子类，也不用考虑按钮的绘制方式等实现细节。 举例创建类族 .h 文件12345678910111213141516#import &lt;UIKit/UIKit.h&gt;typedef enum : NSUInteger &#123;NNAccountStateInitial = 0, // 初始NNAccountStateWaitReviewed, // 待审核NNAccountStatePassed, // 已通过NNAccountStateNoPassed, // 未通过NNAccountStateDeactivated, // 停用NNAccountStateFreeze, // 冻结&#125; NNAccountState;@interface NNHomeViewController : UIViewController+ (NNHomeViewController *)accountWithState:(NNAccountState)state;@end .m 文件12345678910111213141516171819202122232425262728+ (NNHomeViewController *)accountWithState:(NNAccountState)state &#123;switch (state) &#123;case NNAccountStateInitial:// 做操作return [[NNHomeViewController alloc] init];break;case NNAccountStateWaitReviewed:// 做操作return [[NNHomeViewController alloc] init];break;case NNAccountStatePassed:// 做操作return [[NNHomeViewController alloc] init];break;case NNAccountStateNoPassed:// 做操作return [[NNHomeViewController alloc] init];break;case NNAccountStateDeactivated:// 做操作return [[NNHomeViewController alloc] init];break;case NNAccountStateFreeze:// 做操作return [[NNHomeViewController alloc] init];break;&#125;&#125; Cocoa 里的类族系统框架中有许多类族。大部分collection 类都是类族，例如 NSArray 与其可变版本 NSMutableArray。这样看来，实际上有两个抽象基类，一个用于不可变数组，一个用于可变数组。尽管具备公共接口的类有两个，但仍然可以合起来算作一个类族。不可变的类定义了对所有数组都通用的方法，而可变的类则定义了那些只适用于可变数组的方法。两个类共属于一类族，这意味着二者在实现各自类型的数组时可以共用实现代码，此外，还能够把可变数组复制为不可变数组，反之亦然。 请看下面这句代码: 12345id maybeAnArray;// 可以对 maybeAnArray 赋任何值if ([maybeAnArray class] == [NSArray class]) &#123; // 判断永远不会为真// 不会执行&#125; 解析代码：NSArray 是个类族，[maybeAnArray class] 所返回的绝不可能是 NSArray 本身，因为由 NSArray 的初始化方法所返回的那个实例其类型是隐藏在类族公共接口后面的某个内部类型。不过仍然有办法可以判断出某个实例所属的类是否位于类族之中。若想判断某对象是否位于类族中，不要直接检测两个类对象是否相同，而应该采用下列代码：12345id maybeAnArray;// 对 maybeAnArray 赋任何值if ([maybeAnArray isKindOfClass:[NSArray class]]) &#123;// 会执行&#125; 第 8 条：在既有类中使用关联对象存放自定义数据在 OC 中可以通过 Category 给一个现有的类添加属性，但却不能添加实例变量，这似乎成为了 OC 的一个短板。值得庆幸的是，OC 中有一项强大的特性可以解决此问题，这就是关联对象（Associated Object）。 看下这几个方法： 123456789// 需要导入头文件#import &lt;objc/runtime.h&gt;// 根据给定的键和策略为某对象设置关联对象值OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);// 根据给定的键从某对象获取相应的关联对象值OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key);// 移除指定对象的全部关联对象OBJC_EXPORT void objc_removeAssociatedObjects(id object); 解析代码：id object给谁设置关联对象；const void *key关联对象唯一的 key ，获取时会用到的主键；id value关联对象；objc_AssociationPolicy关联策略，关联策略以下几种： 1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object.* The association is not made atomically. */OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied.* The association is not made atomically. */OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object.* The association is made atomically. */OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied.* The association is made atomically. */&#125;; 关联对象有很多细节很多坑需要注意，想了解更多关联对象的童鞋请看这篇文章：Objective-C Associated Objects 的实现原理。 第 9 条：理解 objc_msgSend 的作用在 OC 中，如果向某个对象传递消息，那就会在运行时使用动态绑定（dynamic binding）机制来决定需要调用的方法。但是到了底层具体实现，却是普通的C语言函数实现的。这个实现的函数就是objc_msgSend,该函数定义如下： 1void objc_msgSend(id self, SEL cmd, ...) 第一个参数代表接收者，第二个参数代表选择子（SEL是选择子的类型，选择子即方法名字），后续参数就是消息中的那些参数，其顺序不变。 举个例子: 1id returnValue = [someObject messageName:parameter]; 代码解析：objc_msgSend 函数会依据接收者与选择子的类型来调用适当的方法。函数首先会在接收者所属的类中搜寻其方法列表，如果能找到这个跟选择子名称相同的方法，就跳转至其实现代码。若是当前类没找到，那就沿着继承体系向上查找，等找到合适方法之后再跳转 ，如果最终还是找不到，那就进入消息转发的流程去进行处理了。 第 10 条：理解消息转发机制当对象接收到无法解读的消息后，就会启动“消息转发”（message forwarding）机制，我们可以通过代码在消息转发的过程中告诉对象应该如何处理未知的消息，系统默认是抛出异常，控制台给出提示代码如下： 1unrecognized selector sent to instance 0x7f8c8a70a380 消息转发机制所讲的就是在抛出异常之前也就是消息转发过程中经过的一些步骤。 消息转发机制分为两个阶段： 第一阶段先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子”（unknown selector），这叫做“动态方法解析”（dynamic method resolution）。 第二阶段涉及“完整的消息转发机制”（full forwarding mechanism）。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为两小步。 首先，请接收者看看有没有其他对象能处理这条消息。 若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。若没有“备援的接收者”（replacement receiver），则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到 NSInvocation 对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。 消息转发全流程： 第 11 条：用“方法调配技术”调试“黑盒方法”这条讲的主要内容就是方法调配( Method Swizzling)，通过运行时用另外一种方法实现来替换掉原有的方法实现，往往被应用在向原有实现中添加新功能，打印信息等。 如何互换两个方法实现？具体主要用下面两个方法 12class_getInstanceMethod(Class _Nullable cls, SEL _Nonnull name)method_exchangeImplementations(Method _Nonnull m1, Method _Nonnull m2) 首先我们写一个分类，比如为NSString写一个“分类”（category）： 123456789101112131415161718#import &quot;NSString+extension.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSString (extension)+ (void)load &#123;Method oldMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));Method newMethod = class_getInstanceMethod([NSString class], @selector(new_lowercaseString));method_exchangeImplementations(oldMethod, newMethod);&#125;- (NSString *)new_lowercaseString &#123;NSString *lowerString = [self new_myLowercaseString];NSLog(@&quot;%@ - %@&quot;, self, lowerString);return lowerString;&#125;@end 解析代码：+ (void)load中会调换lowercaseString方法与new_lowercaseString方法；在方法- (NSString *)new_lowercaseString中，[self new_myLowercaseString]，我们调用new_myLowercaseString方法，此时不会引起死循环，因为这个方法是与lowercaseString方法调换的。 此时我们在NSString实例中调用lowercaseString方法： 123456- (void)viewDidLoad &#123;[super viewDidLoad];NSString *string = @&quot;Talk is cheap, Show me the code.&quot;;NSString *lowercaseString = [string lowercaseString];NSLog(@&quot;%@&quot;, lowercaseString);&#125; 打印效果图如下： 通过此方案，开发者可以为那些“完全不知道其具体实现的”（completely opaque，“完全不透明的”）黑盒方法增加日志记录功能，这非常有助于程序调试。然而，此做法只在调试程序时有用。很少有人在调试程序之外的场合用上述“方法调配技术”来永久改动某个类的功能。不能仅仅因为OC语言里有这个特性就一定要用它。若是滥用，反而会令代码变得不易读懂且难于维护。 第 12 条：理解“类对象”的用意类是一个对象，是Class 类型的对象，简称“类对象”。 1typedef struct objc_class *Class; 类型查询方法： 可以用类型信息查询方法来检视类继承体系。“isMemberOfClass:”能够判断出对象是否为某个特定类的实例，而“isKindOfClass:”则能够判断出对象是否为某类或其派生类的实例。例如： 12345NSMutableDictionary *dict = [NSMutableDictionary new];[dict isMemberOfClass:[NSDictionary class]]; ///&lt; NO[dict isMemberOfClass:[NSMutableDictionary class]]; ///&lt; YES[dict isKindOfClass:[NSDictionary class]]; ///&lt; YES[dict isKindOfClass:[NSArray class]]; ///&lt; NO 比较类对象是否等同的办法来判断，使用==操作符，而不要使用比较OC对象时常用的“isEqual:”方法。原因在于，类对象是“单例”（singleton），在应用程序范围内，每个类的Class仅有一个实例。 要点： 每个实例都有一个指向Class 对象的指针，用以表明其类型，而这些 Class对象则构成了类的继承体系。 如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>《52 个有效方法》</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法-几种排序算法 OC 版]]></title>
    <url>%2F2017%2F11%2F29%2F%E7%AE%97%E6%B3%95-%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20OC%20%E7%89%88%2F</url>
    <content type="text"><![CDATA[如果你交给某人一个程序，你将“折磨”他一整天；如果你教某人如何编写程序，你将“折磨”他一辈子。——《大话数据结构》 这阵子抽空看了一些算法与数据结构相关的东西，不得不说算法数据结构这些思想真的是博大精深，作为 iOS 开发人员，为什么要学习算法？说实话很多开发人员可能不会算法，但照样能做 App，有位大家都熟悉的大神在几个月前写了篇文章，我也是无意间读到的，搞 iOS 的学算法有意义吗？，大家有兴趣的话可以去读读。 这两天看了八大排序算法，并试着用 OC 语言写了几种，给大家分享下！ 算法一：冒泡排序个人觉得冒泡排序是最简单的排序了 12345678910111213141516#pragma mark - 冒泡排序+ (void)bubbleSort:(NSMutableArray *)mutableArray &#123;if(mutableArray == nil || mutableArray.count == 0)return;NSLog(@&quot;冒泡排序之前: %@&quot;, mutableArray);for (NSInteger i = 0; i &lt; mutableArray.count; i++) &#123;for (NSInteger j = 0; j &lt; mutableArray.count - i - 1; j++) &#123;if ([mutableArray[j + 1] floatValue] &lt; [mutableArray[j] floatValue]) &#123;CGFloat tempFloat = [mutableArray[j] floatValue];mutableArray[j] = mutableArray[j + 1];mutableArray[j + 1] = [NSNumber numberWithFloat:tempFloat];&#125;&#125;&#125;NSLog(@&quot;冒泡排序之后: %@&quot;, mutableArray);&#125; 算法步骤：1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。3）针对所有的元素重复以上的步骤，除了最后一个。4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 算法二：直接插入排序1234567891011121314#pragma mark - 直接插入排序+ (void)insertSort:(NSMutableArray *)mutableArray &#123;if(mutableArray == nil || mutableArray.count == 0)return;NSLog(@&quot;直接插入排序之前: %@&quot;, mutableArray);for (NSInteger i = 0; i &lt; mutableArray.count; i++) &#123;CGFloat tempFloat = [mutableArray[i] floatValue];for (NSInteger j = i - 1; j &gt;= 0 &amp;&amp; tempFloat &lt; [mutableArray[j] floatValue]; j--) &#123;mutableArray[j + 1] = mutableArray[j];mutableArray[j] = [NSNumber numberWithFloat:tempFloat];&#125;&#125;NSLog(@&quot;直接插入排序之后: %@&quot;, mutableArray);&#125; 算法步骤：1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 算法三：选择排序12345678910111213141516#pragma mark - 选择排序+ (void)chooseSort:(NSMutableArray *)mutableArray &#123;if(mutableArray == nil || mutableArray.count == 0)return;NSLog(@&quot;选择排序之前: %@&quot;, mutableArray);for (NSInteger i = 0; i &lt; mutableArray.count; i++) &#123;for (NSInteger j = i + 1; j &lt; mutableArray.count; j++) &#123;if ([mutableArray[i] floatValue] &gt; [mutableArray[j] floatValue]) &#123;CGFloat tempFloat = [mutableArray[i] floatValue];mutableArray[i] = mutableArray[j];mutableArray[j] = [NSNumber numberWithFloat:tempFloat];&#125;&#125;&#125;NSLog(@&quot;选择排序之后: %@&quot;, mutableArray);&#125; 算法步骤：1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。3）重复第二步，直到所有元素均排序完毕。 算法四：折半插入排序1234567891011121314151617181920212223242526#pragma mark - 折半插入排序+ (void)binaryInsertSort:(NSMutableArray *)mutableArray &#123;if(mutableArray == nil || mutableArray.count == 0)return;NSLog(@&quot;折半插入排序之前: %@&quot;, mutableArray);for(NSInteger i = 1 ; i &lt; mutableArray.count ; i++) &#123;CGFloat tempFloat = [[mutableArray objectAtIndex:i] floatValue];NSInteger left = 0;NSInteger right = i - 1;while (left &lt;= right) &#123;CGFloat middle = (left + right) / 2;if(tempFloat &lt; [[mutableArray objectAtIndex:middle] floatValue])&#123;right = middle - 1;&#125; else &#123;left = middle + 1;&#125;&#125;for(NSInteger j = i ; j &gt; left; j--) &#123;[mutableArray replaceObjectAtIndex:j withObject:[mutableArray objectAtIndex:j - 1]];&#125;[mutableArray replaceObjectAtIndex:left withObject:[NSNumber numberWithFloat:tempFloat]];&#125;NSLog(@&quot;折半插入排序之后: %@&quot;, mutableArray);&#125; 折半插入排序是对插入排序算法的一种改进，排序算法过程，就是不断的依次将元素插入前面已排好序的序列中。 算法五：希尔排序1234567891011121314151617181920#pragma mark - 希尔排序+ (void)shellSort:(NSMutableArray *)mutableArray &#123;if(mutableArray == nil || mutableArray.count == 0)return;NSLog(@&quot;希尔排序之前: %@&quot;, mutableArray);NSInteger shellValue = mutableArray.count / 2;while (shellValue &gt;= 1) &#123;for(NSInteger i = shellValue; i &lt; mutableArray.count; i++) &#123;CGFloat tempFloat = [[mutableArray objectAtIndex:i] floatValue];NSInteger j = i;while (j &gt;= shellValue &amp;&amp; tempFloat &lt; [[mutableArray objectAtIndex:(j - shellValue)] floatValue]) &#123;[mutableArray replaceObjectAtIndex:j withObject:[mutableArray objectAtIndex:j - shellValue]];j -= shellValue;&#125;[mutableArray replaceObjectAtIndex:j withObject:[NSNumber numberWithFloat:tempFloat]];&#125;shellValue = shellValue / 2;&#125;NSLog(@&quot;希尔排序之后: %@&quot;, mutableArray);&#125; 算法步骤：1）选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；2）按增量序列个数k，对序列进行k 趟排序；3）每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 排序算法就先总结到这里，需要看代码打印效果的童鞋可以到这里下载代码：代码传送门 另外分享一篇很不错的博文，八大排序算法，下面是各种排序算法的时间复杂度空间复杂度以及稳定性的展示图表：]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色]]></title>
    <url>%2F2017%2F11%2F18%2F%E7%94%A8%20RunTime%20%E4%B8%BA%20UITextView%20%E8%AE%BE%E7%BD%AE%E5%8D%A0%E4%BD%8D%E6%96%87%E6%9C%AC%E5%B9%B6%E5%AE%9E%E6%97%B6%E6%94%B9%E5%8F%98%E6%96%87%E6%9C%AC%E6%A1%86%E5%8D%A0%E4%BD%8D%E6%96%87%E6%9C%AC%E7%9A%84%E9%A2%9C%E8%89%B2%2F</url>
    <content type="text"><![CDATA[UITextView 实现占位文本的方式有很多种，网上一搜一大把，，这里只介绍 最简单 的一种，如标题所述：用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色。 对 RunTime 不太了解的童鞋可以简单看下这篇文章：iOS开发之 - Runtime，懒得点击鼠标的话我这里也简单的说下，Runtime 简称运行时，是苹果官方的一套比较底层的纯 C 语言 API, 用它可以做很多底层操作（比如访问隐藏的成员变量和方法）。 OK，足够了，接下来我们就抓紧时间来看看如何用 RunTime 为 UITextView 设置占位文本并实时改变文本框占位文本的颜色。。。 首先我们利用 RunTime 获取一下 UITextView 中一些隐藏的成员变量 123456789101112131415161718- (void)viewDidLoad &#123;[super viewDidLoad];// 获取 UITextView 中所有的成员变量unsigned int count = 0;Ivar *ivars = class_copyIvarList([UITextView class], &amp;count);for (int i = 0; i &lt; count; i ++) &#123;Ivar ivar = ivars[i];// ivar_getName(ivar) 意思是获取成员变量名字，如果想获得成员变量的类型用这个 ivar_getTypeEncoding(ivar)const char *name = ivar_getName(ivar);NSString *objcName = [NSString stringWithUTF8String:name];NSLog(@&quot; %d %@ &quot;, i, objcName);&#125;// 释放free(ivars);&#125; 打印结果如下（这里直接放截图） 从上面的截图中我们可以看出，打印的结果里有一个 placeHolderLabel 的私有变量，即 UITextView 类内部有一个名为“_placeHolderLabel”的私有成员变量。那么就简单多了，我们现在就对这个私有变量进行操作。具体的步骤如下： 123456789101112131415161718- (void)setupTextView &#123;_textView = [[UITextView alloc] initWithFrame:CGRectMake(0, 50, [UIScreen mainScreen].bounds.size.width, 200)];_textView.delegate = self;_textView.tintColor = [UIColor whiteColor];_textView.font = [UIFont systemFontOfSize:15.f];_textView.backgroundColor =[UIColor grayColor];[self.view addSubview:_textView];UILabel *placeholderLabel = [[UILabel alloc] init];placeholderLabel.text = @&quot;请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容&quot;;placeholderLabel.font = [UIFont systemFontOfSize:15.f];placeholderLabel.textColor = [UIColor whiteColor];placeholderLabel.numberOfLines = 0;[placeholderLabel sizeToFit];[_textView addSubview:placeholderLabel];[_textView setValue:placeholderLabel forKey:@&quot;_placeholderLabel&quot;];&#125; 上面代码做的事情，无非是创建一个 UITextView 和一个 UILabel 控件，然后通过键值对的原理给 UITextView 中的 _placeholderLabel 这一属性赋值，，，就不详细注释了，重要的是这种思想。。。只需上面这段代码，我们就已经完成了利用 RunTime 为 UITextView 设置占位文本。效果图如下，比较丑但很实用😂： 接下来我们开始实时改变文本框占位文本的颜色。举个栗子：当我们开始输入时占位文本是白色，结束输入时占位文本是灰色。那我们在哪里设置比较好呢？我在 UITextViewDelegate 中找到了两个方法，可以解决我们的需求 12- (BOOL)textViewShouldBeginEditing:(UITextView *)textView;- (BOOL)textViewShouldEndEditing:(UITextView *)textView; 看名字就能猜到这俩方法是干嘛的了，这里不再多说，，，我们需要在这两个方法里进行一些操作，先贴代码。 12345678910111213141516171819#pragma mark - UITextViewDelegate#pragma mark - 开始编辑 UITextView- (BOOL)textViewShouldBeginEditing:(UITextView *)textView &#123;// 设置高亮时，占位文字颜色为白色[_textView setValue:[UIColor whiteColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];// 设置光标颜色为白色_textView.tintColor = [UIColor whiteColor];return YES;&#125;#pragma mark - 结束编辑 UITextView- (BOOL)textViewShouldEndEditing:(UITextView *)textView &#123;// 设置非高亮状态下，占位文字颜色为 lightGrayColor[_textView setValue:[UIColor lightGrayColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];// 设置光标颜色为 lightGrayColor_textView.tintColor = [UIColor lightGrayColor];return YES;&#125; 和上文设置占位文本的思想一样，这里也是 根据键值对的原理给 _placeholderLabel.textColor 赋值，开始编辑时设置为白色，结束编辑时设置为 lightGrayColor，具体请看代码中的注释。 到这里实时改变文本框占位文本的颜色也搞定了，是不是觉得很简单，先看下效果图（比较丑但很使用😂），文章结尾我会再次贴出完整的代码。。。自己以后看着方便，也可以帮助有需要的道友少走弯路，，不过文章如果有需要改正或改进的地方，还希望各位同行能多多指点。 效果图 在需要 UITextView 的页面进行设置，NNViewController.h 中没有相关操作，直接在NNViewController.m 中进行设置即可，当然如果项目中用到 UITextView 这个类比较多的话，你也可以简单封装一下，以便多次利用。。。以下是全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#import &quot;NNViewController.h&quot;#import &lt;objc/runtime.h&gt;@interface NNViewController ()&lt;UITextViewDelegate&gt; &#123;UITextView *_textView;&#125;@end@implementation NNViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 获取 UITextView 中所有的成员变量unsigned int count = 0;Ivar *ivars = class_copyIvarList([UITextView class], &amp;count);for (int i = 0; i &lt; count; i ++) &#123;Ivar ivar = ivars[i];// ivar_getName(ivar) 意思是获取成员变量名字，如果想获得成员变量的类型用这个 ivar_getTypeEncoding(ivar)const char *name = ivar_getName(ivar);NSString *objcName = [NSString stringWithUTF8String:name];NSLog(@&quot; %d %@ &quot;, i, objcName);&#125;// 释放free(ivars);[self setupTextView];&#125;- (void)setupTextView &#123;_textView = [[UITextView alloc] initWithFrame:CGRectMake(0, 50, [UIScreen mainScreen].bounds.size.width, 200)];_textView.delegate = self;_textView.tintColor = [UIColor lightGrayColor];_textView.font = [UIFont systemFontOfSize:15.f];_textView.backgroundColor =[UIColor grayColor];[self.view addSubview:_textView];UILabel *placeholderLabel = [[UILabel alloc] init];placeholderLabel.text = @&quot;请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容请输入内容&quot;;placeholderLabel.font = [UIFont systemFontOfSize:15.f];placeholderLabel.textColor = [UIColor lightGrayColor];placeholderLabel.numberOfLines = 0;[placeholderLabel sizeToFit];[_textView addSubview:placeholderLabel];[_textView setValue:placeholderLabel forKey:@&quot;_placeholderLabel&quot;];&#125;#pragma mark - UITextViewDelegate#pragma mark - 开始编辑 UITextView- (BOOL)textViewShouldBeginEditing:(UITextView *)textView &#123;// 设置高亮时，占位文字颜色为白色[_textView setValue:[UIColor whiteColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];// 设置光标颜色为白色_textView.tintColor = [UIColor whiteColor];return YES;&#125;#pragma mark - 结束编辑 UITextView- (BOOL)textViewShouldEndEditing:(UITextView *)textView &#123;// 设置非高亮状态下，占位文字颜色为 lightGrayColor[_textView setValue:[UIColor lightGrayColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];// 设置光标颜色为 lightGrayColor_textView.tintColor = [UIColor lightGrayColor];return YES;&#125;#pragma mark - 点击空白页面时收回键盘- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;[self.view endEditing:YES];&#125;@end]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 获取设备的各种信息]]></title>
    <url>%2F2017%2F10%2F21%2FiOS%20%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E7%9A%84%E5%90%84%E7%A7%8D%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[iOS 获取设备的各种信息一、目录结构: 获取屏幕宽度与高度 获取设备版本号 获取iPhone名称 获取app版本号 获取电池电量 获取当前系统名称 获取当前系统版本号 获取通用的唯一识别码UUID 获取当前设备IP 获取总内存大小 获取当前可用内存 获取精准电池电量 获取电池当前的状态（共有4种状态） 获取设备当前的语言 二、具体内容1. 获取屏幕宽度与高度123456789/// 屏幕宽度+ (CGFloat)getDeviceScreenWidth &#123;return [UIScreen mainScreen].bounds.size.width;&#125;/// 屏幕高度+ (CGFloat)getDeviceScreenHeight &#123;return [UIScreen mainScreen].bounds.size.height;&#125; [UIScreen mainScreen].bounds.size.width用的很普遍，一般来说定义成宏更好，然后根据屏幕宽高进行尺寸的适配。 2. 获取设备版本号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465+ (NSString *)getDeviceName &#123;// 需要#import &quot;sys/utsname.h&quot;struct utsname systemInfo;uname(&amp;systemInfo);NSString *deviceString = [NSString stringWithCString:systemInfo.machine encoding:NSUTF8StringEncoding];if ([deviceString isEqualToString:@&quot;iPhone3,1&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,2&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone3,3&quot;]) return @&quot;iPhone 4&quot;;if ([deviceString isEqualToString:@&quot;iPhone4,1&quot;]) return @&quot;iPhone 4S&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,1&quot;]) return @&quot;iPhone 5&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,2&quot;]) return @&quot;iPhone 5 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,3&quot;]) return @&quot;iPhone 5c (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone5,4&quot;]) return @&quot;iPhone 5c (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,1&quot;]) return @&quot;iPhone 5s (GSM)&quot;;if ([deviceString isEqualToString:@&quot;iPhone6,2&quot;]) return @&quot;iPhone 5s (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,1&quot;]) return @&quot;iPhone 6 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone7,2&quot;]) return @&quot;iPhone 6&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,1&quot;]) return @&quot;iPhone 6s&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,2&quot;]) return @&quot;iPhone 6s Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone8,4&quot;]) return @&quot;iPhone SE&quot;;if ([deviceString isEqualToString:@&quot;iPod1,1&quot;]) return @&quot;iPod Touch 1G&quot;;if ([deviceString isEqualToString:@&quot;iPod2,1&quot;]) return @&quot;iPod Touch 2G&quot;;if ([deviceString isEqualToString:@&quot;iPod3,1&quot;]) return @&quot;iPod Touch 3G&quot;;if ([deviceString isEqualToString:@&quot;iPod4,1&quot;]) return @&quot;iPod Touch 4G&quot;;if ([deviceString isEqualToString:@&quot;iPod5,1&quot;]) return @&quot;iPod Touch (5 Gen)&quot;;if ([deviceString isEqualToString:@&quot;iPad1,1&quot;]) return @&quot;iPad&quot;;if ([deviceString isEqualToString:@&quot;iPad1,2&quot;]) return @&quot;iPad 3G&quot;;if ([deviceString isEqualToString:@&quot;iPad2,1&quot;]) return @&quot;iPad 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,2&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,3&quot;]) return @&quot;iPad 2 (CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,4&quot;]) return @&quot;iPad 2&quot;;if ([deviceString isEqualToString:@&quot;iPad2,5&quot;]) return @&quot;iPad Mini (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad2,6&quot;]) return @&quot;iPad Mini&quot;;if ([deviceString isEqualToString:@&quot;iPad2,7&quot;]) return @&quot;iPad Mini (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,1&quot;]) return @&quot;iPad 3 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,2&quot;]) return @&quot;iPad 3 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,3&quot;]) return @&quot;iPad 3&quot;;if ([deviceString isEqualToString:@&quot;iPad3,4&quot;]) return @&quot;iPad 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad3,5&quot;]) return @&quot;iPad 4&quot;;if ([deviceString isEqualToString:@&quot;iPad3,6&quot;]) return @&quot;iPad 4 (GSM+CDMA)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,1&quot;]) return @&quot;iPad Air (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,2&quot;]) return @&quot;iPad Air (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,4&quot;]) return @&quot;iPad Mini 2 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,5&quot;]) return @&quot;iPad Mini 2 (Cellular)&quot;;if ([deviceString isEqualToString:@&quot;iPad4,6&quot;]) return @&quot;iPad Mini 2&quot;;if ([deviceString isEqualToString:@&quot;iPad4,7&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,8&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad4,9&quot;]) return @&quot;iPad Mini 3&quot;;if ([deviceString isEqualToString:@&quot;iPad5,1&quot;]) return @&quot;iPad Mini 4 (WiFi)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,2&quot;]) return @&quot;iPad Mini 4 (LTE)&quot;;if ([deviceString isEqualToString:@&quot;iPad5,3&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad5,4&quot;]) return @&quot;iPad Air 2&quot;;if ([deviceString isEqualToString:@&quot;iPad6,3&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,4&quot;]) return @&quot;iPad Pro 9.7&quot;;if ([deviceString isEqualToString:@&quot;iPad6,7&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;iPad6,8&quot;]) return @&quot;iPad Pro 12.9&quot;;if ([deviceString isEqualToString:@&quot;i386&quot;]) return @&quot;Simulator&quot;;if ([deviceString isEqualToString:@&quot;x86_64&quot;]) return @&quot;Simulator&quot;;return deviceString;&#125; 3. 获取iPhone名称1234/// 获取iPhone名称+ (NSString *)getiPhoneName &#123;return [UIDevice currentDevice].name;&#125; 获取的是你 iPhone 的名字。 4. 获取app版本号1234/// 获取app版本号+ (NSString *)getAPPVerion &#123;return [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;];&#125; 5. 获取电池电量1234/// 获取电池电量+ (CGFloat)getBatteryLevel &#123;return [UIDevice currentDevice].batteryLevel;&#125; 这个方法获取电池电量不是很精确，下边会介绍一个获取精确电池电量的。 6. 获取当前系统名称1234/// 当前系统名称+ (NSString *)getSystemName &#123;return [UIDevice currentDevice].systemName;&#125; 7. 获取当前系统版本号1234/// 当前系统版本号+ (NSString *)getSystemVersion &#123;return [UIDevice currentDevice].systemVersion;&#125; 8. 获取通用的唯一识别码UUID1234/// 通用唯一识别码UUID+ (NSString *)getUUID &#123;return [[UIDevice currentDevice] identifierForVendor].UUIDString;&#125; 9. 获取当前设备IP123456789101112131415161718192021222324252627// 获取当前设备IP+ (NSString *)getDeviceIPAdress &#123;NSString *address = @&quot;an error occurred when obtaining ip address&quot;;struct ifaddrs *interfaces = NULL;struct ifaddrs *temp_addr = NULL;int success = 0;success = getifaddrs(&amp;interfaces);if (success == 0) &#123; // 0 表示获取成功temp_addr = interfaces;while (temp_addr != NULL) &#123;if( temp_addr-&gt;ifa_addr-&gt;sa_family == AF_INET) &#123;// Check if interface is en0 which is the wifi connection on the iPhoneif ([[NSString stringWithUTF8String:temp_addr-&gt;ifa_name] isEqualToString:@&quot;en0&quot;]) &#123;// Get NSString from C Stringaddress = [NSString stringWithUTF8String:inet_ntoa(((struct sockaddr_in *)temp_addr-&gt;ifa_addr)-&gt;sin_addr)];&#125;&#125;temp_addr = temp_addr-&gt;ifa_next;&#125;&#125;freeifaddrs(interfaces);return address;&#125; 10. 获取总内存大小1234/// 获取总内存大小+ (long long)getTotalMemorySize &#123;return [NSProcessInfo processInfo].physicalMemory;&#125; 11. 获取当前可用内存123456789101112/// 获取当前可用内存+ (long long)getAvailableMemorySize &#123;vm_statistics_data_t vmStats;mach_msg_type_number_t infoCount = HOST_VM_INFO_COUNT;kern_return_t kernReturn = host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&amp;vmStats, &amp;infoCount);if (kernReturn != KERN_SUCCESS)&#123;return NSNotFound;&#125;return ((vm_page_size * vmStats.free_count + vm_page_size * vmStats.inactive_count));&#125; 12. 获取精准电池电量12345678910111213141516171819202122232425262728/// 获取精准电池电量+ (CGFloat)getCurrentBatteryLevel &#123;UIApplication *app = [UIApplication sharedApplication];if (app.applicationState == UIApplicationStateActive||app.applicationState==UIApplicationStateInactive) &#123;Ivar ivar= class_getInstanceVariable([app class],&quot;_statusBar&quot;);id status = object_getIvar(app, ivar);for (id aview in [status subviews]) &#123;int batteryLevel = 0;for (id bview in [aview subviews]) &#123;if ([NSStringFromClass([bview class]) caseInsensitiveCompare:@&quot;UIStatusBarBatteryItemView&quot;] == NSOrderedSame&amp;&amp;[[[UIDevice currentDevice] systemVersion] floatValue] &gt;=6.0) &#123;Ivar ivar= class_getInstanceVariable([bview class],&quot;_capacity&quot;);if(ivar) &#123;batteryLevel = ((int (*)(id, Ivar))object_getIvar)(bview, ivar);if (batteryLevel &gt; 0 &amp;&amp; batteryLevel &lt;= 100) &#123;return batteryLevel;&#125; else &#123;return 0;&#125;&#125;&#125;&#125;&#125;&#125;return 0;&#125; 上面这个方法是通过 runtime 获取电池电量控件类私有变量的值，较为精确。 13. 获取电池当前的状态（共有4种状态）1234567891011121314/// 获取电池当前的状态，共有4种状态+ (NSString *) getBatteryState &#123;UIDevice *device = [UIDevice currentDevice];if (device.batteryState == UIDeviceBatteryStateUnknown) &#123;return @&quot;UnKnow&quot;;&#125; else if (device.batteryState == UIDeviceBatteryStateUnplugged)&#123;return @&quot;Unplugged&quot;;&#125; else if (device.batteryState == UIDeviceBatteryStateCharging)&#123;return @&quot;Charging&quot;;&#125; else if (device.batteryState == UIDeviceBatteryStateFull)&#123;return @&quot;Full&quot;;&#125;return nil;&#125; 14. 获取设备当前的语言12345/// 获取当前语言+ (NSString *)getDeviceLanguage &#123;NSArray *languageArray = [NSLocale preferredLanguages];return [languageArray objectAtIndex:0];&#125; 提示：上面代码如果直接复制的话有些会报错，这是因为需要导入头文件，详细代码请点击 iOS 获取设备的各种信息。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>获取设备的各种信息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发 - Swift 全面系统的学习（持续更新...）]]></title>
    <url>%2F2017%2F09%2F29%2FiOS%20%E5%BC%80%E5%8F%91%20-%20Swift%20%E5%85%A8%E9%9D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0...%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近项目不算紧，于是就学了学 Swift ，看了一大神写的项目https://github.com/hrscy/DanTang， 很受益，感谢开源！另外自己也写了一些基础代码，分享出来，第一是希望得到同行前辈的指导，第二是希望对需要的朋友有所帮助。 先分享一些学习资料： 学习网站： 苹果官方为开发者提供的 Swift 学习资源: https://developer.apple.com/swift/resources/ 官方的 API Design: https://swift.org/documentation/api-design-guidelines/ 学习书籍： TheSwiftProgrammingLanguage(Swift3): 链接:http://pan.baidu.com/s/1jIopBwi 密码:dqho The Swift Programming Language 中文版: 链接:http://pan.baidu.com/s/1slpxtTj 密码:xay1 其它学习资料 https://github.com/Tim9Liu9/TimLiu-iOS/blob/master/Swift.md#swift https://github.com/ipader/SwiftGuide 练习的 demo 地址： https://github.com/liuzhongning/NNMintFurniture 主要包括以下功能： 多页面滑动视图（分页控制器） 图片轮播 导航栏渐变 瀑布流练习 UIScrollView 练习 照相功能，更换头像 二维码扫描及识别 随机图片验证码封装 圆形输入框封装 第三方库 SnapKit 用法 ………… 练习 demo 的简单介绍，前方高能预警，大量图片请注意手机流量！ 一、多页面滑动视图（分页控制器） 核心代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// MARK: 点击了标签栏func titlesClick(button: UIButton) &#123;selectedButton!.isEnabled = trueselectedButton!.setTitleColor(UIColor.gray, for: .normal)button.isEnabled = falseselectedButton = buttonselectedButton?.setTitleColor(UIColor.red, for: .normal)var offset = contentView!.contentOffsetoffset.x = CGFloat(button.tag) * (contentView?.frame.size.width)!contentView!.setContentOffset(offset, animated: true)&#125;// MARK: 点击了右边搜索框func rightBarButtonClick() &#123;navigationController?.pushViewController(NNSearchController(), animated: true)&#125;// MARK: 点击了箭头func arrowButtonClick(button: UIButton) &#123;UIView.animate(withDuration: 0.25) &#123;button.imageView?.transform = button.imageView!.transform.rotated(by: CGFloat(Double.pi))&#125;&#125;// MARK: - UIScrollViewDelegate 代理// MARK: scrollViewDidEndScrollingAnimationfunc scrollViewDidEndScrollingAnimation(_ scrollView: UIScrollView) &#123;let index = Int(scrollView.contentOffset.x / scrollView.frame.size.width)// 取出子控制器let vc = childViewControllers[index]vc.view.frame.origin.x = scrollView.contentOffset.xvc.view.frame.origin.y = 0// 设置控制器的 view 的 height 值为整个屏幕的高度vc.view.frame.size.height = scrollView.frame.size.heightscrollView.addSubview(vc.view)&#125;// MARK: scrollViewDidEndDeceleratingfunc scrollViewDidEndDecelerating(_ scrollView: UIScrollView) &#123;scrollViewDidEndScrollingAnimation(scrollView)// 当前索引let index = Int(scrollView.contentOffset.x / scrollView.frame.size.width)// 点击 Buttonlet button = titlesView.subviews[index] as! UIButtontitlesClick(button: button)&#125; 二、图片轮播 核心代码： 轮播图的封装12345678// MARK: - 懒加载轮播视图private lazy var shufflingFigureView : NNShufflingFigureView = &#123;let frame = CGRect(x: 0, y: 0, width: NNScreenWidth, height: 180)let imageView = [&quot;shuffling1&quot;, &quot;shuffling2&quot;, &quot;shuffling3&quot;, &quot;shuffling4&quot;]let shufflingFigureView = NNShufflingFigureView(frame: frame, images: imageView as NSArray, autoPlay: true, delay: 3, isFromNet: false)shufflingFigureView.delegate = selfreturn shufflingFigureView&#125;() 通过代理处理图片的点击事件123456// MARK: - 轮播代理方法，处理轮播图的点击事件extension NNItemTableViewController: NNShufflingFigureViewDelegate &#123;func addShufflingFigureView(addShufflingFigureView: NNShufflingFigureView, iconClick index: NSInteger) &#123;print(index)&#125;&#125; 三、导航栏渐变 核心代码 页面滚动时调用12345678910111213141516171819202122232425262728// MARK: - UIScrollViewDelegate 滚动页面时调用extension NNItemTableViewController &#123;override func scrollViewDidScroll(_ scrollView: UIScrollView) &#123;if type == tableViewType.haveHeader &#123;return&#125;currentPostion = scrollView.contentOffset.yif currentPostion &gt; 0 &#123;if currentPostion - lastPosition &gt;= 0 &#123;if topBool &#123;topBool = falsebottomBool = truestopPosition = currentPostion + 64&#125;lastPosition = currentPostionnavigationController?.navigationBar.alpha = 1 - currentPostion / 500&#125; else &#123;if bottomBool &#123;bottomBool = falsetopBool = truestopPosition = currentPostion + 64&#125;lastPosition = currentPostionnavigationController?.navigationBar.alpha = (stopPosition - currentPostion) / 200&#125;&#125;&#125;&#125; 四、瀑布流练习 核心代码 基础设置123456789// 布局let layout = NNItemCollectionViewFlowLayout()// 创建collectionViewlet collectionView = UICollectionView.init(frame: view.bounds, collectionViewLayout: layout)view.addSubview(collectionView)collectionView.dataSource = selfcollectionView.delegate = selfcollectionView.backgroundColor = UIColor.whitecollectionView.register(UICollectionViewCell.self, forCellWithReuseIdentifier: NNItemCollectionViewControllerID) 自定义 UICollectionViewFlowLayout 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// MARK: - 更新布局override func prepare() &#123;super.prepare()// 清除所有的布局属性attrsArray.removeAll()columnHeightsAry.removeAll()for _ in 0 ..&lt; columnCountDefault &#123;columnHeightsAry.append(edgeInsetsDefault.top)&#125;let sections : Int = (collectionView?.numberOfSections)!for num in 0 ..&lt; sections &#123;let count : Int = (collectionView?.numberOfItems(inSection: num))!for i in 0 ..&lt; count &#123;let indexpath : NSIndexPath = NSIndexPath.init(item: i, section: num)let attrs = layoutAttributesForItem(at: indexpath as IndexPath)!attrsArray.append(attrs)&#125;&#125;&#125;// MARK: - cell 对应的布局属性override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? &#123;let attrs = UICollectionViewLayoutAttributes.init(forCellWith: indexPath)let collectionWidth = collectionView?.frame.size.width// 获得所有 item 的宽度let itemW = (collectionWidth! - edgeInsetsDefault.left - edgeInsetsDefault.right - CGFloat(columnCountDefault-1) * columnMargin) / CGFloat(columnCountDefault)let itemH = 50 + arc4random_uniform(100)// 找出高度最短那一列var dextColum : Int = 0var minH = columnHeightsAry[0]for i in 1 ..&lt; columnCountDefault&#123;// 取出第 i 列的高度let columnH = columnHeightsAry[i]if minH &gt; columnH &#123;minH = columnHdextColum = i&#125;&#125;let x = edgeInsetsDefault.left + CGFloat(dextColum) * (itemW + columnMargin)var y = minHif y != edgeInsetsDefault.top&#123;y = y + itemMargin&#125;attrs.frame = CGRect(x: x, y: y, width: itemW, height: CGFloat(itemH))// 更新最短那列高度columnHeightsAry[dextColum] = attrs.frame.maxYreturn attrs&#125; 五、UIScrollView 练习 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// MARK: - 放大缩小// MARK: 放大func amplificationBtnClick() &#123;var zoomScale = scrollView.zoomScale // 当前缩放zoomScale += 0.1if zoomScale &gt;= scrollView.maximumZoomScale &#123;return&#125;self.scrollView.setZoomScale(zoomScale, animated: true)&#125;// MARK: 缩小func narrowDownBtnClick() &#123;var zoomScale = scrollView.zoomScale // 当前缩放zoomScale -= 0.1if zoomScale &lt;= scrollView.minimumZoomScale &#123;return&#125;self.scrollView.setZoomScale(zoomScale, animated: true)&#125;// MARK: - NNItemBtnViewDelegate 上下左右点击代理extension NNItemScrollView &#123;// MARK: 向左func leftBtnClickDelegate() &#123;var point = self.scrollView.contentOffsetpoint.x += 100point.x = point.x &gt;= self.scrollView.contentSize.width ? 0 : point.xscrollView.setContentOffset(point, animated: true)&#125;// MARK: 向右func rightBtnClickDelegate() &#123;var point = self.scrollView.contentOffsetpoint.x -= 100point.x = point.x &lt;= -NNScreenWidth ? 0 : point.xscrollView.setContentOffset(point, animated: true)&#125;// MARK: 向上func topBtnClickDelegate() &#123;var point = self.scrollView.contentOffsetpoint.y += 50point.y = point.y &gt;= self.scrollView.contentSize.height ? 0 : point.yscrollView.setContentOffset(point, animated: true)&#125;// MARK: 向下func bottomBtnClickDelegate() &#123;var point = self.scrollView.contentOffsetpoint.y -= 50point.y = point.y &lt;= -NNScreenHeight ? 0 : point.yscrollView.setContentOffset(point, animated: true)&#125;&#125; 六、照相功能，更换头像（建议用真机） 核心代码 123456789101112131415161718192021222324252627282930313233343536373839// MARK: - 点击头像按钮，更换头像func changePicture() &#123;let alertcontroller = UIAlertController(title: &quot;请选择相片&quot;, message: nil, preferredStyle: .actionSheet)let alertaction = UIAlertAction(title: &quot;从相册选取&quot;, style: .destructive) &#123; (action) inlet imagePicker = UIImagePickerController()imagePicker.delegate = selfimagePicker.sourceType = .photoLibraryimagePicker.allowsEditing = trueself.present(imagePicker, animated: true, completion: nil)&#125;let alertaction2 = UIAlertAction(title: &quot;拍照&quot;, style: .destructive) &#123; (action) inif (!UIImagePickerController.isSourceTypeAvailable(.camera)) &#123;print(&quot;设备不支持相机&quot;)return&#125;let imagePicker = UIImagePickerController()imagePicker.delegate = selfimagePicker.sourceType = .cameraimagePicker.allowsEditing = trueself.present(imagePicker, animated: true, completion: nil)&#125;let alertAction3 = UIAlertAction(title: &quot;取消&quot;, style: .cancel) &#123; (action) inprint(&quot;取消&quot;)&#125;alertcontroller.addAction(alertaction)alertcontroller.addAction(alertaction2)alertcontroller.addAction(alertAction3)present(alertcontroller, animated: true, completion: nil)&#125;// MARK: - UIImagePickerControllerDelegatefunc imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123;let image = info[UIImagePickerControllerOriginalImage] as! UIImageimageView.image = imageself.dismiss(animated: true, completion: nil)&#125; 七、二维码扫描及识别（建议用真机） 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// MARK: - 扫描设备设置func setupScanSession() &#123;do &#123;// 设置捕捉设备let device = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)// 设置设备输入输出let input = try AVCaptureDeviceInput(device: device)let output = AVCaptureMetadataOutput()output.setMetadataObjectsDelegate(self, queue: DispatchQueue.main)// 设置会话let scanSession = AVCaptureSession()scanSession.canSetSessionPreset(AVCaptureSessionPresetHigh)if scanSession.canAddInput(input) &#123;scanSession.addInput(input)&#125;if scanSession.canAddOutput(output) &#123;scanSession.addOutput(output)&#125;// 设置扫描类型(二维码和条形码)output.metadataObjectTypes = [AVMetadataObjectTypeQRCode,AVMetadataObjectTypeCode39Code,AVMetadataObjectTypeCode128Code,AVMetadataObjectTypeCode39Mod43Code,AVMetadataObjectTypeEAN13Code,AVMetadataObjectTypeEAN8Code,AVMetadataObjectTypeCode93Code]// 预览图层let scanPreviewLayer = AVCaptureVideoPreviewLayer(session:scanSession)scanPreviewLayer!.videoGravity = AVLayerVideoGravityResizeAspectFillscanPreviewLayer!.frame = view.layer.boundsview.layer.insertSublayer(scanPreviewLayer!, at: 0)// 设置扫描区域NotificationCenter.default.addObserver(forName: NSNotification.Name.AVCaptureInputPortFormatDescriptionDidChange, object: nil, queue: nil, using: &#123; (noti) inoutput.rectOfInterest = (scanPreviewLayer?.metadataOutputRectOfInterest(for:self.scanImageView.frame))!&#125;)// 保存会话self.scanSession = scanSession&#125; catch &#123;// 摄像头不可用return&#125;&#125; 扫描完成后调用 12345678910111213141516// MARK: - AVCaptureMetadataOutputObjectsDelegate 扫描捕捉完成extension NNScanCodeController : AVCaptureMetadataOutputObjectsDelegate &#123;func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) &#123;// 停止扫描scanLine.layer.removeAllAnimations()scanSession!.stopRunning()// 扫完完成if metadataObjects.count &gt; 0 &#123;if let resultObj = metadataObjects.first as? AVMetadataMachineReadableCodeObject &#123;print(resultObj.stringValue)scanResult.text = &quot;扫描结果:&quot; + resultObj.stringValue&#125;&#125;&#125;&#125; 识别验证码，从相册中选择 123456789101112131415161718192021222324252627// MARK: - UIImagePickerControllerDelegate, UINavigationControllerDelegateextension NNScanCodeController : UIImagePickerControllerDelegate , UINavigationControllerDelegate &#123;func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123;// 判断是否能取到图片guard let image = info[UIImagePickerControllerOriginalImage] as? UIImage else &#123;return&#125;// 转成ciimageguard let ciimage = CIImage(image: image) else &#123;return&#125;// 从选中的图片中读取二维码// 创建探测器let detector = CIDetector(ofType: CIDetectorTypeQRCode, context: nil, options: [CIDetectorAccuracy : CIDetectorAccuracyLow])let resoult = (detector?.features(in: ciimage))!scanResult.text = &quot;无法识别&quot;for result in resoult &#123;guard (result as! CIQRCodeFeature).messageString != nil else &#123;return&#125;scanResult.text = &quot;扫描结果:&quot; + (result as! CIQRCodeFeature).messageString!&#125;picker.dismiss(animated: true, completion: nil)&#125;&#125; 八、随机图片验证码封装 核心代码12345678910111213141516171819202122232425262728293031323334353637383940414243// MARK: - 绘制图形验证码override func draw(_ rect: CGRect) &#123;if charString.isEmpty &#123;return;&#125;let textString:String = charStringlet charSize = textString.substring(to: textString.startIndex).size(attributes: [NSFontAttributeName : UIFont.systemFont(ofSize: 14)])let width = rect.size.width / CGFloat(charCount) - charSize.width - 15;let hight = rect.size.height - charSize.height;var point: CGPointvar pointX: CGFloatvar pointY: CGFloatfor i in 0..&lt;textString.characters.count &#123;let char = CGFloat(i)pointX = (CGFloat)(arc4random() % UInt32(Float(width))) + rect.size.width / (CGFloat)(textString.characters.count) * charpointY = (CGFloat)(arc4random() % UInt32(Float(hight)))point = CGPoint(x: pointX, y: pointY)let charStr = textString[textString.index(textString.startIndex, offsetBy:i)]let string = String(charStr)string.draw(at: point,withAttributes:([NSFontAttributeName : UIFont.systemFont(ofSize: 14)]))&#125;drawLine(rect)&#125;// MARK: - 绘制干扰线func drawLine(_ rect: CGRect) &#123;let context = UIGraphicsGetCurrentContext()context!.setLineWidth(1.0)var pointX = 0.0var pointY = 0.0for _ in 0..&lt;lineCount &#123;context!.setStrokeColor(randomColor().cgColor)pointX = Double(arc4random() % UInt32(Float(rect.size.width)))pointY = Double(arc4random() % UInt32(Float(rect.size.height)))context?.move(to: CGPoint(x: pointX, y: pointY))pointX = Double(CGFloat(arc4random() % UInt32(Float(rect.size.width))))pointY = Double(CGFloat(arc4random() % UInt32(Float(rect.size.height))))context?.addLine(to: CGPoint(x: pointX, y: pointY))context!.strokePath()&#125;&#125; OC版本：iOS开发 - 随机图片验证码封装 九、圆形输入框封装 核心代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// MARK: - 监听文本输入 核心操作func textFieldDidChange(_ textField: UITextField) &#123;let i = textField.text?.characters.countif i! &gt; labelCount &#123;return&#125;if i == 0 &#123;((labelArr.object(at: 0)) as! UILabel).text = &quot;&quot;((labelArr.object(at: 0)) as! UILabel).layer.borderColor = defaultColor.cgColor&#125; else &#123;((labelArr.object(at: (i! - 1))) as! UILabel).text = (textField.text! as NSString).substring(with: NSMakeRange(i! - 1, 1))((labelArr.object(at: (i! - 1))) as! UILabel).layer.borderColor = changedColor.cgColor((labelArr.object(at: (i! - 1))) as! UILabel).textColor = changedColorif labelCount &gt; i! &#123;((labelArr.object(at: (i!))) as! UILabel).text = &quot;&quot;((labelArr.object(at: (i!))) as! UILabel).layer.borderColor = defaultColor.cgColor&#125;&#125;&#125;// MARK: - setupUIfunc setupUI() &#123;setupTextField()var labelX = CGFloat()let labelY : CGFloat = 0.0let labelWidth = self.width / CGFloat(labelCount)let sideLength = labelWidth &lt; self.height ? labelWidth : self.heightfor i in 0..&lt;labelCount &#123;if i == 0 &#123;labelX = 0&#125; else &#123;labelX = CGFloat(i) * (sideLength + labelDistance)&#125;let label = UILabel(frame: CGRect(x: labelX, y: labelY, width: sideLength, height: sideLength))self.addSubview(label)label.textAlignment = NSTextAlignment.centerlabel.layer.borderColor = UIColor.black.cgColorlabel.layer.borderWidth = 1.0label.layer.cornerRadius = sideLength / 2.0labelArr.add(label)&#125;&#125;// MARK: - UITextFieldDelegate// MARK: 监听输入框func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -&gt; Bool &#123;// 允许删除if (string.characters.count == 0) &#123;return true&#125; else if (textField.text?.characters.count)! &gt;= labelCount &#123;return false&#125; else &#123;return true&#125;&#125;// MARK: 回车收起键盘func textFieldShouldReturn(_ textField: UITextField) -&gt; Bool &#123;textField.resignFirstResponder()return false&#125; OC版本：iOS开发 - 圆形验证码(或密码)输入框的封装输入框的封装/) 十、第三方库 SnapKit 用法 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677func addRedView() &#123;redView.backgroundColor = UIColor.redview.addSubview(redView)// redView 距离父视图四条边的距离都是 50redView.snp.makeConstraints &#123; (make) inmake.edges.equalTo(view).inset(50)&#125;&#125;func addBlueView() &#123;blueView.backgroundColor = UIColor.blueview.addSubview(blueView)// blueView 左边距离父视图为 0；上边距离父视图为 0；size 是(50，50)blueView.snp.makeConstraints &#123; (make) inmake.left.equalTo(0)make.top.equalTo(0)make.size.equalTo(CGSize(width: 50, height: 50))&#125;&#125;func addBlackView() &#123;blackView.backgroundColor = UIColor.blackview.addSubview(blackView)// blackView 左边和 redView 的右边距离为 0；大小与 blueView 相同；且与 blueView 上对齐blackView.snp.makeConstraints &#123; (make) inmake.left.equalTo(redView.snp.right)make.size.equalTo(blueView)make.top.equalTo(blueView)&#125;&#125;func addCyanView() &#123;cyanView.backgroundColor = UIColor.cyanview.addSubview(cyanView)// cyanView 与 blueView 左对齐；cyanView 的顶部距离 redView 的底部 10；cyanView 的高是40；cyanView 与 blueView 等宽cyanView.snp.makeConstraints &#123; (make) inmake.trailing.equalTo(blueView)make.top.equalTo(redView.snp.bottom).offset(10)make.height.equalTo(40)make.width.equalTo(blueView)&#125;&#125;func addYellowView() &#123;yellowView.backgroundColor = UIColor.yellowview.addSubview(yellowView)// yellowView 顶部与 redView 的底部对齐；yellowView 与 blackView 左对齐；yellowView 与 blueView 相同大小yellowView.snp.makeConstraints &#123; (make) inmake.top.equalTo(redView.snp.bottom)make.trailing.equalTo(blackView)make.size.equalTo(blueView)&#125;&#125;func addWhiteView() &#123;whiteView.backgroundColor = UIColor.whiteredView.addSubview(whiteView)// whiteView 的父视图是 redView，距离父视图四条边的距离分别是（30，10，30，10）whiteView.snp.makeConstraints &#123; (make) in// 第一种方式make.edges.equalTo(redView).inset(UIEdgeInsets(top: 30, left: 10, bottom: 30, right: 10))// 第二种方式// make.top.equalTo(redView).offset(30)// make.left.equalTo(redView).offset(10)// make.bottom.equalTo(redView).offset(-30)// make.right.equalTo(redView).offset(-10)// 第三种方式// make.top.left.bottom.right.equalTo(redView).inset(UIEdgeInsets(top: 30, left: 10, bottom: 30, right: 10))&#125;&#125; 详情代码，请移步到 https://github.com/liuzhongning/NNMintFurniture 中查看，如有疑问或有建议的地方，欢迎讨论。另外代码中有一个名为 guide.swift 的类，简单标出了代码的结构，更方便阅读。会持续更新……]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 开发中导航栏渐变的两种方法]]></title>
    <url>%2F2017%2F08%2F29%2FiOS%20%E5%BC%80%E5%8F%91%E4%B8%AD%E5%AF%BC%E8%88%AA%E6%A0%8F%E6%B8%90%E5%8F%98%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[很多 APP 都有导航栏颜色渐变的效果，各位开发者也都八仙过海各显神通，各有各的方法，我这里提供两种思路：第一种是通过设置 navigationBar 的 alpha；第二种是在 navigationBar 上加入一个 view，再设置 view 的 alpha。 两种方法的核心代码： 一、设置 navigationBar 的 alpha向上滑和向下滑时分别对 navigationBar 的透明度进行设置。 12345678910111213141516171819202122232425#pragma mark - UIScrollViewDelegate- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;self.currentPostion = scrollView.contentOffset.y;if (self.currentPostion &gt; 0) &#123;if (self.currentPostion - self.lastPosition &gt;= 0) &#123;if (self.topBool) &#123;self.topBool = NO;self.bottomBool = YES;self.stopPosition = self.currentPostion + 64;&#125;self.lastPosition = self.currentPostion;self.navigationController.navigationBar.alpha = 1 - self.currentPostion / 500;&#125; else &#123;if (self.bottomBool) &#123;self.bottomBool = NO;self.topBool = YES;self.stopPosition = self.currentPostion + 64;&#125;self.lastPosition = self.currentPostion;self.navigationController.navigationBar.alpha = (self.stopPosition - self.currentPostion) / 200;&#125;&#125;&#125; 这里要说明一点，如果你不希望自己 navigationBar 上的按钮也被改变透明度，可以通过自定义 UINavigationController 实现。用系统的 navigationBar 时，navigationBar上的按钮的透明度也会被更改。 二、在 navigationBar 上加入一个 view在 navigationBar 上加一个 view，然后设置 view 的 alpha。 12345CGSize customSize = self.navigationController.navigationBar.frame.size;self.customView = [[UIView alloc] initWithFrame:CGRectMake(0, -20, customSize.width, customSize.height + 20)];self.customView.backgroundColor = [UIColor orangeColor];self.customView.userInteractionEnabled = NO;[self.navigationController.navigationBar insertSubview: self.customView atIndex:0]; 这里也要说明一点，View 的 userInteractionEnabled 属性要设置为 NO，不然会出现问题。 UIScrollViewDelegate 的这个代理方法与上面的一样。12345678910111213141516171819202122232425#pragma mark - UIScrollViewDelegate- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;self.currentPostion = scrollView.contentOffset.y;if (self.currentPostion &gt; 0) &#123;if (self.currentPostion - self.lastPosition &gt;= 0) &#123;if (self.topBool) &#123;self.topBool = NO;self.bottomBool = YES;self.stopPosition = self.currentPostion + 64;&#125;self.lastPosition = self.currentPostion;self.customView.alpha = 1 - self.currentPostion / 500;&#125; else &#123;if (self.bottomBool) &#123;self.bottomBool = NO;self.topBool = YES;self.stopPosition = self.currentPostion + 64;&#125;self.lastPosition = self.currentPostion;self.customView.alpha = (self.stopPosition - self.currentPostion) / 200;&#125;&#125;&#125; 上面的两种方法都可以实现导航栏渐变，只是思路不同，一个是改变系统的导航栏，一个是在导航栏上插入 View，另外还可以自定义导航控制器这个类来实现，各位道友可以试试哦！ 代码传送门 欢迎各位道友交流或指出错误！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 - 仿简书个人主页多页面滑动视图]]></title>
    <url>%2F2017%2F08%2F22%2FiOS%E5%BC%80%E5%8F%91%20-%20%E4%BB%BF%E7%AE%80%E4%B9%A6%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E5%A4%9A%E9%A1%B5%E9%9D%A2%E6%BB%91%E5%8A%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[之前项目中很多地方用到了滑动视图，三个界面五个界面或界面个数不定的情况都有，这里以简书 APP 的个人主页为例，总结一下，一则对自己也有好处，二则希望对看到的朋友有所帮助。 简书APP个人主页： demo 效果图： demo 地址：https://github.com/liuzhongning/NNJaneBookView 简单说下思路及核心代码： 思路： 导航栏上面的头像会随着视图的上下滑动而变大变小，这里注册了一个通知，用来监听视图的上下滑动，可以根据偏移量的值来改变头像的大小。 此 UI 页面分为三部分，第一部分是信息展示，用来显示昵称签名等；第二部分是标签栏，即“动态”，“文章”，“更多”这三个标签；第三部分是主要显示内容； 我这里用了这样的思路：页面底部是一个 UIScrollView; 接着 UIScrollView 上面 add 了三个 UITableView ；信息展示以及标签栏放在 UITableView 的 tableHeaderView 中；接着挨个实现其功能即可。 核心代码： 头像跟随页面上下滑动而变大变小 这里是头像变大变小时调用的代码，如果你的项目中用到了此功能，可以直接把这个类拿过去，然后调用下面这几句代码就可以实现了。另外点击头像的回调也通过 block 传了出来，你可以在此处做些操作，比如更改头像等等。 123456self.headerImageView = [[NNPersonalHomePageHeaderImageView alloc] initWithImage:[UIImage imageNamed:@&quot;header&quot;]];[self.headerImageView reloadSizeWithScrollView:self.dynamicTableView];self.navigationItem.titleView = self.headerImageView;[self.headerImageView handleClickActionWithBlock:^&#123;NSLog(@&quot;你点击了头像按钮&quot;);&#125;]; tableView 的头部视图 这里另外建了两个 UIView 类，一个用来显示基本信息（昵称签名等），一个用来显示标签栏（动态，文章等标签），额外建这两个 UIView 类是为了减少控制器中的代码。 1234567891011121314151617181920212223242526- (void)setupHeaderView &#123;UIView *headerView = [[NNPersonalHomePageHeaderView alloc] init];headerView.frame = CGRectMake(0, 0, NNScreenWidth, NNHeadViewHeight + NNTitleHeight);[self.view addSubview:headerView];self.headerView = headerView;NNPersonalHomePageTitleView *titleView = [[NNPersonalHomePageTitleView alloc] init];[headerView addSubview:titleView];self.titleView = titleView;titleView.backgroundColor = [UIColor whiteColor];[titleView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.right.mas_equalTo(headerView);make.bottom.equalTo(headerView.mas_bottom);make.height.mas_equalTo(NNTitleHeight);&#125;];[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.right.bottom.equalTo(self.view);make.top.mas_equalTo(headerView.top);&#125;];__weak typeof(self) weakSelf = self;titleView.titles = @[@&quot;动态&quot;, @&quot;文章&quot;, @&quot;更多&quot;];titleView.selectedIndex = 0;titleView.buttonSelected = ^(NSInteger index)&#123;[weakSelf.scrollView setContentOffset:CGPointMake(NNScreenWidth * index, 0) animated:YES];&#125;;&#125; 主要内容 主要内容就是页面下部展示的具体内容，这里用了三个 UITableView ，依次添加到 UIScrollView 中，这里代码有些臃肿，后期再做优化，有兴趣的童鞋也可以帮忙改一下哈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/// 主要内容- (void)setupContentView &#123;NNContentScrollView *scrollView = [[NNContentScrollView alloc] init];scrollView.delaysContentTouches = NO;[self.view addSubview:scrollView];self.scrollView = scrollView;scrollView.pagingEnabled = YES;scrollView.showsVerticalScrollIndicator = NO;scrollView.showsHorizontalScrollIndicator = NO;scrollView.delegate = self;scrollView.contentSize = CGSizeMake(NNScreenWidth * 3, 0);UIView *headView = [[UIView alloc] init];headView.frame = CGRectMake(0, 0, 0, NNHeadViewHeight + NNTitleHeight);self.tableViewHeadView = headView;NNContentTableView *dynamicTableView = [[NNContentTableView alloc] init];dynamicTableView.delegate = self;dynamicTableView.separatorStyle = UITableViewCellSeparatorStyleNone;self.dynamicTableView = dynamicTableView;dynamicTableView.tableHeaderView = headView;[scrollView addSubview:dynamicTableView];[dynamicTableView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(scrollView);make.width.mas_equalTo(NNScreenWidth);make.top.equalTo(self.view);make.bottom.equalTo(self.view);&#125;];NNContentTableView *articleTableView = [[NNContentTableView alloc] init];articleTableView.delegate = self;articleTableView.separatorStyle = UITableViewCellSeparatorStyleNone;self.articleTableView = articleTableView;articleTableView.tableHeaderView = headView;[scrollView addSubview:articleTableView];[articleTableView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(scrollView).offset(NNScreenWidth);make.width.equalTo(dynamicTableView);make.top.bottom.equalTo(dynamicTableView);&#125;];NNContentTableView *moreTableView = [[NNContentTableView alloc] init];moreTableView.delegate = self;moreTableView.separatorStyle = UITableViewCellSeparatorStyleNone;self.moreTableView = moreTableView;moreTableView.tableHeaderView = headView;[scrollView addSubview:moreTableView];[moreTableView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(scrollView).offset(NNScreenWidth * 2);make.width.equalTo(dynamicTableView);make.top.bottom.equalTo(dynamicTableView);&#125;];&#125; 左右或上下滑动页面 这里为 UIScrollView 添加了代理，一旦滑动视图，便会调用下面这两个方法。为了区分是左右滑动还是上下滑动，这里做了简单的判断，if (scrollView == self.scrollView)，那么这就是左右滑动，因为 UITableView 是上下滑动的，所有左右滑动就是 UIScrollView 的滑动，需要切换 UITableView 的显示内容，在这里做相应的操作即可；如果 if (scrollView == self.scrollView || !scrollView.window)这个条件不成立，那么就是 UITableView 的滑动，就是上下滑动，在这里需要改变“标签栏”的frame，因为“标签栏”需要显示在导航栏下边位置。1234567891011121314151617181920212223242526272829303132333435363738394041#pragma mark - UIScrollViewDelegate- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView &#123;if (scrollView == self.scrollView) &#123;CGFloat contentOffsetX = scrollView.contentOffset.x;NSInteger pageNum = contentOffsetX / NNScreenWidth + 0.5;self.titleView.selectedIndex = pageNum;&#125;&#125;- (void)scrollViewDidScroll:(UIScrollView *)scrollView &#123;if (scrollView == self.scrollView || !scrollView.window) &#123;return;&#125;CGFloat offsetY = scrollView.contentOffset.y;CGFloat originY = 0;CGFloat otherOffsetY = 0;if (offsetY &lt;= NNHeadViewHeight) &#123;originY = -offsetY;if (offsetY &lt; 0) &#123;otherOffsetY = 0;&#125; else &#123;otherOffsetY = offsetY;&#125;&#125; else &#123;originY = -NNHeadViewHeight;otherOffsetY = NNHeadViewHeight;&#125;self.headerView.frame = CGRectMake(0, originY, NNScreenWidth, NNHeadViewHeight + NNTitleHeight);for ( int i = 0; i &lt; self.titleView.titles.count; i++ ) &#123;if (i != self.titleView.selectedIndex) &#123;UITableView *contentView = self.scrollView.subviews[i];CGPoint offset = CGPointMake(0, otherOffsetY);if ([contentView isKindOfClass:[UITableView class]]) &#123;if (contentView.contentOffset.y &lt; NNHeadViewHeight || offset.y &lt; NNHeadViewHeight) &#123;[contentView setContentOffset:offset animated:NO];self.scrollView.offset = offset;&#125;&#125;&#125;&#125;&#125; 上面只是简单的介绍下，具体的代码还请到 demo 中 查看，如有疑问或有建议的地方，欢迎讨论。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 - 极光推送中生产证书和开发证书的生成]]></title>
    <url>%2F2017%2F08%2F12%2FiOS%E5%BC%80%E5%8F%91%20-%20%E6%9E%81%E5%85%89%E6%8E%A8%E9%80%81%E4%B8%AD%E7%94%9F%E4%BA%A7%E8%AF%81%E4%B9%A6%E5%92%8C%E5%BC%80%E5%8F%91%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[项目中用到了 极光推送，这里记录下极光推送中生产证书和开发证书的生成过程。 推送设置中需要配置生产证书以及开发证书~~ 1.开发证书生成步骤 登录 苹果开发者中心，点击 Certificates, IDs &amp; Profiles 点击 Development，并选择 Apple Push Notification service SSL (Sandbox)，接着点击下边的 Continue 按钮 来到 App ID 这个界面之后，继续点击下边的 Continue 按钮 这里的说明是让我们生成一个 CSR 文件，继续点击 Continue 按钮 这个界面需要上传 CSR 文件，上传 CSR 证书之后继续点击 Continue 按钮（ CSR 文件 生成很简单，后面会提一下） 点击 Continue 按钮之后，就会出现下面这个界面，直接点击 Download ，然后双击下载的证书，安装到钥匙串里。 1.1 CSR 文件生成步骤 首先打开电脑上的钥匙串，点击 从证书颁发机构请求证书，如下图所示： 填写用户邮箱地址以及 CA 电子邮件地址，将请求改为“存储到磁盘”，点击 继续，接着点击 存储 即可。 2.生产证书生成步骤 生产证书的生成和开发证书的生成类似，先选择 Production ，点击“加号”后选择 Production 中的 Apple Push Notification service SSL (Sandbox &amp; Production) 这一栏，接着点击 Continue 按钮 来到 App ID 这个界面之后，继续点击下边的 Continue 按钮 然后依然会让上传一个 CSR 文件， 不再累述。生产证书生成后，下载安装到钥匙串中即可。 3. 导出 p12 文件 选中刚刚安装的生产证书和开发证书，然后导出~ 文件格式为 个人信息交换(.p12) 接着设置下密码 最后将两个p12文件上传到极光推送上，就OK了！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>极光推送</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 - 链式编程思想]]></title>
    <url>%2F2017%2F08%2F08%2FiOS%E5%BC%80%E5%8F%91%20-%20%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[因为有 Masory 以及 Snapkit 这些知名开源库的存在，相信很多 iOS 开发者对链式编程都不会太陌生，先来看下面这句代码： 123[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.top.bottom.left.right.equalTo(self.view).insets(UIEdgeInsetsMake(250, 100, 250, 100));&#125;]; 这句代码就属于链式编程，而且 Masonry 框架本身也是通过链式语法对 NSLayoutConstraints 进行的封装。对 Masonry 感兴趣的童鞋可以读读这篇文章 iOS开发之源码解析 - Masonry。 链式编程思想：所谓链式编程就是通过点（.）将多个操作链接在一起成为一句代码，使代码更加紧凑，也提高了代码的可读性（如上面那句代码）。 链式编程特点： 方法的返回值是 block，block 中必须有一个返回值，通常返回它本身，也可以是处理后的数据或对象。 返回值中的 block 具备两个功能，第一：可以作为类的属性被’点’出来。第二：可以当作函数直接调用。 通常会通过调用一个函数来给属性赋值，在函数内部封装赋值的语句，也可以加入一些判断逻辑等。 链式编程练习我这里写了一个 UILabel 的扩展类用来练习链式编程，叫做 UILabel+NNCategory。利用这个分类创建 UILabel，并为其设置frame，text，font，textColor，backgroundColor等属性，代码如下： 123[UILabel addToView:self.view createLabel:^(UILabel *label) &#123;label.nn_frame(50, 200, 300, 100).nn_text(@&quot;NNTreasure&quot;).nn_fontSize(50).nn_textColor([UIColor redColor]).nn_backgroundColorRGB(224, 224, 224, 1).nn_textAlignment(NSTextAlignmentCenter);&#125;]; 细心观察上面的代码，我们可以猜出 nn_frame()，nn_text()，nn_fontSize() 这些都是属性，不过为什么它们后面都带有括号呢？这是因为这些属性都是 block 类型。那么为什么它们可以点出来呢？即为什么可以 label.nn_frame().nn_text().nn_fontSize() 这么用？简单来说，就是因为这些 block 类型的属性都带有返回值！ 下面是分类 UILabel+NNCategory 的详细实现过程 在 UILabel+NNCategory.h 中声明一些属性 1234567891011121314151617181920@property (nonatomic, copy, readonly) UILabel *(^nn_text)(NSString *);@property (nonatomic, copy, readonly) UILabel *(^nn_frame)(CGFloat, CGFloat, CGFloat, CGFloat);@property (nonatomic, copy, readonly) UILabel *(^nn_attributedText)(NSAttributedString *);@property (nonatomic, copy, readonly) UILabel *(^nn_textAlignment)(NSTextAlignment);@property (nonatomic, copy, readonly) UILabel *(^nn_textColor)(UIColor *);@property (nonatomic, copy, readonly) UILabel *(^nn_textColorRGB)(CGFloat, CGFloat, CGFloat, CGFloat);@property (nonatomic, copy, readonly) UILabel *(^nn_backgroundColor)(UIColor *);@property (nonatomic, copy, readonly) UILabel *(^nn_backgroundColorRGB)(CGFloat, CGFloat, CGFloat, CGFloat);@property (nonatomic, copy, readonly) UILabel *(^nn_highlightTextColor)(UIColor *);@property (nonatomic, copy, readonly) UILabel *(^nn_highlight)(BOOL);@property (nonatomic, copy, readonly) UILabel *(^nn_enable)(BOOL);@property (nonatomic, copy, readonly) UILabel *(^nn_font)(UIFont *);@property (nonatomic, copy, readonly) UILabel *(^nn_fontSize)(NSInteger);@property (nonatomic, copy, readonly) UILabel *(^nn_shadowColor)(UIColor *);@property (nonatomic, copy, readonly) UILabel *(^nn_shadowOffset)(CGSize);@property (nonatomic, copy, readonly) UILabel *(^nn_lineBreakMode)(NSLineBreakMode);@property (nonatomic, copy, readonly) UILabel *(^nn_numberOfLine)(NSInteger);@property (nonatomic, copy, readonly) UILabel *(^nn_adjustsFontSizeToFitWidth)(BOOL);@property (nonatomic, copy, readonly) UILabel *(^nn_baselineAdjust)(UIBaselineAdjustment);@property (nonatomic, copy, readonly) UILabel *(^nn_drawText)(CGRect); 我们在 UILabel 分类里面声明了这些属性，所以接下来只要是 UILabel 类型都可以点出来这些属性。这里也可以看出这些属性都是 block 类型。我们抽出一句代码简单说明一下：@property (nonatomic, copy, readonly) UILabel *(^nn_text)(NSString *);，这句代码声明了一个 block(^) 原型，名字叫做 nn_text，包含了一个 NSString 类型的参数，返回值是 UILabel 类型。 在 UILabel+NNCategory.m 中实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139- (UILabel *(^)(NSString *))nn_text &#123;return ^(NSString *text) &#123;self.text = text;return self;&#125;;&#125;- (UILabel *(^)(CGFloat, CGFloat, CGFloat, CGFloat))nn_frame &#123;return ^(CGFloat X, CGFloat Y, CGFloat W, CGFloat H) &#123;self.frame = CGRectMake(X, Y, W, H);return self;&#125;;&#125;- (UILabel *(^)(NSAttributedString *))nn_attributedText &#123;return ^(NSAttributedString *attributedText) &#123;self.attributedText = attributedText;return self;&#125;;&#125;- (UILabel *(^)(NSTextAlignment))nn_textAlignment &#123;return ^(NSTextAlignment textAlignment) &#123;self.textAlignment = textAlignment;return self;&#125;;&#125;- (UILabel *(^)(UIColor *))nn_textColor &#123;return ^(UIColor *textColor) &#123;self.textColor = textColor;return self;&#125;;&#125;- (UILabel *(^)(CGFloat, CGFloat, CGFloat, CGFloat))nn_textColorRGB &#123;return ^(CGFloat r, CGFloat g, CGFloat b, CGFloat a)&#123;self.textColor = [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:g / 255.0 alpha:a];return self;&#125;;&#125;- (UILabel *(^)(UIColor *))nn_backgroundColor &#123;return ^(UIColor *backgroundColor) &#123;self.backgroundColor = backgroundColor;return self;&#125;;&#125;- (UILabel *(^)(CGFloat, CGFloat, CGFloat, CGFloat))nn_backgroundColorRGB &#123;return ^(CGFloat r, CGFloat g, CGFloat b, CGFloat a) &#123;self.backgroundColor = [UIColor colorWithRed:r / 255.0 green:g / 255.0 blue:g / 255.0 alpha:a];return self;&#125;;&#125;- (UILabel *(^)(UIColor *))nn_highlightTextColor &#123;return ^(UIColor *color) &#123;self.highlightedTextColor = color;return self;&#125;;&#125;- (UILabel *(^)(BOOL))nn_highlight &#123;return ^(BOOL isHighlighted) &#123;self.highlighted = isHighlighted;return self;&#125;;&#125;- (UILabel *(^)(BOOL))nn_enable &#123;return ^(BOOL isEnabled) &#123;self.enabled = isEnabled;return self;&#125;;&#125;- (UILabel *(^)(UIFont *))nn_font &#123;return ^(UIFont *font) &#123;self.font = font;return self;&#125;;&#125;- (UILabel *(^)(NSInteger))nn_fontSize &#123;return ^(NSInteger size) &#123;self.font = [UIFont systemFontOfSize:size];return self;&#125;;&#125;- (UILabel *(^)(UIColor *))nn_shadowColor &#123;return ^(UIColor *shadowColor) &#123;self.shadowColor = shadowColor;return self;&#125;;&#125;- (UILabel *(^)(CGSize))nn_shadowOffset &#123;return ^(CGSize size) &#123;self.shadowOffset = size;return self;&#125;;&#125;- (UILabel *(^)(NSLineBreakMode))nn_lineBreakMode &#123;return ^(NSLineBreakMode mode) &#123;self.lineBreakMode = mode;return self;&#125;;&#125;- (UILabel *(^)(NSInteger))nn_numberOfLine &#123;return ^(NSInteger number) &#123;self.numberOfLines = number;return self;&#125;;&#125;- (UILabel *(^)(BOOL))nn_adjustsFontSizeToFitWidth &#123;return ^(BOOL b) &#123;self.adjustsFontSizeToFitWidth = b;return self;&#125;;&#125;- (UILabel *(^)(UIBaselineAdjustment))nn_baselineAdjust &#123;return ^(UIBaselineAdjustment adjustment) &#123;self.baselineAdjustment = adjustment;return self;&#125;;&#125;- (UILabel *(^)(CGRect))nn_drawText &#123;return ^(CGRect rect) &#123;[self drawTextInRect:rect];return self;&#125;;&#125; UILabel+NNCategory.m 中的这些是 UILabel+NNCategory.h 文件中属性的 getter 方法。我们抽出一个简单说明一下 123456789- (UILabel *(^)(NSString *))nn_text &#123;// 返回临时变量的 blockreturn ^(NSString *text) &#123;// block 执行的一些功能self.text = text;// block 执行完毕的返回值return self;&#125;;&#125; 这个属性的类型是 block，具体是 UILabel *(^nn_text)(NSString *) 类型，需要说明的是，我们用 block 并不是为了返回 block 对象本身，而是为了在 block 内部执行一些操作，所以我们在属性的 getter 方法中首先返回一个临时的 block 对象，主要是为了在 block 内部返回 UILabel 类型的对象。具体请看上面代码块中的一些注释。 这时我们还需要定义一个方法方便外界调用，这个方法主要有两个功能，第一是用来创建 UILabel ，第二是为其“点”出各种属性。 在 UILabel+NNCategory.h 中声明一个方法 1+ (instancetype)addToView:(UIView *)superView createLabel:(void(^)(UILabel *label))block; 这里是模仿 Masonry，我们通常用 Masonry 加约束时首先会调用这个方法：- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block， 123456- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123;self.translatesAutoresizingMaskIntoConstraints = NO;MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self];block(constraintMaker);return [constraintMaker install];&#125; 我们用 Masonry 加约束时调用这个方法，是因为 Masonry 在这个方法内部早已做好一些所需要的操作。所以接下来我们也要在 UILabel+NNCategory.m 中做些事情。 在 UILabel+NNCategory.m 中实现这个方法 123456789+ (instancetype)addToView:(UIView *)superView createLabel:(void(^)(UILabel *label))block &#123;// 创建 UILabelUILabel *label = [[UILabel alloc] init];// 把 UILabel 添加到传过来的 superView 上[superView addSubview:label];// 通过 block 进行回调if (block) block(label);return label;&#125; 上面这个方法首先初始化一个 UILabel 对象，接着把 UILabel 添加到传过来的 superView 上，然后对 block 进行回调，执行 block，把外界对 UILabel 设置的属性添加上去，最后返回 UILabel 对象。 这就是一些简单的链式编程思维，外界调用的时候只需如下代码即可： 123[UILabel addToView:self.view createLabel:^(UILabel *label) &#123;label.nn_frame(50, 200, 300, 100).nn_text(@&quot;NNTreasure&quot;).nn_fontSize(50).nn_textColor([UIColor redColor]).nn_backgroundColorRGB(224, 224, 224, 1).nn_textAlignment(NSTextAlignmentCenter);&#125;]; 效果图如下：]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>链式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 - 随机图片验证码封装]]></title>
    <url>%2F2017%2F07%2F27%2FiOS%E5%BC%80%E5%8F%91%20-%20%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[在 iOS 开发中，为了防止短信验证码的恶意获取，注册时需要图片验证，比如某共享单车 APP 在注册时就用了图片验证码，如下图： 图片验证码封装思路：第一眼看到图片验证码，可能会觉得图片验证码是由 UIImage 实现的，但事实上明显不是，这里简单说下图片验证码封装思路。 首先要有一个数组，里面包含 1-9、a-z 这些字符 在 UIView 上显示这些字符 同时在 UIView 上绘制干扰线 效果图 用法 12_testView = [[NNValidationView alloc] initWithFrame:CGRectMake((self.view.frame.size.width - 100) / 2, 200, 100, 40) andCharCount:4 andLineCount:4];[self.view addSubview:_testView]; 以上两行代码便可以实现图片验证码，其中 charCount 和 lineCount 分别指显示的字符串数量以及干扰线的数量。另外我们还需要知道图片验证码上的字符串，可以用下边这个 block 获取： 12345__weak typeof(self) weakSelf = self;/// 返回验证码数字_testView.changeValidationCodeBlock = ^(void)&#123;NSLog(@&quot;验证码被点击了：%@&quot;, weakSelf.testView.charString);&#125;; 打印效果如下 核心代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#pragma mark - 绘制界面- (void)drawRect:(CGRect)rect &#123;[super drawRect:rect];self.backgroundColor = NNRandomColor;CGFloat rectWidth = rect.size.width;CGFloat rectHeight = rect.size.height;CGFloat pointX, pointY;NSString *text = [NSString stringWithFormat:@&quot;%@&quot;,self.charString];NSInteger charWidth = rectWidth / text.length - 15;NSInteger charHeight = rectHeight - 25;// 依次绘制文字for (NSInteger i = 0; i &lt; text.length; i++) &#123;// 文字X坐标pointX = arc4random() % charWidth + rectWidth / text.length * i;// 文字Y坐标pointY = arc4random() % charHeight;unichar charC = [text characterAtIndex:i];NSString *textC = [NSString stringWithFormat:@&quot;%C&quot;, charC];[textC drawAtPoint:CGPointMake(pointX, pointY) withAttributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:arc4random() % 10 + 15]&#125;];&#125;// 获取上下文CGContextRef context = UIGraphicsGetCurrentContext();// 设置线宽CGContextSetLineWidth(context, 1.0);// 依次绘制直线for(NSInteger i = 0; i &lt; self.lineCount; i++) &#123;// 设置线的颜色CGContextSetStrokeColorWithColor(context, NNRandomColor.CGColor);// 设置线的起点pointX = arc4random() % (NSInteger)rectWidth;pointY = arc4random() % (NSInteger)rectHeight;CGContextMoveToPoint(context, pointX, pointY);// 设置线的终点pointX = arc4random() % (NSInteger)rectWidth;pointY = arc4random() % (NSInteger)rectHeight;CGContextAddLineToPoint(context, pointX, pointY);// 绘画路径CGContextStrokePath(context);&#125;&#125; 代码中写了注释，因此这里不再详细解释，需要看全部代码的童鞋可以点击下边的链接，有疑问或有建议的话欢迎讨论。 demo 地址：NNValidationView]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发 - 圆形验证码(或密码)输入框的封装]]></title>
    <url>%2F2017%2F07%2F19%2FiOS%E5%BC%80%E5%8F%91%20-%20%E5%9C%86%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81(%E6%88%96%E5%AF%86%E7%A0%81)%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[项目中用到了圆形验证码输入框，输入框之间要求有一定的距离，UI图如下： 上面的UI图主要有以下几个要求： 输入框为圆形 输入框之间有适当距离 输入框颜色在输入文本时有变化 刚开始想着用固定的几个 UITextField 实现，但转念一想，用 UITextField 实现有点麻烦（输入框多的话，它们之间的响应事件不太容易控制，需要来回变换），于是开始想其它办法，最后用了以下的思路： 创建一个 UITextField，用 UILabel 显示 UITextField 上输入的数字，需要监听文本的输入，同时对 UILabel 进行一些操作，再用 block 将输入的文本传出来。 封装的圆形输入框主要实现了以下功能：输入框的数量、距离、颜色、大小等都可以自行设定，用起来也很方便，只需以下几行代码即可：123456NNValidationCodeView *view = [[NNValidationCodeView alloc] initWithFrame:CGRectMake(80, 100, 300, 45) andLabelCount:4 andLabelDistance:10];[self.view addSubview:view];view.changedColor = [UIColor yellowColor];view.codeBlock = ^(NSString *codeString) &#123;NSLog(@&quot;验证码:%@&quot;, codeString);&#125;; 这是 demo 的效果图： 由于代码很容易看懂，另外代码中也写了注释，因此这里不再对项目做过多的陈述，这是 demo地址，需要的话可以拿去借鉴，有什么不足之处希望能留下宝贵意见或建议！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发技巧 - UIViewController 基类设计]]></title>
    <url>%2F2017%2F07%2F12%2FiOS%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%20-%20UIViewController%20%E5%9F%BA%E7%B1%BB%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[在项目开发中，所有控制器里面大概都有共同的属性，比如背景色、导航栏、tarBar 的设置等等，这时我们一般都会设计出来一个 UIViewController 的基类，通常叫做 baseViewController或rootViewController，在这个类里面设置所有控制器的共同的属性，然后项目中所有的控制器再继承自这个类。 一般来说这种基类控制器里面需要做的操作有以下几个： 为 APP 设置统一的背景色 设置是否允许控制器自动调整高度（一般是 NO） 自定义导航栏返回按钮 重新布局视图大小，及时更新视图的 frame 当然还有其它的一些，毕竟这和项目的具体需求息息相关，因此还要因项目而异。我这里主要就列出基类控制器中基本的常用的一些需求，和大家分享下，希望能帮到需要的人，少走弯路；另外文章如果有不足之处，也希望各位同行能多多的交流指点。 UIViewController 基类控制器设计步骤首先创建一个 UIViewController 类，命名为 NNBaseViewController接着在 NNBaseViewController.m中做一些操作1.设置应用的统一背景色 12// 设置应用的背景色self.view.backgroundColor = [UIColor lightGrayColor]; 2.将 automaticallyAdjustsScrollViewInsets 设置为NO，不然视图会下移64像素 12// 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素self.automaticallyAdjustsScrollViewInsets = NO; 3.有时候系统的返回按钮不符合应用的风格，所以就需要重写导航栏上的返回按钮 12345678910111213141516#pragma mark - 自定义返回按钮- (void)setupLeftBarButton &#123;// 自定义 leftBarButtonItem ，UIImageRenderingModeAlwaysOriginal 防止图片被渲染self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[[UIImage imageNamed:@&quot;Back-蓝&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]style:UIBarButtonItemStylePlaintarget:selfaction:@selector(leftBarButtonClick)];// 防止返回手势失效self.navigationController.interactivePopGestureRecognizer.delegate = (id&lt;UIGestureRecognizerDelegate&gt;)self;&#125;#pragma mark - 返回按钮的点击事件- (void)leftBarButtonClick &#123;[self.navigationController popViewControllerAnimated:YES];&#125; 当然这里需要判断一下，不然首层控制器的导航栏上也会被设置上返回按钮 leftBarButtonItem，我是在 - (void)viewDidLoad 方法中判断的。 1234// 判断是否有上级页面，有的话再调用if ([self.navigationController.viewControllers indexOfObject:self] &gt; 0) &#123;[self setupLeftBarButton];&#125; 4.接下来我们一起设置下 View 中视图的布局，根据视图中控件的最大的 Y 值和最大的 X 值调整 View 的 frame 。这个主要用在视图中控件比较多的时候，也需要具体分析，比如有时候应用中全是 UITableView，那么就不需要设置了，因为 UITableView 可以根据 cell 自动调整 frame。不过也有用到的时候，比如应用中需要计算高度的类有很多，那么就可以用这个统一设置，主要还是看项目需求。另外注意这个方法要放在 - (void)viewWillAppear:(BOOL)animated中。 1234567891011121314151617181920212223- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];CGFloat baseViewHeight = 0;CGFloat baseViewWidth = 0;NSArray *subViews = self.baseView.subviews;// 遍历视图中的所有控件，求出最大的Y值和最大的X值for (UIView *view in subViews) &#123;if (CGRectGetMaxY(view.frame) &gt; baseViewHeight) &#123;baseViewHeight = CGRectGetMaxY(view.frame);&#125;if (CGRectGetMaxX(view.frame) &gt; baseViewWidth) &#123;baseViewWidth = CGRectGetMaxX(view.frame);&#125;&#125;// 三目运算方法求出最大的宽是否大于屏幕宽，以及最大的高是否大于屏幕高CGFloat NNHeight = baseViewHeight &gt; NNBaseViewSizeHeight ? baseViewHeight:NNBaseViewSizeHeight;CGFloat NNWidth = baseViewWidth &gt; NNBaseViewSizeWidth ? baseViewWidth:NNBaseViewSizeWidth;self.baseView.contentSize = CGSizeMake(NNWidth, NNHeight);&#125; 上面代码块中用到了一个属性 baseView ， baseView 属于 UIScrollView 类，相当于一个子视图容器，所有继承自 NNBaseViewController 的控制器都应该把子视图添加到 baseView上，这样才能更新它的 frame。 12345678#import &lt;UIKit/UIKit.h&gt;@interface NNBaseViewController : UIViewController/** 子视图容器 */@property (nonatomic, strong) UIScrollView *baseView;@end 另外别忘了在 - (void)viewDidLoad 这个方法中创建baseView并设置它的属性。 123456789self.baseView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height - 64)];// 是否反弹self.baseView.bounces = NO;// 是否显示滚动指示器self.baseView.showsVerticalScrollIndicator = NO;self.baseView.showsHorizontalScrollIndicator = NO;[self.view addSubview:self.baseView];self.baseView.contentSize = NNContentSize; 上面便是一个基本的 UIViewController 的基类，具体还是要根据项目的需要来设计。 接下来是完整的代码：NNBaseViewController.h12345678#import &lt;UIKit/UIKit.h&gt;@interface NNBaseViewController : UIViewController/** 子视图容器 */@property (nonatomic, strong) UIScrollView *baseView;@end NNBaseViewController.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#import &quot;NNBaseViewController.h&quot;#define NNBaseViewSize self.baseView.bounds.size#define NNBaseViewSizeHeight self.baseView.bounds.size.height#define NNBaseViewSizeWidth self.baseView.bounds.size.width@interface NNBaseViewController ()@end@implementation NNBaseViewController- (void)viewDidLoad &#123;[super viewDidLoad];[self setupViews];// 判断是否有上级页面，有的话再调用if ([self.navigationController.viewControllers indexOfObject:self] &gt; 0) &#123;[self setupLeftBarButton];&#125;&#125;- (void)setupViews &#123;// 设置应用的背景色self.view.backgroundColor = [UIColor lightGrayColor];// 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素self.automaticallyAdjustsScrollViewInsets = NO;self.baseView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 64, [UIScreen mainScreen].bounds.size.width, [UIScreen mainScreen].bounds.size.height - 64)];// 是否反弹self.baseView.bounces = NO;// 是否显示滚动指示器self.baseView.showsVerticalScrollIndicator = NO;self.baseView.showsHorizontalScrollIndicator = NO;[self.view addSubview:self.baseView];self.baseView.contentSize = NNBaseViewSize;&#125;- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];CGFloat baseViewHeight = 0;CGFloat baseViewWidth = 0;NSArray *subViews = self.baseView.subviews;// 遍历视图中的所有控件，求出最大的Y值和最大的X值for (UIView *view in subViews) &#123;if (CGRectGetMaxY(view.frame) &gt; baseViewHeight) &#123;baseViewHeight = CGRectGetMaxY(view.frame);&#125;if (CGRectGetMaxX(view.frame) &gt; baseViewWidth) &#123;baseViewWidth = CGRectGetMaxX(view.frame);&#125;&#125;// 三目运算方法求出最大的宽和最大的高CGFloat NNHeight = baseViewHeight &gt; NNBaseViewSizeHeight ? baseViewHeight:NNBaseViewSizeHeight;CGFloat NNWidth = baseViewWidth &gt; NNBaseViewSizeWidth ? baseViewWidth:NNBaseViewSizeWidth;self.baseView.contentSize = CGSizeMake(NNWidth, NNHeight);&#125;#pragma mark - 自定义返回按钮- (void)setupLeftBarButton &#123;// 自定义 leftBarButtonItem ，UIImageRenderingModeAlwaysOriginal 防止图片被渲染self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[[UIImage imageNamed:@&quot;Back-蓝&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]style:UIBarButtonItemStylePlaintarget:selfaction:@selector(leftBarButtonClick)];// 防止返回手势失效self.navigationController.interactivePopGestureRecognizer.delegate = (id&lt;UIGestureRecognizerDelegate&gt;)self;&#125;#pragma mark - 返回按钮的点击事件- (void)leftBarButtonClick &#123;[self.navigationController popViewControllerAnimated:YES];&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>基类设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 多线程]]></title>
    <url>%2F2017%2F07%2F02%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近利用晚上的空闲时间，整理了一下多线程相关的知识，几经更改，就变成你现在看到的模样了（如有失误之处，还请不吝赐教）。把多线程相关的知识总结在这里，只希望对看到的朋友们有所帮助！文章有些长，涵盖的知识点也比较多，希望朋友们能够耐心读完哈！我们这篇文章主要包括以下几个模块： （一）iOS开发之多线程 基础知识 （二）iOS开发之多线程 NSThread （三）iOS开发之多线程 NSOperation （四）iOS开发之多线程 GCD （五）iOS开发之多线程 线程间的通信 下面我们开始了解 iOS 多线程的基础知识，如果在此之前对多线程已经有所了解的朋友，大可跳过这一部分，直接看后边三种多线程编程的 demo 即可！ （一）iOS 开发之多线程 基础知识1.多线程简介:一个进程要想执行任务, 必须得有线程(每个进程至少要有一条线程), 线程是进程的基本执行单元, 一个进程（程序）的所有任务都在线程中执行. 2.多线程的原理:同一时间, CPU 只能处理一条线程,只有一条线程在工作.多线程并发(同时)执行, 其实是 CPU 快速地在多条线程之间调度.如果 CPU 调度线程的时间足够快,就造成了多线程并发执行的假象. 3.多线程的优缺点:多线程的优点:能适当提高程序的执行效率.能适当提高资源利用率(CPU、内存利用率). 多线程的缺点:开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用512KB),如果开启大量的线程,会占用大量的内存空间,降低程序的性能. 4.多线程在 iOS 开发中的应用:主线程:一个 iOS 程序运行后，默认会开启1条线程，称为“主线程”或“ UI 线程”.主线程的主要作用:刷新 UI 界面、处理 UI 事件(比如点击事件、滚动事件、拖拽事件等). 5.iOS 中三种多线程编程的技术，分别是：（一）NSThread（二）Cocoa NSOperation（三）GCD（全称：Grand Central Dispatch）这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的。 三种方式的优缺点介绍：NSThread:优点：NSThread 比其他两个轻量级缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销。 Cocoa NSOperation优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。Cocoa operation 相关的类是 NSOperation ，NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。 GCDGrand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。 对 iOS 基础知识有了一定了解之后，下边我们开始看多线程相关的一些 demo， 建议朋友们试试下边的 demo，这样更方便理解！如有疑问，或发现某些 demo 写的有误，还请朋友们告知！ 下边我们开始了解NSThread，NSThread 其实用的真不多，主要还是用另外两种，不过作为 iOS 开发者，还是应该对它有些了解的，下边是 NSThread 相关的 demo ！ （二）iOS 开发之多线程 NSThread一、NSThread 初始化1.动态方法1234567- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument// 初始化线程NSThread* thread = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething:)object:nil];// 线程名字thread.name = @"MYThread";// 启动线程[thread start]; 2.静态方法123+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument[NSThread detachNewThreadSelector:@selector(doSomething:) toTarget:self withObject:nil];// 调用完毕后，会马上创建并开启新线程 3.隐式创建线程的方法：12- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg;[self performSelectorInBackground:@selector(run) withObject:nil]; 提示朋友们一下:第一种方式会直接创建线程并且开始运行线程，第二种方式是先创建线程对象，然后再运行线程操作，在运行线程操作前可以设置线程的优先级等线程信息 二、线程间的通信123456//在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];//在当前线程执行操作[self performSelector:@selector(run) withObject:nil];//在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 三、一些简单方法123456//获取当前线程NSThread *thread = [NSThread currentThread];//获取主线程NSThread *main = [NSThread mainThread];//睡眠，相当于暂停[NSThread sleepForTimeInterval:3]; NSThread 就说到这，一起再看下NSOperation， NSOperation 在开发中用的还是挺多的，虽然苹果建议使用 GCD ，但依然有开发者觉得 NSOperation 比 GCD 更好用！仁者见仁智者见智吧！本小白觉得如果能掌握还是都掌握的好！ （三）iOS开发之多线程 NSOperation一、创建线程的方式使用NSOperation创建线程的方式有3种: （1）NSInvocationOperation 方式（2）NSBlockOperation 方式（3）自定义子类继承NSOperation,实现内部相应的⽅法 下面是这三种方式创建线程的具体方法： 1.NSInvocationOperation123456789- (void)invocationOperation&#123;//创建NSInvocationOperation对象NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];//开始执行操作[operation start];&#125;//一旦执行操作,就会调用target的run方法 提示:默认情况下,调用了start方法后并不会开一条新线程去执行操作,只有将NSOperation放到一个NSOperationQueue中,才会异步执行操作. 2.NSBlockOperation1234567891011121314151617- (void)blockOperation&#123;//创建NSBlockOperation对象NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;// 主线程NSLog(@"1---%@", [NSThread currentThread]);&#125;];// 添加任务(在子线程执行)[operation addExecutionBlock:^&#123;NSLog(@"2---%@", [NSThread currentThread]);&#125;];[operation addExecutionBlock:^&#123;NSLog(@"3---%@", [NSThread currentThread]);&#125;];//开启执行操作[operation start];&#125; 提示:只要NSBlockOperation封装的操作数 &gt; 1,就会异步执行操作 3.自定义子类继承自NSOperation自定义NSOperation子类需要重写 - (void)main方法 123456789101112131415161718192021- (void)main&#123;// 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池@autoreleasepool &#123;for (NSInteger i = 0; i&lt;100; i++) &#123;NSLog(@"1 - %ld - %@", i, [NSThread currentThread]);&#125;//检测操作是否被取消,对取消做出响应if (self.isCancelled) return;for (NSInteger i = 0; i&lt;100; i++) &#123;NSLog(@"2 - %ld - %@", i, [NSThread currentThread]);&#125;if (self.isCancelled) return;for (NSInteger i = 0; i&lt;100; i++) &#123;NSLog(@"3 - %ld - %@", i, [NSThread currentThread]);&#125;if (self.isCancelled) return;&#125;&#125; 二、NSOperationQueue的应用一个NSOperation对象可以通过调用start方法来执行任务,默认是同步执行的.也可以将NSOperation添加到一个NSOperationQueue中去执行,而且是异步执行的. 1.NSOperationQueue简单创建123456789101112131415161718192021222324252627282930313233343536373839//第一种方式- (void)operationQueue&#123;// 创建NSOperationQueue队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];// 创建NSInvocationOperation对象NSInvocationOperation *operation1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run1) object:nil];NSInvocationOperation *operation2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run2) object:nil];// 创建NSBlockOperation对象NSBlockOperation *operation3 = [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@"1 --- %@", [NSThread currentThread]);&#125;];[operation3 addExecutionBlock:^&#123;NSLog(@"2 --- %@", [NSThread currentThread]);&#125;];NSBlockOperation *operation4 = [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@"3 --- %@", [NSThread currentThread]);&#125;];// 添加任务到队列中[queue addOperation:operation1];[queue addOperation:operation2];[queue addOperation:operation3];[queue addOperation:operation4];&#125;//第二种方式- (void)operationQueue2&#123;// 创建NSOperationQueue队列NSOperationQueue *queue = [[NSOperationQueue alloc] init];[queue addOperationWithBlock:^&#123;NSLog(@"1 --- %@", [NSThread currentThread]);&#125;];[queue addOperationWithBlock:^&#123;NSLog(@"2 --- %@", [NSThread currentThread]);&#125;];&#125; 2.NSOperation中的操作依赖NSOperation之间可以设置依赖来保证执行顺序,比如一定要让操作A执行完后,才能执行操作B,可以这么写[operationB addDependency:operationA]; // 操作B依赖于操作operationA,另外,通过removeDependency方法可以删除依赖对象. 123456789101112131415161718192021222324252627#pragma mark - 依赖操作调整执行顺序- (void)NSOperationTest1 &#123;NSOperationQueue *queue = [[NSOperationQueue alloc] init];NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@"~~1~~%@", [NSThread currentThread]);&#125;];NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123;for (int i = 0; i &lt; 5; i ++) &#123;NSLog(@"~~2~~%@~~%d~~", [NSThread currentThread], i);&#125;&#125;];NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123;NSLog(@"~~3~~%@", [NSThread currentThread]);&#125;];[op2 addExecutionBlock:^&#123;NSLog(@"~~4~~%@", [NSThread currentThread]);&#125;];op3.completionBlock = ^&#123;NSLog(@"~~5~~%@", [NSThread currentThread]);&#125;;// 设置依赖[op1 addDependency:op2];[op1 addDependency:op3];[queue addOperation:op1];[queue addOperation:op2];[queue addOperation:op3];&#125; 3.线程间的通信123456789101112#pragma mark - NSOperation实现线程间的通信- (void)NSOperationTest2 &#123;[[[NSOperationQueue alloc] init] addOperationWithBlock:^&#123;NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://img.lanrentuku.com/img/allimg/1310/13822295641903.jpg"]];UIImage *image = [UIImage imageWithData:data];[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;self.imageview.image = image;&#125;];&#125;];&#125; 三、一些简单方法123456789101112// 取消单个操作[operation cancel];// 取消queue中所有的操作[queue cancelAllOperations];//设置队列的最大并发操作数量queue.maxConcurrentOperationCount = 1;// 会阻塞当前线程，等到某个operation执行完毕[operation waitUntilFinished];// 阻塞当前线程，等待queue的所有操作执行完毕[queue waitUntilAllOperationsAreFinished];// 暂停queue YES代表暂停队列,NO代表恢复队列[queue setSuspended:YES]; NSOperation 常用的基本上也就上面那些了。。。GCD 就不用多说了，老东家苹果推荐的，不过我却觉得名字太长~~~，一开始总是记不住，多敲就好了！所有编程语言大概都有这么一个绝招O(∩_∩)O！ （四）iOS开发之多线程 GCD一、GCD 术语要理解GCD ，我们先来熟悉与线程和并发相关的几个概念。 1.Serial vs. Concurrent 串行 vs. 并发任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。 2.同步（Synchronous）与异步（Asynchronous）同步，意味着在当前线程中执行任务，不具备开启新的线程的能力。异步，在新的线程中执行任务，具备开启新的线程的能力。 3.临界区（Critical Section）就是一段代码不能被并发执行，即两个线程不能同时执行这段代码。 4.死锁（Deadlock）停止等待事情的线程会导致多个线程相互维持等待，即死锁。 5.Thread Safe 线程安全线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃等）。 6.Queues 队列GCD 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 GCD 的任务并用 FIFO 顺序执行这些任务。 二、代码演示1、dispatch_async(异步函数)1234567891011121314151617181920212223242526272829303132333435363738//异步函数 + 并发队列:可以同时开启多条线程,任务是并行的// 1.创建并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);//2.将任务加入队列dispatch_async(queue, ^&#123;for (NSInteger i = 0 ; i &lt; 5; i ++) &#123;NSLog(@"%ld~~~~1~~~~%@", i, [NSThread currentThread]);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"%ld~~~2~~~%@", i, [NSThread currentThread]);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"%ld~~~~3~~~~%@", i, [NSThread currentThread]);&#125;&#125;);//异步函数 + 串行队列:会开启新的线程，但是任务是串行的，执行完一个任务，再执行下一个任务// 1.创建串行队列dispatch_queue_t queue = dispatch_queue_create("YMWM", DISPATCH_QUEUE_SERIAL);// 2.将任务加入队列dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5 ; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"2~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"2~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;); 2、dispatch_sync(同步函数)1234567891011121314151617181920212223242526272829303132333435363738//同步函数 + 并发队列:不会开启新的线程// 1.获得全局的并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 2.将任务加入队列dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"2~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"3~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);//同步函数 + 串行队列:不会开启新的线程// 1.创建串行队列dispatch_queue_t queue = dispatch_queue_create("YMWM", DISPATCH_QUEUE_SERIAL);// 2.将任务加入队列dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"2~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"3~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;); 3.两者在主队列中的应用12345678910111213141516171819202122232425262728293031323334//异步函数 + 主队列：只在主线程中执行任务dispatch_queue_t queue = dispatch_get_main_queue();dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"2~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_async(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"3~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);//同步函数 + 主队列：死循环dispatch_queue_t queue = dispatch_get_main_queue();dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;);dispatch_sync(queue, ^&#123;for (NSInteger i = 0; i &lt; 5; i ++) &#123;NSLog(@"1~~~%@~~~~~%ld", [NSThread currentThread], i);&#125;&#125;); 4、dispatch_group_async的使用12345678910111213141516171819202122dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);// 创建一个队列组dispatch_group_t group = dispatch_group_create();dispatch_group_async(group, queue, ^&#123;//添加操作...[NSThread sleepForTimeInterval:1];NSLog(@"1%@", [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123;//添加操作...[NSThread sleepForTimeInterval:1];NSLog(@"2%@", [NSThread currentThread]);&#125;);dispatch_group_async(group, queue, ^&#123;//添加操作...[NSThread sleepForTimeInterval:1];NSLog(@"3%@", [NSThread currentThread]);&#125;);// 回到主线程dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@"回到主线程刷新UI");&#125;); 5、dispatch_barrier_async的使用12345678910111213141516171819dispatch_queue_t queue = dispatch_queue_create("YMWM", DISPATCH_QUEUE_CONCURRENT);dispatch_async(queue, ^&#123;[NSThread sleepForTimeInterval:.5];NSLog(@"1%@", [NSThread currentThread]);&#125;);dispatch_async(queue, ^&#123;[NSThread sleepForTimeInterval:.5];NSLog(@"2%@", [NSThread currentThread]);&#125;);dispatch_barrier_async(queue, ^&#123;NSLog(@"barrier --- %@", [NSThread currentThread]);[NSThread sleepForTimeInterval:.5];&#125;);dispatch_async(queue, ^&#123;NSLog(@"3%@", [NSThread currentThread]);&#125;);dispatch_async(queue, ^&#123;NSLog(@"4%@", [NSThread currentThread]);&#125;); 6、dispatch_apply的使用12345//执行某个代码片段10次dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_apply(10, queue, ^(size_t index) &#123;NSLog(@"%@", [NSThread currentThread]);&#125;); 7、dispatch_once_t的使用第一个参数predicate，该参数是检查后面第二个参数所代表的代码块是否被调用的谓词，第二个参数则是在整个应用程序中只会被调用一次的代码块1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;NSLog(@"%@", [NSThread currentThread]);&#125;); 8.dispatch_after的使用1234567- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;NSLog(@"-------");//延迟执行，较为精确dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;NSLog(@"~~~~~~");&#125;);&#125; 9.线程间的通信1234567891011#pragma mark - GCD-线程间的通信- (void)downloadImage &#123;NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://img.lanrentuku.com/img/allimg/1310/13822295641903.jpg"]];UIImage *image = [UIImage imageWithData:data];dispatch_async(dispatch_get_main_queue(), ^&#123;self.imageview.image = image;&#125;);&#125; 10.文件剪切1234567891011121314151617181920212223242526272829//第一种方式//将文件从from剪切至toNSString *from = @"/Users/iOS/Desktop/Test";NSString *to = @"/Users/iOS/Desktop/test1";NSFileManager *mgr = [NSFileManager defaultManager];NSArray *subpaths = [mgr subpathsAtPath:from];for (NSString *subpath in subpaths) &#123;NSString *fromFullpath = [from stringByAppendingPathComponent:subpath];NSString *toFullpath = [to stringByAppendingPathComponent:subpath];dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;//剪切[mgr moveItemAtPath:fromFullpath toPath:toFullpath error:nil];&#125;);&#125;//第二种方式//将文件从from剪切至todispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);NSString *from = @"/Users/iOS/Desktop/Test";NSString *to = @"/Users/iOS/Desktop/test1";NSFileManager *mag = [NSFileManager defaultManager];NSArray *subpaths = [mag subpathsAtPath:from];dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;NSString *subpath = subpaths[index];NSString *fromFullpath = [from stringByAppendingPathComponent:subpath];NSString *toFullpath = [to stringByAppendingPathComponent:subpath];// 剪切[mag moveItemAtPath:fromFullpath toPath:toFullpath error:nil];NSLog(@"%@~~~~~~%@", [NSThread currentThread], subpath);&#125;); 三、GCD与非GCD实现单粒设计模式1.GCD实现设计模式类的.h文件123@interface PKPerson : NSObject+ (instancetype)sharedCar;@end 类的.m文件12345678910111213141516171819202122232425262728293031323334@interface PKPerson() &lt;NSCopying&gt;@end@implementation PKPerson// 实例变量，当前类static id _instance;// 重写allocWithZone方法+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;static dispatch_once_t onceToken;// 该方法整个应用程序只调用一次dispatch_once(&amp;onceToken, ^&#123;_instance = [super allocWithZone:zone];&#125;);return _instance;&#125;+ (instancetype)sharedInstance&#123;static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;_instance = [[self alloc] init];&#125;);return _instance;&#125;// 保证每复制一个对象也是同一内存空间- (id)copyWithZone:(NSZone *)zone&#123;return _instance;&#125;@end 2.宏定义封装GCD单粒设计模式通常当多个类之间有相同的属性和方法时，我们会考虑将相同的部分抽取出来，封装到父类中，但单粒模式不可以这样做，因为单粒模式采用继承方式的话，所有的类会共享一份内存。所以一般采取宏定义封装GCD单粒设计模式。注意，每行的结尾需要添加 “\”。1234567891011121314151617181920212223242526272829// .h文件#define PKSingletonH + (instancetype)sharedInstance;// .m文件#define PKSingletonH \static id _instace; \\+ (instancetype)allocWithZone:(struct _NSZone *)zone \&#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken, ^&#123; \_instace = [super allocWithZone:zone]; \&#125;); \return _instace; \&#125; \\+ (instancetype)sharedInstance \&#123; \static dispatch_once_t onceToken; \dispatch_once(&amp;onceToken, ^&#123; \_instace = [[self alloc] init]; \&#125;); \return _instace; \&#125; \\- (id)copyWithZone:(NSZone *)zone \&#123; \return _instace; \&#125; 3.非GCD实现设计模式类的.h文件 12345@interface PKPerson : NSObject+ (instancetype)sharedInstance;@end 类的.m文件123456789101112131415161718192021222324252627282930313233343536#import "PKPerson.h"@interface PKPerson()@end@implementation PKPersonstatic id _instance;+ (instancetype)allocWithZone:(struct _NSZone *)zone&#123;// 同步锁，防止多线程同时进入@synchronized(self) &#123;if (_instance == nil) &#123;_instance = [super allocWithZone:zone];&#125;&#125;return _instance;&#125;+ (instancetype)sharedInstance&#123;@synchronized(self) &#123;if (_instance == nil) &#123;_instance = [[self alloc] init];&#125;&#125;return _instance;&#125;- (id)copyWithZone:(NSZone *)zone&#123;return _instance;&#125;@end 四、GCD定时器12345678910111213141516171819202122232425262728@interface ViewController ()/** 定时器(这里不用带*，因为dispatch_source_t就是个类，内部已经包含了*) */@property (nonatomic, strong) dispatch_source_t timer;@end@implementation ViewController- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;// 获得队列dispatch_queue_t queue = dispatch_get_main_queue();// 创建一个定时器(dispatch_source_t本质还是个OC对象)self.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);// GCD的时间参数一般是纳秒（1秒 == 10的9次方纳秒）dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);dispatch_source_set_timer(self.timer, start, interval, 0);// 设置回调dispatch_source_set_event_handler(self.timer, ^&#123;NSLog(@"------%@-------", [NSThread currentThread]);&#125;);// 启动定时器dispatch_resume(self.timer);&#125; 三种多线程编程都说完了，代码有些多，不过希望朋友们有所收获，另外再补充一些关于线程间通信的。。。 （五）iOS开发之多线程 线程间的通信一、简单介绍在一个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信。以下是线程之间进行通信的方法: 二、常用方法:代码1:performSelectorperformSelector常用方法的常用方法主要有以下几种:12345678//在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];//在当前线程执行操作[self performSelector:@selector(run) withObject:nil];//在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; 具体代码:12345678910111213141516171819202122232425262728293031//点击屏幕开始执行以下方法- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event &#123;[self performSelectorInBackground:@selector(download) withObject:nil];&#125;- (void)download&#123;// 图片的网络路径NSURL *url = [NSURL URLWithString:@"http://img.lanrentuku.com/img/allimg/1310/13822295641903.jpg"];// 根据地址加载图片NSData *data = [NSData dataWithContentsOfURL:url]; //耗时操作// 生成图片UIImage *image = [UIImage imageWithData:data];// 回到主线程，刷新UI界面//方式一[self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:NO];//方式二// [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:NO];//方式三// [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:NO];&#125;//显示图片(如果performSelector调用的是setImage:方法，会直接调用系统的方法)//- (void)showImage:(UIImage *)image//&#123;// self.imageView.image = image;//&#125; 代码2:NSOperationQueue方式一个NSOperation对象可以通过调用start方法来执行任务,默认是同步执行的.也可以将NSOperation添加到一个NSOperationQueue中去执行,而且是异步执行的. 12345678910#pragma mark - NSOperation实现线程间的通信- (void)NSOperationTest &#123;[[[NSOperationQueue alloc] init] addOperationWithBlock:^&#123;NSData *data = [NSData dataWithContentsOfURL:[NSURL URLWithString:@"http://img.lanrentuku.com/img/allimg/1310/13822295641903.jpg"]];UIImage *image = [UIImage imageWithData:data];[[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;self.imageView.image = image;&#125;];&#125;];&#125; 代码3:GCD方式GCD，全称Grand Central Dispath，是苹果开发的一种支持并行操作的机制。它的主要部件是一个FIFO队列和一个线程池，前者用来添加任务，后者用来执行任务。 12345678910111213141516dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;// 图片的网络路径NSURL *url = [NSURL URLWithString:@"http://img.lanrentuku.com/img/allimg/1310/13822295641903.jpg"];// 加载图片NSData *data = [NSData dataWithContentsOfURL:url];// 生成图片UIImage *image = [UIImage imageWithData:data];// 回到主线程显示图片dispatch_async(dispatch_get_main_queue(), ^&#123;self.imageView.image = image;&#125;);&#125;); 三、NSPort方法:NSPort有3个子类，NSSocketPort、NSMessagePort、NSMachPort，但在iOS下只有NSMachPort可用。代码如下: UIViewController中的代码: 12345678910111213141516171819202122232425262728293031#import "ViewController.h"#import "MyPort.h"@interface ViewController () &lt;NSPortDelegate&gt;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];//创建主线程的portNSPort *myPort = [NSPort port];//设置代理myPort.delegate = self;//把port加入runloop[[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];//启动子线程,并传入主线程的portMyPort *work = [[MyPort alloc] init];[NSThread detachNewThreadSelector:@selector(launchThreadWithPort:)toTarget:workwithObject:myPort];&#125;- (void)handlePortMessage:(NSMessagePort*)message&#123;NSLog(@"已接到子线程的消息 --- %@", message);&#125;@end MyPort中的代码: .h文件:12345#import &lt;Foundation/Foundation.h&gt;@interface MyPort : NSPort@end .m文件:1234567891011121314151617181920212223242526272829303132333435363738394041424344#import "MyPort.h"#define PKMessage 10@interface MyPort ()&lt;NSMachPortDelegate&gt; &#123;NSPort *firstPort;NSPort *secondPort;&#125;@end@implementation MyPort- (void)launchThreadWithPort:(NSPort *)port &#123;@autoreleasepool &#123;//接收主线程传入的port//设置子线程名字[[NSThread currentThread] setName:@"MyThread"];//开启runloop[[NSRunLoop currentRunLoop] run];//创建自己portsecondPort = [NSPort port];secondPort.delegate = self;//将自己的port添加到runloop,防止runloop执行完毕之后退出,接收主线程发送过来的port消息[[NSRunLoop currentRunLoop] addPort:secondPort forMode:NSDefaultRunLoopMode];//完成向主线程发送消息[self sendPortMessage];&#125;&#125;/*** 完成向主线程发送消息*/- (void)sendPortMessage &#123;//发送消息到主线程[firstPort sendBeforeDate:[NSDate date]msgid:PKMessagecomponents:nilfrom:secondPortreserved:0];&#125; 提示:通常来说, NSPort可以做的事情通过performSelector也同样可以搞定，因此线程间通信完全可以通过performSelector来实现。 结束语：以上是多线程相关的知识总结，本人也是小白级别，如果有写错的地方，还请朋友们能够指出来，谢谢！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 二维码]]></title>
    <url>%2F2017%2F06%2F28%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[在我们的日常生活中，二维码扫描越来越常见，比如支付宝支付扫描、微信支付扫描、信息获取等等，所以简单的整理了二维码相关的知识，总共分为两部分：生成二维码；扫描二维码。 一、生成二维码 简单的生成二维码，先看效果图如图所示，这个效果不太好，有些模糊 生成简单二维码的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &quot;ViewController.h&quot;// 需要导入此框架#import &lt;CoreImage/CoreImage.h&gt;@interface ViewController ()@property (nonatomic, strong) UIImageView *imageView;@end@implementation ViewController- (UIImageView *)imageView &#123;if (!_imageView) &#123;_imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];_imageView.center = self.view.center;[self.view addSubview:_imageView];&#125;return _imageView;&#125;- (void)viewDidLoad &#123;[super viewDidLoad];[self creatQRCode];&#125;// 生成二维码- (void)creatQRCode &#123;// 创建二维码滤镜CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;];// 恢复滤镜的默认属性[filter setDefaults];// 给过滤器添加数据（纯文本，URL都可以）// NSString *dataString = @&quot;http://www.baidu.com&quot;;NSString *dataString = @&quot;生成二维码&quot;;// 将字符串转换成NSDataNSData *data = [dataString dataUsingEncoding:NSUTF8StringEncoding];// 设置滤镜 inputMessage 数据[filter setValue:data forKeyPath:@&quot;inputMessage&quot;];CIImage *outputImage = [filter outputImage];UIImage *image = [UIImage imageWithCIImage:outputImage];// 把生成的二维码显示在 imageview 上self.imageView.image = image;&#125; 生成清晰二维码 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#import &quot;ViewController.h&quot;#import &lt;CoreImage/CoreImage.h&gt;@interface ViewController ()@property (nonatomic, strong) UIImageView *imageView;@end@implementation ViewController- (UIImageView *)imageView &#123;if (!_imageView) &#123;_imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];_imageView.center = self.view.center;[self.view addSubview:_imageView];&#125;return _imageView;&#125;- (void)viewDidLoad &#123;[super viewDidLoad];[self creatQRCode];&#125;// 生成二维码- (void)creatQRCode &#123;// 创建二维码滤镜CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;];// 恢复滤镜的默认属性[filter setDefaults];// 给过滤器添加数据（纯文本，URL都可以）// NSString *dataString = @&quot;http://www.baidu.com&quot;;NSString *dataString = @&quot;生成二维码&quot;;// 将字符串转换成NSDataNSData *data = [dataString dataUsingEncoding:NSUTF8StringEncoding];// 设置滤镜 inputMessage 数据[filter setValue:data forKeyPath:@&quot;inputMessage&quot;];// 获取滤镜输出的二维码CIImage *outputImage = [filter outputImage];// 显示二维码self.imageView.image = [self creatClearImageFromCIImage:outputImage withSize:200];&#125;- (UIImage *)creatClearImageFromCIImage:(CIImage *)image withSize:(CGFloat) size&#123;CGRect extent = CGRectIntegral(image.extent);CGFloat scale = MIN(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent));size_t width = CGRectGetWidth(extent) * scale;size_t height = CGRectGetHeight(extent) * scale;// 创建灰度色调空间CGColorSpaceRef colorSpaceRef = CGColorSpaceCreateDeviceGray();CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpaceRef, (CGBitmapInfo)kCGImageAlphaNone);CIContext *context = [CIContext contextWithOptions:nil];CGImageRef bitmapImage = [context createCGImage:image fromRect:extent];CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);CGContextScaleCTM(bitmapRef, scale, scale);CGContextDrawImage(bitmapRef, extent, bitmapImage);// 保存图片CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);CGContextRelease(bitmapRef);CGImageRelease(bitmapImage);return [UIImage imageWithCGImage:scaledImage];&#125; 二、扫描二维码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &quot;ViewController.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;@interface ViewController () &lt;AVCaptureMetadataOutputObjectsDelegate&gt;@property (nonatomic, strong) AVCaptureSession *session;@property (nonatomic, strong) AVCaptureVideoPreviewLayer *layer;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 创建拍摄会话self.session = [[AVCaptureSession alloc] init];// 添加输入设备AVCaptureDevice *device = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:device error:nil];[self.session addInput:input];// 添加输出数据AVCaptureMetadataOutput *output = [[AVCaptureMetadataOutput alloc] init];[output setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()];[self.session addOutput:output];// 设置输入元数据的类型[output setMetadataObjectTypes:@[AVMetadataObjectTypeQRCode]];// 添加扫描图层self.layer = [AVCaptureVideoPreviewLayer layerWithSession:self.session];self.layer.frame = self.view.bounds;[self.view.layer addSublayer:self.layer];// 启动会话[self.session startRunning];&#125;#pragma mark - 扫描到数据就会执行该代理方法- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection&#123;if (metadataObjects.count &gt; 0) &#123;// 提示：如果需要对url或者文本等信息进行扫描，可以在此进行扩展AVMetadataMachineReadableCodeObject *object = [metadataObjects lastObject];NSLog(@&quot;%@&quot;, object.stringValue);// 如果扫描完成，停止会话[self.session stopRunning];// 删除预览图层[self.layer removeFromSuperlayer];&#125; else &#123;NSLog(@&quot;没有扫描到数据&quot;);&#125;&#125; 最后说几个二维码相关的注意点： 注意点：二维码都有一定的容错部分，意思就是有部分污损或者破损都没有关系，照常识别。但是也是有限度的，这根据生成时使用的纠错级别而定，可以有7％~30％左右的损坏。 二维码使用基本原则：1、三个角上的“回”及“回”字周围的底色不要动2、中间部分和不带“回”字的一角是可以填图片的（中间最好）3、如果中间有小的“回”字，能不变就不变，能少变就少变4、尽可能放大二维码后再添加图片，不要添加图片后放大5、生成时尽量选择较高的纠错级别]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 广告植入]]></title>
    <url>%2F2017%2F06%2F21%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%B9%BF%E5%91%8A%E6%A4%8D%E5%85%A5%2F</url>
    <content type="text"><![CDATA[应用中植入广告是iOS开发者获得收益的方式之一，其实有很多 app 的绝大部分盈利都来自于广告收入……下面就开始介绍两种主流的植入广告的方法：iAd 方式和 Admob方式。 一、iAd 方式 iAd 方式简介iAd 移动广告业务是乔布斯在2010年推出来的，怀念～～～刚开始的时候，iAd 的确有很大的发展，但是随着时间的推移，更是在老乔辞世😢之后，iAd 的使用人数便越来越少。以至于今年年初，苹果公司宣布将要放弃在 iAd 平台上直接出售广告，而是将其转交给出版商。。。但是作为 iOS 开发者的我们，还是有了解的必要， iAd 广告平台依在。 使用步骤如下： 1.1 导入iAd.framework 依赖库 1.2 方便起见，我是在 Main.storyboard 中拉入ADBannerView 1.3 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &quot;ViewController.h&quot;#import &lt;iAd/iAd.h&gt;@interface ViewController () &lt;ADBannerViewDelegate&gt;@property (weak, nonatomic) IBOutlet NSLayoutConstraint *bannerViewBottom;@property (nonatomic,strong)ADBannerView *bannerView;@end@implementation ViewController- (void)viewDidLoad&#123;[super viewDidLoad];&#125;#pragma mark - ADBannerViewDelegate 协议一共有五个方法// 广告即将被加载- (void)bannerViewWillLoadAd:(ADBannerView *)banner&#123;NSLog(@&quot;bannerViewWillLoadAd&quot;);&#125;// 广告已被加载- (void)bannerViewDidLoadAd:(ADBannerView *)banner&#123;NSLog(@&quot;bannerViewDidLoadAd&quot;);self.bannerViewBottom.constant = 0;[UIView animateWithDuration:0.5 animations:^&#123;[self.view layoutIfNeeded];&#125;];&#125;// 是否出现全屏的广告- (BOOL)bannerViewActionShouldBegin:(ADBannerView *)banner willLeaveApplication:(BOOL)willLeave &#123;// return YES: 用户点击 Banner 之后，会出现全屏广告// 如果返回的是 NO，用户点击 Banner 之后, 不会出现全屏广告// 另外如果返回 YES， 用户其它的活动都会被暂停return YES;&#125;// 全屏的广告退出时调用，用户其它的活动都会被唤醒- (void)bannerViewActionDidFinish:(ADBannerView *)banner &#123;NSLog(@&quot;bannerViewActionDidFinish&quot;);&#125;// 如果 app 上没有广告，就会调用这个方法- (void)bannerView:(ADBannerView *)banner didFailToReceiveAdWithError:(NSError *)error&#123;NSLog(@&quot;didFailToReceiveAdWithError&quot;);&#125;@end 二、Admob方式 Admob方式简介Admob 是 Google 推出的，用的人比较多，它提供了目前为止最方便的 iPhone app 广告集成库。 下面说一下它的基本使用～～～ 2.1 首先需要注册Admob、设置账户信息、创建应用等等，这里不再详细介绍，如果有朋友需要可以借鉴这篇文章。 2.2 集成Admob SDK.2.21 下载Admob SDK：Admob SDK2.22 下载完成后，将这两个文件导入项目： 2.23 添加依赖库 2.24 导入头文件注意需要导入的事这两个头文件！12#import &quot;GoogleMobileAds/GADInterstitial.h&quot;#import &quot;GoogleMobileAds/GADBannerView.h&quot; 2.3 代码实现 在屏幕底部植入广告 1234567891011121314151617181920212223242526272829303132#import &quot;ViewController.h&quot;#import &quot;GoogleMobileAds/GADInterstitial.h&quot;#import &quot;GoogleMobileAds/GADBannerView.h&quot;@interface ViewController ()&#123;GADBannerView *bannerView;&#125;@endstatic NSString *MyId = @&quot;********&quot;;@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 在屏幕底部创建标准尺寸的视图bannerView = [[GADBannerView alloc] initWithFrame:CGRectMake(0.0, self.view.frame.size.height -GAD_SIZE_320x50.height, GAD_SIZE_320x50.width, GAD_SIZE_320x50.height)];bannerView.backgroundColor = [UIColor redColor];// 指定广告的标识符bannerView.adUnitID = MyId;// 转至广告的展示位置之后恢复哪个 UIViewControllerbannerView.rootViewController = self;[self.view addSubview:bannerView];// 请求并加载广告[bannerView loadRequest:[GADRequest request]];&#125;@end 也可以在屏幕顶部植入广告 1234567891011121314151617181920212223242526272829#import &quot;ViewController.h&quot;#import &quot;GoogleMobileAds/GADInterstitial.h&quot;#import &quot;GoogleMobileAds/GADBannerView.h&quot;@interface ViewController ()&#123;GADBannerView *bannerView;&#125;@endstatic NSString *MyId = @&quot;********&quot;;@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 导航栏位置添加广告float y =self.navigationController.navigationBar.frame.size.height + [[UIApplication sharedApplication] statusBarFrame].size.height;float x = ([UIScreen mainScreen].bounds.size.width - 320) / 2;bannerView=[[GADBannerView alloc]initWithAdSize:kGADAdSizeBanner origin:CGPointMake(x, y)];bannerView.adUnitID = MyId;bannerView.backgroundColor = [UIColor redColor];bannerView.rootViewController = self;[self.view addSubview:bannerView];GADRequest *request = [GADRequest request];request.testDevices = @[MyId,MyId];[bannerView loadRequest:request];&#125; 当然，你可以在任何你希望的地方植入广告，大家可以试试的😊！以后要是用的多了，我会继续在这里补充，另外如果代码书写有误，还请大家能够指出来！互相交流学习！谢谢！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>广告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 好玩的富文本]]></title>
    <url>%2F2017%2F06%2F16%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%AF%8C%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[周末闲着没事，就想着不如把那些容易遗忘的知识点整理一下，一来可以让有需要的朋友少走弯路，二来自己以后再忘记的时候也可以回头看看……但 iOS 中小冷易忘的知识点实在太多了，不知道该从哪里开始整理，“百无聊赖”逛了下淘宝，发现里面好多都是富文本，就想着为什么不从富文本开始呢？反正闲着也是闲着……于是就有了下面这些东西，希望可以帮到看到的盆友们！ 先写一个小引子 在项目中，很多时候我们都需要把文字设置成倾斜、加粗、加下划线、加删除线、加阴影等等状态，就比如下面这张图： 但如果我们只是简单的设置字体1self.textView.text = @&quot;很好玩的富文本&quot;; 显示出来大概是这个样子滴： 为了让文字变的好看一些，接下来我们尝试一下富文本！ 改变字体颜色 123456NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(1, 2)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(3, 1)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(4, 3)];self.textView.attributedText = string; 改变字体大小 1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:20] range:NSMakeRange(1, 2)];[string addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:30] range:NSMakeRange(4, 3)];self.textView.attributedText = string; 给文字添加背景色1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSBackgroundColorAttributeName value:[UIColor cyanColor] range:NSMakeRange(1, 2)];[string addAttribute:NSBackgroundColorAttributeName value:[UIColor yellowColor] range:NSMakeRange(4, 3)];self.textView.attributedText = string; 给文字设置间距123NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSKernAttributeName value:@(20) range:NSMakeRange(0, 6)];self.textView.attributedText = string; 字体倾斜123NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSObliquenessAttributeName value:@(0.5) range:NSMakeRange(0, 7)];self.textView.attributedText = string; 字体加粗123NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSExpansionAttributeName value:@(0.5) range:NSMakeRange(4, 3)];self.textView.attributedText = string; 加下划线并设置下划线颜色1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSUnderlineStyleAttributeName value:@(1) range:NSMakeRange(4, 3)];[string addAttribute:NSUnderlineColorAttributeName value:[UIColor blueColor] range:NSMakeRange(4, 3)];self.textView.attributedText = string; 加删除线并设置删除线颜色1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;原价666💰，现价只要66💰！&quot;];[string addAttribute:NSStrikethroughStyleAttributeName value:@(1) range:NSMakeRange(2, 3)];[string addAttribute:NSStrikethroughColorAttributeName value:[UIColor blueColor] range:NSMakeRange(2, 3)];self.textView.attributedText = string; 设置文字方向1234NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSVerticalGlyphFormAttributeName value:@(1) range:NSMakeRange(0, 7)];[string addAttribute:NSWritingDirectionAttributeName value:@[@(2),@(3)] range:NSMakeRange(0, 7)];self.textView.attributedText = string; 给文字添加阴影1234567NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];NSShadow *shadow = [[NSShadow alloc]init];shadow.shadowOffset = CGSizeMake(5, 5);shadow.shadowColor = [UIColor blueColor];shadow.shadowBlurRadius = 1;[string addAttribute:NSShadowAttributeName value:shadow range:NSMakeRange(4, 3)];self.textView.attributedText = string; 图文混排 12345678NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];// 创建图片图片附件NSTextAttachment *attach = [[NSTextAttachment alloc] init];attach.image = [UIImage imageNamed:@&quot;1.jpg&quot;];attach.bounds = CGRectMake(0, 0, 20, 20);NSAttributedString *attachString = [NSAttributedString attributedStringWithAttachment:attach];[string appendAttributedString:attachString];self.textView.attributedText = string; 文字偏移1234567NSMutableAttributedString *string = [[NSMutableAttributedString alloc] initWithString:@&quot;很好玩的富文本&quot;];[string addAttribute:NSBaselineOffsetAttributeName value:@(10) range:NSMakeRange(0, 1)];[string addAttribute:NSBaselineOffsetAttributeName value:@(20) range:NSMakeRange(1, 1)];[string addAttribute:NSBaselineOffsetAttributeName value:@(30) range:NSMakeRange(2, 1)];[string addAttribute:NSBaselineOffsetAttributeName value:@(40) range:NSMakeRange(3, 1)];[string addAttribute:NSBaselineOffsetAttributeName value:@(50) range:NSMakeRange(4, 3)];self.textView.attributedText = string; 以上是对 iOS 中富文本相关的知识做的一些整理，如果有粗心写错的地方，还请朋友们指出！如果还有遗漏的地方，以后碰到了再来补充。。。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>富文本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔记 - Webstorm常用快捷键]]></title>
    <url>%2F2017%2F06%2F16%2F%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20-%20Webstorm%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[需要做一些前端的东西，……朋友推荐了 Webstorm 编辑器，据说很不错，在开始码代码之前，想着如果要提高效率，那掌握一些常用的快捷键应该是少不了的，于是就查了一下，整理出来。用的是 Mac 系统，而在 Windows 系统上，command 即 Ctrl。 一、必备快捷键 command+/：注释当前行 command+Shift+/：当前位置插入注释 command+Alt+/：块注释，并Focus到首行，写注释说明用的 command+Shift+A：选择当前标签前后，修改标签用的 F11：全屏 Shift+F11：全屏免打扰模式，只编辑当前文件 Alt+F3：选择所有相同的词 Alt+.：闭合标签 Alt+Shift+数字：分屏显示 Alt+数字：切换打开第N个文件 Shift+右键拖动：光标多不，用来更改或插入列内容 鼠标的前进后退键可切换Tab文件 按 command，依次点击或选取，可需要编辑的多个位置 按 command+Shift+上下键，可替换行 command+Shift+P：打开命令面板 command+P：搜索项目中的文件 command+G：跳转到第几行 command+W：关闭当前打开文件 command+Shift+W：关闭所有打开文件 command+Shift+V：粘贴并格式化 command+D：选择单词，重复可增加选择下一个相同的单词 command+L：选择行，重复可依次增加选择下一行 command+Shift+L：选择多行 command+Shift+Enter：在当前行前插入新行 command+X：删除当前行 command+M：跳转到对应括号 command+U：软撤销，撤销光标位置 command+J：选择标签内容 command+F：查找内容 command+Shift+F：查找并替换 command+H：替换 command+R：前往 method command+N：新建窗口 command+K+B：开关侧栏 command+Shift+M：选中当前括号内容，重复可选着括号本身 command+F2：设置/删除标记 二、选择类快捷键 command+← 向左单位性地移动光标，快速移动光标。 command+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 command+Shift+← 向左单位性地选中文本。 command+Shift+→ 向右单位性地选中文本。 command+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 command+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 command+Alt+↑ 向上添加多行光标，可同时编辑多行。 command+Alt+↓ 向下添加多行光标，可同时编辑多行。 command+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 command+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 command+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 command+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 command+M 光标移动至括号内结束或开始的位置。 command+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 command+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 command+Shift+[ 选中代码，按下快捷键，折叠代码。 command+Shift+] 选中代码，按下快捷键，展开代码。 command+K+0 展开所有折叠代码。 三、编辑类快捷键 command+K+K 从光标处开始删除代码至行尾。 command+Shift+K 删除整行。 command+/ 注释单行。 command+Shift+/ 注释多行。 command+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 command+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 command+K+U 转换大写。 command+K+L 转换小写。 command+Z 撤销。 command+Y 恢复撤销。 command+U 软撤销，感觉和 Gtrl+Z 一样。 command+F2 设置书签 command+T 左右字母互换。 F6 单词检测拼写 四、搜索类快捷键 command+F 打开底部搜索框，查找关键字。 command+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 command+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 command+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 command+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 command+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 command+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 五、显示类快捷键 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 command+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 command+PageDown 向左切换当前窗口的标签页。 command+PageUp 向右切换当前窗口的标签页。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端笔记 - HTML 特殊标签实现文字滚动]]></title>
    <url>%2F2017%2F06%2F09%2F%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0%20-%20HTML%20%E7%89%B9%E6%AE%8A%E6%A0%87%E7%AD%BE%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[想用 HTML 做个文字滚动效果，可以用特殊标签 marquee 实现，当然也可以用 JS 实现， 今天试了下用特殊标签 marquee 实现文字滚动。先声明下本人从事于 iOS 开发，之前零零星星的学过 HTML ，但目前尚处于小白阶段😂，因此文章如果有不当之处还请各位大神不吝指出！ 先一起看下 marquee 标签存在哪些属性： behavior：滚动方式，三种：scroll（循环滚动） slide（单次滚动）、alternate（来回滚动） bgcolor：滚动文本框的背景颜色 direction：滚动方向，四种：left（从右到左）、right（从左到右）、up（从下到上）、down（从上到下） scrolldelay：每轮滚动之间的延迟时间，数字越大滚动越慢 scrollamount：一次滚动总的时间量，数字越小滚动越慢 align：文字的对齐方式，三种： middle(居中)、bottom(居下)、top(居上) width：滚动文本框的宽度 height：滚动文本框的高度 loop：滚动次数，默认为 infinite（无限） hspace：水平方向的空白距离 vspace：垂直方向的空白距离 下面便是 marquee 属性的一些应用一、滚动方式 behavior ：scroll（循环滚动）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;right&quot;behavior=&quot;scroll&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 二、滚动方式 behavior：alternate（来回滚动）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;right&quot;behavior=&quot;alternate&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 三、滚动方向 direction：up（从下到上）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;up&quot;behavior=&quot;scroll&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 四、滚动方向 direction：left（从右到左）1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 五、滚动速度（scrollamount）123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;scrollamount=&quot;80px&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 六、循环次数（loop）12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;scrollamount=&quot;80px&quot;loop=&quot;5&quot;&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 七、当鼠标停留在文字上，文字停止滚动1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;scrollamount=&quot;80px&quot;onmouseover=stop()onmouseout=start()&gt;&lt;br&gt;金风玉露一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 八、给滚动字幕加超链接1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;scrollamount=&quot;80px&quot;onmouseover=stop()onmouseout=start()&gt;&lt;br&gt;&lt;a href=#&gt;金风玉露&lt;/a&gt;一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 九、综合其它属性123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;marquee direction=&quot;left&quot;behavior=&quot;scroll&quot;scrollamount=&quot;30&quot;scrolldelay=&quot;0&quot;loop=&quot;-1&quot;width=&quot;500&quot;height=&quot;100&quot;bgcolor=&quot;#FFCCFF&quot;hspace=&quot;30&quot;vspace=&quot;10&quot;onmouseover=this.stop()onmouseout=start()&gt;&lt;br&gt;&lt;a href=#&gt;金风玉露&lt;/a&gt;一相逢, 便胜却人间无数.&lt;br&gt;两情若是久长时, 又岂在朝朝暮暮.&lt;br&gt;&lt;/marquee&gt;&lt;/body&gt;&lt;/html&gt; 小结：试了 HTML 实现文字滚动效果之后，发现比 iOS 简单方便许多，以后在工作之余会多学学前端知识，求大神带哈😀！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端学习</tag>
        <tag>文字滚动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 毛玻璃&模糊视图&滤镜]]></title>
    <url>%2F2017%2F05%2F19%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E6%AF%9B%E7%8E%BB%E7%92%83%26%E6%A8%A1%E7%B3%8A%E8%A7%86%E5%9B%BE%26%E6%BB%A4%E9%95%9C%2F</url>
    <content type="text"><![CDATA[为了让界面更加美观，有时候我们需要将图片设置成模糊，比如下边这张图片： 这篇文章主要演示了三种模糊效果，如下： 一、简单的毛玻璃效果： 原图 毛玻璃效果 代码如下： 123456789101112131415161718192021222324#import &quot;ViewController.h&quot;#import &lt;CoreImage/CoreImage.h&gt;@interface ViewController ()@property (nonatomic, strong) UIImageView *imageView;@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];self.imageView = [[UIImageView alloc]initWithFrame:self.view.frame];self.imageView.image = [UIImage imageNamed:@&quot;1.jpg&quot;];self.imageView.contentMode = UIViewContentModeScaleAspectFill;[self.view addSubview:self.imageView];UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];button.frame = CGRectMake(0, self.view.frame.size.height - 80, self.view.frame.size.width, 40);[button setTitle:@&quot;蒙奇·D·路飞&quot; forState:UIControlStateNormal];button.backgroundColor = [UIColor brownColor];[button addTarget:self action:@selector(&quot;点击调用的方法&quot;) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:button];&#125; button 被点击时调用以下代码：1234567891011121314151617181920self.imageView = [[UIImageView alloc] initWithFrame:self.view.frame];self.imageView.image = [UIImage imageNamed:@&quot;1.jpg&quot;];UIBlurEffect *blur = [UIBlurEffect effectWithStyle:UIBlurEffectStyleLight];UIVisualEffectView *visualEffectView = [[UIVisualEffectView alloc] initWithEffect:blur];visualEffectView.frame = self.view.frame;[self.imageView addSubview:visualEffectView];UIVibrancyEffect *vibrancyEffect = [UIVibrancyEffect effectForBlurEffect:blur];UIVisualEffectView *ano = [[UIVisualEffectView alloc] initWithEffect:vibrancyEffect];ano.frame = self.view.frame;UILabel *label = [[UILabel alloc] init];label.font = [UIFont systemFontOfSize:40];label.frame = CGRectMake(0, self.view.frame.size.height - 120, self.view.frame.size.width, 80);label.textAlignment = NSTextAlignmentCenter;label.text = @&quot;蒙奇·D·路飞&quot;;[visualEffectView.contentView addSubview:ano];[ano.contentView addSubview:label];[self.view addSubview:self.imageView]; 二、高斯模糊运动模糊等，先看效果图： 原图 运动模糊效果图 代码如下 viewDidLoad 中的代码和“简单的毛玻璃效果”中的 viewDidLoad 是一样的，这里只简单贴出 button 被点击调用的代码12345678910111213CIImage *inputImage = [CIImage imageWithCGImage:self.imageView.image.CGImage];// CIGaussianBlur 高斯模糊// CIBoxBlur 均值模糊// CIDiscBlur 环形卷积模糊// CIMotionBlur 运动模糊CIFilter *filter = [CIFilter filterWithName:@&quot;CIMotionBlur&quot;];[filter setValue:inputImage forKey:kCIInputImageKey];[filter setValue:@5 forKey:kCIInputRadiusKey];CIContext *context = [CIContext contextWithOptions:nil];CIImage *outupImage = filter.outputImage;CGImageRef imageRef = [context createCGImage:outupImage fromRect:outupImage.extent];self.imageView.image= [UIImage imageWithCGImage:imageRef]; 三、滤镜效果，先看下效果图 原图 “怀旧”效果图 代码如下 viewDidLoad 中的代码和“简单的毛玻璃效果”中的 viewDidLoad 是一样的，这里也只贴出 button 被点击调用的代码123456789101112131415161718CIContext *context = [CIContext contextWithOptions:nil];CIImage *inputImage = [[CIImage alloc] initWithImage:self.imageView.image];// 怀旧 CIPhotoEffectInstant// 单色 CIPhotoEffectMono// 黑白 CIPhotoEffectNoir// 褪色 CIPhotoEffectFade// 色调 CIPhotoEffectTonal// 冲印 CIPhotoEffectProcess// 岁月 CIPhotoEffectTransfer// 铬黄 CIPhotoEffectChromeCIFilter *filter = [CIFilter filterWithName:@&quot;CIPhotoEffectInstant&quot;];[filter setValue:inputImage forKey:kCIInputImageKey];CIImage *result = [filter valueForKey:kCIOutputImageKey];CGImageRef cgImage = [context createCGImage:result fromRect:[result extent]];UIImage *resultImage = [UIImage imageWithCGImage:cgImage];self.imageView.image= [UIImage imageWithCGImage:resultImage.CGImage]; 这是今晚整理的 CoreImage 相关的知识，如果哪里写的有问题，欢迎大家指正！另外给大家分享一篇文章，里面有很多 iOS 9 出来的 Core Image新滤镜，在这里。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>毛玻璃&amp;模糊视图&amp;滤镜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 内购]]></title>
    <url>%2F2017%2F05%2F15%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%86%85%E8%B4%AD%2F</url>
    <content type="text"><![CDATA[电商之类的 app 大多用的都是第三方支付（支付宝微信等支付），但是在某种特殊情况之下，我们却不得不使用内购。比如商品是在本 app 中使用和消耗的（游戏币游戏道具等），就一定要用内购，苹果强制的，否则会被拒绝上线。因此作为 iOS 开发者，不光要了解第三方支付，对内购也要有一定的认识！ 一、什么是内购？内购是苹果推出的一种支付方式。说白了内购就是苹果获取利润的方式之一。如果我们使用第三方支付，只会支付少量的💰，但使用内购却要支付很多💰💰💰💰💰💰💰💰，要和苹果三七分帐（以前是四六分😢）。 二、内购产品的类别官方的注释写的很清楚了，内购有五种产品类别，简介如下： 非消耗品（Nonconsumable）指的是在游戏中一次性购买并拥有永久访问权的物品或服务。非消耗品物品可以被用户再次下载，并且能够在用户的所有设备上使用。 消耗品（Consumable）消耗品购买不可被再次下载,根据其特点,消耗品不能在用户的设备之间跨设备使用,除非自定义服务在用户的账号之间共享这些信息。以下三种类别在iBooks中使用，目前iBooks不支持大陆市场 免费订阅（Free subscriptions） 自动续费订阅（Auto-renewing subscriptions） 非自动续费订阅（Nonrenewing subscriptions） 三、苹果官方的内购流程 白话文如下⬇️ 程序向服务器发送请求，获得一份产品列表。 服务器返回包含产品标识符的列表。 程序向App Store发送请求，得到产品的信息。 App Store返回产品信息。 程序把返回的产品信息显示给用户（App的store界面） 用户选择某个产品 程序向App Store发送支付请求 App Store处理支付请求并返回交易完成信息。 程序从信息中获得数据，并发送至服务器。 服务器纪录数据，并进行审(我们的)查。 服务器将数据发给App Store来验证该交易的有效性。 App Store对收到的数据进行解析，返回该数据和说明其是否有效的标识。 服务器读取返回的数据，确定用户购买的内容。 服务器将购买的内容传递给程序。 四、代码实现4.1 项目的Bundle identifier需要与您申请AppID时填写的bundleID一致，不然会无法请求到商品信息。 4.2要使用内购,需要导入 StoreKit 依赖库 4.3代码部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#import &quot;UITableController.h&quot;#import &lt;StoreKit/StoreKit.h&gt;@interface UITableController () &lt;SKProductsRequestDelegate, UITableViewDelegate, UITableViewDataSource, SKPaymentTransactionObserver&gt;/** 所有商品 */@property (nonatomic, strong) NSArray *products;@end@implementation UITableController- (void)viewDidLoad &#123;[super viewDidLoad];[self requestProducts];&#125;// 请求可卖商品- (void)requestProducts &#123;// 1.从服务器请求所有商品的ProductIdsNSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;iapdemo.plist&quot; ofType:nil];NSArray *productArray = [NSArray arrayWithContentsOfFile:filePath];// 2.获取productIdNSArray *productIdArray = [productArray valueForKeyPath:@&quot;productId&quot;];// 3.请求可卖的商品NSSet *productIdSet = [NSSet setWithArray:productIdArray];SKProductsRequest *request = [[SKProductsRequest alloc] initWithProductIdentifiers:productIdSet];request.delegate = self;[request start];&#125;- (void)viewWillAppear:(BOOL)animated&#123;[super viewWillAppear:animated];// 添加观察者[[SKPaymentQueue defaultQueue] addTransactionObserver:self];&#125;- (void)viewWillDisappear:(BOOL)animated&#123;[super viewWillDisappear:animated];// 移除观察者[[SKPaymentQueue defaultQueue] removeTransactionObserver:self];&#125;#pragma mark - 实现SKProductsRequest的代理方法// 请求到可卖商品的结果- (void)productsRequest:(SKProductsRequest *)request didReceiveResponse:(SKProductsResponse *)response&#123;// 1.展示商品self.products = [response.products sortedArrayWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(SKProduct *obj1, SKProduct *obj2) &#123;return [obj1.price compare:obj2.price];&#125;];// 2.刷新表格[self.tableView reloadData];&#125;// 请求失败- (void)request:(SKRequest *)request didFailWithError:(NSError *)error &#123;NSLog(@&quot;%@&quot;, [error localizedDescription]);&#125;// 请求结束- (void)requestDidFinish:(SKRequest *)request &#123;NSLog(@&quot;请求结束&quot;);&#125;#pragma mark - 实现tableView的数据源和代理方法- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;return self.products.count;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123;static NSString *ID = @&quot;productCellId&quot;;UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];if (cell == nil) &#123;cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];&#125;// 1.取出模型SKProduct *product = self.products[indexPath.row];// 2.给cell设置数据cell.textLabel.text = product.localizedTitle;cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;价格:%@&quot;, product.price];return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;// 1.取出模型SKProduct *product = self.products[indexPath.row];// 2.购买商品[self buyProduct:product];&#125;#pragma mark - 购买商品- (void)buyProduct:(SKProduct *)product&#123;// 1.创建票据SKPayment *payment = [SKPayment paymentWithProduct:product];// 2.将票据加入到交易队列中[[SKPaymentQueue defaultQueue] addPayment:payment];&#125;#pragma mark - 实现SKPaymentQueue的回调方法// 监听购买结果- (void)paymentQueue:(SKPaymentQueue *)queue updatedTransactions:(NSArray *)transactions&#123;for (SKPaymentTransaction *transation in transactions) &#123;switch (transation.transactionState) &#123;case SKPaymentTransactionStatePurchasing:NSLog(@&quot;正在交易&quot;);break;case SKPaymentTransactionStatePurchased:NSLog(@&quot;交易成功&quot;);// 将交易从交易队列中移除, 否则会验证不通过,以下几个都得移除[queue finishTransaction:transation];break;case SKPaymentTransactionStateFailed:NSLog(@&quot;交易失败&quot;);[queue finishTransaction:transation];break;case SKPaymentTransactionStateRestored:NSLog(@&quot;购买过该商品&quot;);[queue finishTransaction:transation];break;case SKPaymentTransactionStateDeferred:NSLog(@&quot;未决定&quot;);break;default:break;&#125;&#125;&#125;- (void)dealloc &#123;[[SKPaymentQueue defaultQueue] removeTransactionObserver:self];&#125; 另外使用这个方法即可恢复购买1[[SKPaymentQueue defaultQueue] removeTransactionObserver:self];]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 刷新框架 MJRefresh 的使用]]></title>
    <url>%2F2017%2F05%2F11%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%88%B7%E6%96%B0%E6%A1%86%E6%9E%B6%20MJRefresh%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[下拉刷新控件目前比较火的有好几种，此前用过MJRefresh 和 SVPullToRefresh，相对而言，还是觉得 MJRefresh 更好用！因此抽了些时间整理了 MJRefresh 的用法。以下是文章内容。。。 【文章目录】一、类结构图 MJRefreshComponent.h MJRefreshHeader.h MJRefreshFooter.h MJRefreshAutoFooter.h 二、参考例子 下拉刷新01-默认 下拉刷新02-动画图片 下拉刷新03-隐藏时间 下拉刷新04-隐藏状态和时间 下拉刷新05-自定义文字 下拉刷新06-自定义刷新控件 上拉刷新01-默认 上拉刷新02-动画图片 上拉刷新03-隐藏刷新状态的文字 上拉刷新04-全部加载完毕 上拉刷新05-自定义文字 上拉刷新06-加载后隐藏 上拉刷新07-自动回弹的上拉01 上拉刷新08-自动回弹的上拉02 上拉刷新09-自定义刷新控件(自动刷新) 上拉刷新10-自定义刷新控件(自动回弹) UICollectionView01-上下拉刷新 UIWebView01-下拉刷新 【文章内容】1.类结构图 MJRefreshComponent.h1234567891011121314/** 刷新控件的基类 */@interface MJRefreshComponent : UIView#pragma mark - 刷新状态控制/** 进入刷新状态 */- (void)beginRefreshing;/** 结束刷新状态 */- (void)endRefreshing;/** 是否正在刷新 */- (BOOL)isRefreshing;#pragma mark - 其它/** 根据拖拽比例自动切换透明度 */@property (assign, nonatomic, getter=isAutomaticallyChangeAlpha) BOOL automaticallyChangeAlpha;@end MJRefreshHeader.h1234567891011121314@interface MJRefreshHeader : MJRefreshComponent/** 创建 header */+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;/** 创建 header */+ (instancetype)headerWithRefreshingTarget:(id)target refreshingAction:(SEL)action;/** 这个 key 用来存储上一次下拉刷新成功的时间 */@property (copy, nonatomic) NSString *lastUpdatedTimeKey;/** 上一次下拉刷新成功的时间 */@property (strong, nonatomic, readonly) NSDate *lastUpdatedTime;/** 忽略多少 scrollView 的 contentInset 的顶部 */@property (assign, nonatomic) CGFloat ignoredScrollViewContentInsetTop;@end MJRefreshFooter.h1234567891011121314151617@interface MJRefreshFooter : MJRefreshComponent/** 创建 footer */+ (instancetype)footerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock;/** 创建 footer */+ (instancetype)footerWithRefreshingTarget:(id)target refreshingAction:(SEL)action;/** 提示没有更多的数据 */- (void)noticeNoMoreData;/** 重置没有更多的数据（消除没有更多数据的状态） */- (void)resetNoMoreData;/** 忽略多少 scrollView 的 contentInset 的底部*/@property (assign, nonatomic) CGFloat ignoredScrollViewContentInsetBottom;/** 自动根据有无数据来显示和隐藏 */@property (assign, nonatomic) BOOL automaticallyHidden;@end MJRefreshAutoFooter.h1234567@interface MJRefreshAutoFooter : MJRefreshFooter/** 是否自动刷新(默认为 YES) */@property (assign, nonatomic, getter=isAutomaticallyRefresh) BOOL automaticallyRefresh;/** 当底部控件出现多少时就自动刷新(默认为1.0，也就是底部控件完全出现时，才会自动刷新) */@property (assign, nonatomic) CGFloat appearencePercentTriggerAutoRefresh;@end 2.参考例子ps: 可以下载 MJRefresh试试 下拉刷新01-默认12345678self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;// 进入刷新状态后会自动调用这个block&#125;];// 或// 设置回调（一旦进入刷新状态，就调用 target 的 action，也就是调用 self 的 loadNewData 方法）self.tableView.mj_header = [MJRefreshNormalHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];// 马上进入刷新状态[self.tableView.mj_header beginRefreshing]; 下拉刷新02-动画图片12345678910111213141516// 设置回调（一旦进入刷新状态，就调用 targett 的 action，即调用 self 的 loadNewData 方法）MJRefreshGifHeader *header = [MJRefreshGifHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];// 设置普通状态的动画图片NSArray *idleImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[header setImages:idleImages forState:MJRefreshStateIdle];// 设置即将刷新状态的动画图片（一松开就会刷新的状态）NSArray *pullingImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[header setImages:pullingImages forState:MJRefreshStatePulling];// 设置正在刷新状态的动画图片NSArray *refreshingImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[header setImages:refreshingImages forState:MJRefreshStateRefreshing];// 设置 headerself.tableView.mj_header = header; 下拉刷新03-隐藏时间12// 隐藏时间header.lastUpdatedTimeLabel.hidden = YES; 下拉刷新04-隐藏状态和时间12345// 隐藏时间header.lastUpdatedTimeLabel.hidden = YES;// 隐藏状态header.stateLabel.hidden = YES; 下拉刷新05-自定义文字123456789101112// 设置文字[header setTitle:@&quot;Pull down to refresh&quot; forState:MJRefreshStateIdle];[header setTitle:@&quot;Release to refresh&quot; forState:MJRefreshStatePulling];[header setTitle:@&quot;Loading ...&quot; forState:MJRefreshStateRefreshing];// 设置字体header.stateLabel.font = [UIFont systemFontOfSize:15];header.lastUpdatedTimeLabel.font = [UIFont systemFontOfSize:14];// 设置颜色header.stateLabel.textColor = [UIColor redColor];header.lastUpdatedTimeLabel.textColor = [UIColor blueColor]; 下拉刷新06-自定义刷新控件12self.tableView.mj_header = [MJDIYHeader headerWithRefreshingTarget:self refreshingAction:@selector(loadNewData)];// 具体实现参考 MJDIYHeader.h 和 MJDIYHeader.m 上拉刷新01-默认123456self.tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^&#123;// 进入刷新状态后会自动调用这个 block&#125;];// 或// 设置回调（一旦进入刷新状态，就调用 target 的 action，即调用 self 的 loadMoreData 方法）self.tableView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)]; 上拉刷新02-动画图片12345678910// 设置回调（一旦进入刷新状态，就调用 target 的 action，即调用 self 的 loadMoreData 方法）MJRefreshAutoGifFooter *footer = [MJRefreshAutoGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 设置刷新图片NSArray *refreshingImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];// 设置尾部self.tableView.mj_footer = footer; 上拉刷新03-隐藏刷新状态的文字123// 隐藏刷新状态的文字footer.refreshingTitleHidden = YES;// 如果没有上面的方法，就用footer.stateLabel.hidden = YES; 上拉刷新04-全部加载完毕12// 变为没有更多数据的状态[footer endRefreshingWithNoMoreData]; 上拉刷新05-自定义文字12345678910// 设置文字[footer setTitle:@&quot;Click or drag up to refresh&quot; forState:MJRefreshStateIdle];[footer setTitle:@&quot;Loading more ...&quot; forState:MJRefreshStateRefreshing];[footer setTitle:@&quot;No more data&quot; forState:MJRefreshStateNoMoreData];// 设置字体footer.stateLabel.font = [UIFont systemFontOfSize:17];// 设置颜色footer.stateLabel.textColor = [UIColor blueColor]; 上拉刷新06-加载后隐藏12// 隐藏当前的上拉刷新控件self.tableView.mj_footer.hidden = YES; 上拉刷新07-自动回弹的上拉011self.tableView.mj_footer = [MJRefreshBackNormalFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)]; 上拉刷新08-自动回弹的上拉02123456789101112131415161718MJRefreshBackGifFooter *footer = [MJRefreshBackGifFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 设置普通状态的动画图片NSArray *idleImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[footer setImages:idleImages forState:MJRefreshStateIdle];// 设置即将刷新状态的动画图片（一松开就会刷新的状态）NSArray *pullingImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[footer setImages:pullingImages forState:MJRefreshStatePulling];// 设置正在刷新状态的动画图片NSArray *refreshingImages = @[@&quot;图片1&quot;, @&quot;图片2&quot;, @&quot;图片3&quot;];[footer setImages:refreshingImages forState:MJRefreshStateRefreshing];// 设置尾部self.tableView.mj_footer = footer; 上拉刷新09-自定义刷新控件(自动刷新)12self.tableView.mj_footer = [MJDIYAutoFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 具体实现参考MJDIYAutoFooter.h和MJDIYAutoFooter.m 上拉刷新10-自定义刷新控件(自动回弹)12self.tableView.mj_footer = [MJDIYBackFooter footerWithRefreshingTarget:self refreshingAction:@selector(loadMoreData)];// 具体实现参考MJDIYBackFooter.h和MJDIYBackFooter.m UICollectionView01-上下拉刷新12345678// 下拉刷新self.collectionView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;// 进入刷新状态后会自动调用这个block&#125;];// 上拉刷新self.collectionView.mj_footer = [MJRefreshAutoNormalFooter footerWithRefreshingBlock:^&#123;// 进入刷新状态后会自动调用这个block&#125;]; UIWebView01-下拉刷新1234// 添加下拉刷新控件self.webView.scrollView.mj_header = [MJRefreshNormalHeader headerWithRefreshingBlock:^&#123;// 进入刷新状态后会自动调用这个block&#125;]; over以上是 MJRefresh 的具体用法，有兴趣的朋友还可以参考下MJRefresh/README.md]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>MJRefresh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 微信支付]]></title>
    <url>%2F2017%2F05%2F01%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[作为 iOS 开发者，支付无疑是很重要的，特别是这两年几乎到处都是微信支付、支付宝支付。相比支付宝支付，觉得微信支付还算简单，但还是建议预先看下文档。开始说文章的内容吧，这篇文章主要分为四个部分：创建应用、了解支付的流程、集成微信SDK，最后是实现支付的demo。 第一步：创建应用 通常来说注册APP这样的事情是部门经理做的，所以这一步也可以忽略～～～ 在 微信开放平台 的管理中心 创建一个应用。此应用官方称七日内审核通过，一般都是三四天！而关于填写经营信息、填写商户信息、填写对公帐号信息在这里就忽略不写了。有兴趣的朋友可以了解下这篇文章。 第二步：了解支付的流程 如果做过其它支付，就会发现这些流程其实都差不多，就像我们平时用手机支付买东西一样。下边的流程两分钟大概就能读完，很容易理解！ 1&gt; 用户使用 APP 客户端，选择商品下单。2&gt; APP 客户端将用户的商品数据传给商户服务器，请求生成支付订单。3&gt; 商户后台调用统一下单 API 向微信的服务器发送请求，微信服务器生成预付单，并生成一个 prepay_id 返回给商户后台。4&gt; 商户后台将这个 prepay_id 返回给商户客户端。5&gt; 用户点击确认支付，这时候商户客户端调用 SDK 打开微信客户端，进行微信支付。6&gt; 微信客户端向微信服务器发起支付请求并返回支付结果（他们之间交互用的就是prepay_id这个参数，微信的服务器要验证微信客户端传过去的参数是否跟第三步中生成的那个id一致）。7&gt; 用户输入支付密码后，微信客户端提交支付授权，跟微信服务器交互，完成支付8&gt; 微信服务器给微信客户端发送支付结果提示，并异步给商户服务器发送支付结果通知。9&gt; 商户客户端通过支付结果回调接口查询支付结果，并向后台检查支付结果是否正确，后台返回支付结果。10&gt; 商户客户端显示支付结果，完成订单，发货。 第三步：集成SDK 其实严格来说，这一步才是微信支付的真正开始。首先我们应该下载 微信SDK，如有需要，还可把【微信支付】APP支付示例下载下来看看。下面是集成 SDK 的具体步骤： 1.把下载好的 SDK 导入工程（如下图）（我下的是OpenSDK1.7.4版本） 2.导入微信支付SDK依赖库（如下图） 3.设置URL Scheme在注册微信平台APP的时候，会给一个唯一识别标识符（APPID）,需要填写在工程中。（如下图） 配置好上述参数后就可以写代码了～～～ 第四部：代码 代码分为以下步骤： 1.在 Appdelegate 中注册微信 APPID这是首先要做的事情。1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;// 向微信终端注册ID[WXApi registerApp:@&quot;wx0f8d5e0eadd2d4b7&quot; withDescription:@&quot;demo test&quot;];return YES;&#125; 2.获取微信支付所必要的参数接着，在微信支付的.m文件中获取微信支付所必要的参数。为了提高数据安全性，下单、签名等操作一般都是在后台完成的，因此以下这些参数后台会给我们。我们主要得知道这些参数如何设置：123456789101112131415// 发起微信支付，设置参数PayReq *request = [[PayReq alloc] init]; // 创建支付对象request.openID = @&quot;&quot;; // 由用户微信号和AppID组成的唯一标识request.partnerId = @&quot;&quot;; // 商家IDrequest.prepayId = @&quot;&quot;; // 预支付订单IDrequest.package = @&quot;Sign=WXPay&quot;; // 数据和签名request.nonceStr = @&quot;&quot;; // 随机编码NSDate *date = [NSDate date];NSString * timeSp = [NSString stringWithFormat:@&quot;%ld&quot;, (long)[date timeIntervalSince1970]];UInt32 timeStamp = [timeSp intValue];request.timeStamp = timeStamp; // 时间戳request.sign = @&quot;&quot;; // 签名，签名一般都会加密//发送请求到微信，等待微信返回 onResp[WXApi sendReq:request]; 3.微信支付回调最后要在Appdelegate.m文件中添加微信支付结果 onResp 回调方法1234567891011121314151617181920212223242526272829303132333435363738// 判断发起的请求是否为微信支付，如果是就回调- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;NSString *,id&gt; *)options &#123;return [WXApi handleOpenURL:url delegate:self];&#125;#pragma mark - WXApiDelegate// 微信支付结果回调方法- (void)onResp:(BaseResp *)resp &#123;NSString *payResoult = [NSString stringWithFormat:@&quot;%d&quot;, resp.errCode];if([resp isKindOfClass:[PayResp class]])&#123;/**WXSuccess = 0, 成功WXErrCodeCommon = -1, 普通错误类型WXErrCodeUserCancel = -2, 用户点击取消并返回WXErrCodeSentFail = -3, 发送失败WXErrCodeAuthDeny = -4, 授权失败WXErrCodeUnsupport = -5, 微信不支持*///支付返回结果，实际支付结果需要去微信服务器端查询switch (resp.errCode) &#123;case WXSuccess:payResoult = @&quot;支付成功&quot;;break;case WXErrCodeCommon:payResoult = @&quot;支付失败&quot;;break;case WXErrCodeUserCancel:payResoult = @&quot;用户点击取消并返回&quot;;break;default:// 错误码 以及 错误提示字符串payResoult = [NSString stringWithFormat:@&quot;支付结果：失败！retcode = %d, retstr = %@&quot;, resp.errCode,resp.errStr];break;&#125;&#125;&#125; 结束语：在开发中，微信支付常常与其它技术配合使用，比如MD5加密，AFN等等。有空闲的话会一一整理出来与大家分享！另外文章写的如果有什么错误，还请大家指出来，谢谢大家！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 小冷易忘知识点总结]]></title>
    <url>%2F2017%2F04%2F29%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E5%B0%8F%E5%86%B7%E6%98%93%E5%BF%98%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[看网上有人整理 iOS 开发中常用的易忘知识点，iOS 开发小冷易忘知识点总结，觉得不错，于是自己也想着整理一些易忘的知识点。会持续更新…… iOS 控制器的基类，搭建框架之初一般都会设计一个 ViewController 基类，这里设置的基类是 NNBaseViewController，继承自 UIViewController。 1234567#import &quot;NNBaseViewController.h&quot;@interface NNBaseViewController ()@end@implementation NNBaseViewController 123456789101112131415161718192021222324252627282930313233- (void)viewDidLoad &#123;[super viewDidLoad];[self setupViews];// 判断是否有上级页面，有的话再设置返回按钮if ([self.navigationController.viewControllers indexOfObject:self] != 0) &#123;[self setupLeftBarButton];&#125;&#125;- (void)setupViews &#123;// 设置应用的背景色self.view.backgroundColor = [UIColor lightGrayColor];// 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素self.automaticallyAdjustsScrollViewInsets = NO;&#125;#pragma mark - 自定义返回按钮- (void)setupLeftBarButton &#123;// 自定义 leftBarButtonItem ，UIImageRenderingModeAlwaysOriginal 防止图片被渲染self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[[UIImage imageNamed:@&quot;Back-蓝&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]style:UIBarButtonItemStylePlaintarget:selfaction:@selector(leftBarButtonClick)];// 防止返回手势失效self.navigationController.interactivePopGestureRecognizer.delegate = (id&lt;UIGestureRecognizerDelegate&gt;)self;&#125;- (void)leftBarButtonClick &#123;[self.navigationController popViewControllerAnimated:YES];&#125;@end 隐藏 navigationControll 左侧的返回按钮 因为项目需要，有时需要隐藏 navigationControll 左侧或右侧的按钮。 123456// 这两句貌似不太管用self.navigationItem.leftBarButtonItems = nil;self.navigationItem.rightBarButtonItem = nil;// 可以试试这两句代码self.navigationItem.hidesBackButton = YES;self.navigationItem.rightBarButtonItem.customView.hidden = YES; 改变 button 内部的图片以及文字的偏移量 有时候需要在 button 的右部添加指示箭头，但 button 默认的是图片在左，文字在右，因此想要实现项目需求，我们需要改变 button 内部的偏移量。在 storyboard 或 xib 中也可以改变 button 内部的图片以及文字的偏移量，但貌似没有做适配的地方，那么在不同机型上的显示就会有问题（如果哪位道友发现可以在 storyboard 或 xib 中可以做适配，还请告知），下面是改变 button 内部图片以及文字偏移量的代码。 123// 已经做了适配，各位可以根据需要做屏幕适配self.changeSpecialistBtn.titleEdgeInsets = UIEdgeInsetsMake(0, -lengthFit(16), 0, 0);self.changeSpecialistBtn.imageEdgeInsets = UIEdgeInsetsMake(0, lengthFit(76), 0, 0); tableView 滚动时自动收起键盘 项目中某个 tableView 页面有文字搜索功能，输入文本完毕之后滚动 tableView，要求键盘自动收起。 1self.tableView.keyboardDismissMode = UIScrollViewKeyboardDismissModeOnDrag; 判断上级页面是哪个页面 1234567// 我这里的项目需求是，如果上一个页面是 KXOrderCenterViewController，就隐藏稍后支付按钮，否则不隐藏NSArray *array = self.navigationController.viewControllers;if ([array[0] isKindOfClass:[KXOrderCenterViewController class]]) &#123;self.payLaterBtn.hidden = YES;&#125; else &#123;self.payLaterBtn.hidden = NO;&#125; 从任意界面返回 NavigationController 中的任意一个 这个方法还是挺实用的，从某个界面跳转到任意一个界面。 12345678910111213141516171819// 得到当前的 NavigationController[[APPDELEGATE getCurrentViewController].navigationController popToRootViewControllerAnimated:NO];// 跳转到哪个 NavigationController，这里下标为1，表示第二个[APPDELEGATE.tabBarController setSelectedIndex:1];// 退出当前界面并执行 block 中的内容[self.navigationController dismissViewControllerAnimated:YES completion:^&#123;UINavigationController *navi = APPDELEGATE.tabBarController.viewControllers[1];// 保险起见，再判断下是否是将要跳转到的页面if ([navi.viewControllers[0] isKindOfClass:[KXOrderCenterViewController class]]) &#123;// 我这里需要刷新KXOrderCenterViewController *orderCenter = navi.viewControllers[0];[orderCenter beginRefreshing];&#125;&#125;]; 设置导航栏右部点击按钮，并添加点击事件 123456789// 添加文字按钮UIBarButtonItem *rightBarButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;编辑&quot; style:UIBarButtonItemStylePlain target:self action:@selector(editor)];self.navigationItem.rightBarButtonItem = rightBarButton;// 添加图片按钮UIBarButtonItem *rightBarBtn = [[UIBarButtonItem alloc] initWithImage:[[UIImage imageNamed:@&quot;图片名&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal] style:UIBarButtonItemStylePlain target:self action:@selector(rightBarButtonEvent)];[self.navigationItem setRightBarButtonItem:rightBarBtn]; 给 view 添加手势，并加入点击事件 123UITapGestureRecognizer *operationTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(gotoCapture:)];[self.operationView addGestureRecognizer:operationTap]; textview 输入文本，服务器那边要求返回文本个数不超过32 服务器那边有限制，要求返回文本个数不超过32个。。。于是这里做了判断，如果超过32个就不再允许输入，允许删除。 123456789101112131415161718192021222324252627282930313233343536- (void)textViewDidChange:(UITextView *)textView &#123;[self updateViewHeight];// 该判断用于联想输入if (textView == self.secondDiagnosisTextView) &#123;if (textView.text.length &gt; 32) &#123;// 截取字符串textView.text = [textView.text substringToIndex:32];// HUD 提示[CommunityPublicClass showHUDwithLabelText:@&quot;最多输入32个字&quot; andDetailsLabelText:nil];&#125;&#125;&#125;// 代理方法规定只能输入32个字- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text &#123;// 输入32字之后，允许删除if ([text isEqualToString:@&quot;&quot;]) &#123;return YES;&#125;if (textView == self.secondDiagnosisTextView) &#123;if (textView.text.length == 0)return YES;NSInteger existedLength = textView.text.length;NSInteger selectedLength = range.length;NSInteger replaceLength = text.length;if (existedLength - selectedLength + replaceLength &gt; 32) &#123;// HUD 提示[CommunityPublicClass showHUDwithLabelText:@&quot;最多输入32个字&quot; andDetailsLabelText:nil];return NO;&#125;&#125;return YES;&#125; textfield 中输入手机号，只允许输入数字 12345678910111213141516171819- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123;if (textField == self.secondAgeTextField) &#123;if ([self isPureInt:string] || [string isEqualToString:@&quot;&quot;]) &#123;return YES;&#125;else&#123;return NO;&#125;&#125;return YES;&#125;// 判断输入的是否是纯数字- (BOOL)isPureInt:(NSString*)string&#123;NSScanner *scan = [NSScanner scannerWithString:string];int val;return [scan scanInt:&amp;val] &amp;&amp; [scan isAtEnd];&#125; 给 button 设置边框、圆角、边框设置颜色 123[self.completeBtn.layer setBorderWidth:1.0];self.completeBtn.layer.cornerRadius = 1;[self.completeBtn.layer setBorderColor:KXColorTextBlack.CGColor]; 设置图片拉伸 有时 UI 设计师给出的图片并不合适，比如我们这的 UI 设计师一边忙 web 端，一边忙我们移动端，有时候都不忍心让他重新作图，于是只好自己想办法 123// 设置图片拉伸UIImage *bgImage = [UIImage imageNamed:@&quot;&quot;];_bgImageView.image = [bgImage stretchableImageWithLeftCapWidth:15 topCapHeight:15]; 点击单元格时，默认的点击效果比较丑，大多时候不显示点击效果 1234- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123;[tableView deselectRowAtIndexPath:indexPath animated:YES] ;&#125; 改变导航栏标题的颜色 123UIColor *color = [UIColor cyanColor];NSDictionary *dictionary = [NSDictionary dictionaryWithObject: color forKey:NSForegroundColorAttributeName];self.navigationController.navigationBar.titleTextAttributes = dictionary; 延迟调用 12// 延迟两秒钟调用 beginAction 方法[self performSelector:@selector(beginAction) withObject:nil afterDelay:0.2] ; 项目中用到了 UISwitch 控件，需要更改它的大小 12345// 改变 UISwitch 的大小，CGAffineTransformMakeScale(CGFloat x, CGFloat y) 对 view 的长和宽进行缩放，不改变 view 的中心点self.orderSwitch.transform = CGAffineTransformMakeScale(0.7, 0.7);// 改变 UISwitch 开启时的颜色self.orderSwitch.onTintColor = KXColorBlue; 在做明暗文切换(密码输入框)的时候遇见一个坑——就是切换 secureTextEntry 的时候，输入框的光标会偏移，下面是解决办法及明暗文切换的方法： 123456789101112131415- (IBAction)btnClick:(UIButton *)sender &#123;sender.selected = !sender.selected;NSString *passwordString = self.passwordText.text;// 这句代码可以防止切换的时候光标偏移self.passwordText.text = @&quot;&quot;;if (sender.selected) &#123; // 明文self.passwordText.secureTextEntry = NO;&#125; else &#123; // 暗文self.passwordText.secureTextEntry = YES;&#125;self.passwordText.text = passwordString;&#125; 判断屏幕横屏/竖屏(在ViewController里面) 123456789101112// 屏幕发生翻转的时候会调用- (void)viewWillLayoutSubviews &#123;[self shouldRotateToOrientation:(UIDeviceOrientation)[UIApplication sharedApplication].statusBarOrientation];&#125;- (void)shouldRotateToOrientation:(UIDeviceOrientation)orientation &#123;if (orientation == UIDeviceOrientationPortrait ||orientation == UIDeviceOrientationPortraitUpsideDown) &#123;NSLog(@&quot;这是竖屏&quot;);&#125; else &#123;NSLog(@&quot;这是横屏&quot;);&#125;&#125; 加载本地的 HTML 文件，比如文件名字是serviceDescription.html 1234NSString *resourcePath = [[NSBundle mainBundle] resourcePath];NSString *filePath = [resourcePath stringByAppendingPathComponent:@&quot;serviceDescription.html&quot;];NSString *htmlString = [[NSString alloc] initWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];[self.webView loadHTMLString: htmlString baseURL: [NSURL fileURLWithPath:[[NSBundle mainBundle] bundlePath]]]; iOS 项目开发中用的一部分宏定义 12345678910111213141516171819202122232425262728293031323334353637383940414243/** self的弱引用 */#define NNWeakSelf __weak typeof(self) weakSelf = self;/** self的强引用 */#define NNStrongSelf __strong __typeof(weakSelf)strongSelf = weakSelf;#define NNColorBlue [UIColor colorWithRed:0.0/255.0f green:135.0/255.0f blue:209.0/255.0f alpha:1]#define NNFontBoldText [UIFont boldSystemFontOfSize:fontFit(16)]#define NNFontText [UIFont systemFontOfSize:fontFit(16)]#define SCREENWIDTH [UIScreen mainScreen].bounds.size.width#define SCREENHEIGHT [UIScreen mainScreen].bounds.size.height#define iPhone5 (([[UIScreen mainScreen] bounds].size.height*[[UIScreen mainScreen] bounds].size.width &lt;= 320*568)?YES:NO)#define iPhone6 (([[UIScreen mainScreen] bounds].size.height*[[UIScreen mainScreen] bounds].size.width &lt;= 375*667)?YES:NO)#define iPhone6p (([[UIScreen mainScreen] bounds].size.height*[[UIScreen mainScreen] bounds].size.width &lt;= 414*736)?YES:NO)#define iOS7 ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 7.0 ? YES : NO) // 是否IOS7static inline float lengthFit(float iphone6PlusLength)&#123;if (iPhone5) &#123;return iphone6PlusLength *320.0f/414.0f;&#125;if (iPhone6) &#123;return iphone6PlusLength *375.0f/414.0f;&#125;return iphone6PlusLength;&#125;static inline float fontFit(float iphone6PlusFont)&#123;if (iPhone5) &#123;return iphone6PlusFont - 2;&#125;if (iPhone6) &#123;return iphone6PlusFont - 1;&#125;return iphone6PlusFont;&#125;#define PlaceholderAvatarImage [UIImage imageNamed:@&quot;默认头像&quot;] 一句代码隐藏 UITableView 中空的 cell 1self.tableView.tableFooterView = [[UIView alloc] init]; 自定义 leftBarButtonItem 返回按钮时，防止返回手势失效的办法 123456789101112- (void)setupLeftBarButton &#123;self.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc]initWithImage:[[UIImage imageNamed:@&quot;Back-蓝&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal]style:UIBarButtonItemStylePlaintarget:selfaction:@selector(leftBarButtonClick)];self.navigationController.interactivePopGestureRecognizer.delegate = (id&lt;UIGestureRecognizerDelegate&gt;)self;&#125;- (void)leftBarButtonClick &#123;[self.navigationController popViewControllerAnimated:YES];&#125; 不允许 viewController 自动调整，我们自己布局；如果设置为YES，视图会自动下移 64 像素 1self.automaticallyAdjustsScrollViewInsets = NO; 去空格，开发中有些地方不需要空格，这里记录一下 12345// 去掉两端的空格[trimString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]];// 去掉所有空格[trimString stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;]; 判断字符串中是否包含非法字符 12345if ([self.searchText.text rangeOfString:@&quot;&apos;&quot;].location != NSNotFound) &#123;// 用封装好的提示框提示[CommunityPublicClass showHUDwithLabelText:@&quot;您输入的字符不合法&quot; andDetailsLabelText:nil];return;&#125; iOS 导航栏的正确隐藏方法 第一种方法 1234567891011- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];[self.navigationController setNavigationBarHidden:YES animated:YES];&#125;- (void)viewWillDisappear:(BOOL)animated &#123;[super viewWillDisappear:animated];[self.navigationController setNavigationBarHidden:NO animated:YES];&#125; 第二种方法 123456789101112131415161718@interface NNViewController () &lt;UINavigationControllerDelegate&gt;@end@implementation NNViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 设置导航控制器的代理为selfself.navigationController.delegate = self;&#125;#pragma mark - UINavigationControllerDelegate- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated &#123;[self.navigationController setNavigationBarHidden: [viewController isKindOfClass:[self class]] animated:YES];&#125; 判断字符串是否为空 12345678910111213// 判断字符串是否为空+ (BOOL)isBlankString:(NSString *)string &#123;if (string == nil || string == NULL) &#123;return YES;&#125;if ([string isKindOfClass:[NSNull class]]) &#123;return YES;&#125;if ([[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] length]==0) &#123;return YES;&#125;return NO;&#125;]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>知识点总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 银联支付]]></title>
    <url>%2F2017%2F04%2F19%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E9%93%B6%E8%81%94%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[前阵子看了很多篇博客，有很多朋友吐槽说银联支付怎么怎么坑，所以集成的时候小心翼翼，但集成完银联支付之后，觉得相对于支付宝支付微信支付而言，银联支付还可以说的过去。下面就来介绍一下怎样快速的集成银联支付。 首先，下载银联支付SDK（这个有点不好找），里面包含需要的库文件和详细的文档；下载好开发包之后，进行解压，解压成下面这样的文件 官方文档也在这个目录下： 下面开始集成SDK 导入文件（文件目录：app开发包/控件开发包/upmp_iphone/paymentcontrol） 注意：记得老版本是三个文件，现在是新版本，只有两个 到这里的话，其实银联支付就做了一半了，是不是觉得很轻松很 easy 😉，接下来像我们 iOS 客户端再简单调用一个方法就行啦 支付接口调用商户App从商户服务器获取tn，当tn不为空时，调用支付接口。123456789//当获得的tn不为空时，调用支付接口if (tn != nil &amp;&amp; tn.length &gt; 0)&#123;[[UPPaymentControl defaultControl]startPay:tnfromScheme:@&quot;UPPay&quot;mode:self.tnModeviewController:self];&#125; 上边这个方法需要的几个参数文档上都写的有，tn 是交易流水号，fromScheme 是商户自定义协议， mode 是接入模式，viewController指的是发起调用的视图控制器。 检测是否已安装银联App接口调用(这个方法可写可不写)1234if([[UPPaymentControl defaultControl] isPaymentAppInstalled])&#123;//当判断用户手机上已安装银联App，商户客户端可以做相应个性化处理&#125; 到这里的话，银联支付就轻松愉快的搞定了。另外银联的开发文档中给我们提供的有测试帐号，大家可以试试。那里还有支付接口回调、检查是否安装银联App的接口、返回结果接口这三个方法，大家有兴趣的话也可以试试的。集成完银联支付之后，对比下支付宝和微信，觉得还是银联比较有业界良心。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 支付宝支付]]></title>
    <url>%2F2017%2F04%2F09%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[在开发中，很多时候我们都会用到支付宝支付和微信支付，前段时间已经总结过微信支付流程，这里再说下支付宝支付（相对来说觉得支付宝有点坑），先说下支付宝支付的流程，如下图： 一、支付流程理解先看个图 流程和咱们平时在手机上买东西是一样的：1.用户选好商品后，点击提交订单（一般是这样），选择使用支付宝付款。2.手机客户端（你做的APP）把用户选择的商品的信息传给你们后台服务器。3.后台的服务器将各种数据拼接签名后生成一个签名后的字符串，回传到客户端APP上。4.用户点击确认支付按钮，调用手机支付宝客户端，利用后台传过来的那个参数调起支付宝，让支付宝客户端传给他们服务器交互，进行付款。(这一步是支付宝自己完成的，安全性高)5.支付宝的服务器将支付的结果（可能成功也可能不成功）返回给手机支付宝客户端和你们公司的后台服务器。6.你们公司后台服务器收到后一般是更新下数据信息，手机支付宝客户端会显示一下支付成功。 二、支付流程详解 下载支付宝SDKApp支付DEMO&amp;SDK 进入支付平台注册应用创建应用 获取支付相关的 ‘私钥’ 和 ‘密钥’RSA私钥及公钥生成 集成支付宝SDK可以先看下官方集成文档，下面是一些具体步骤： 4.1 导入文件（如下图） 这里有一个注意点：如果不在客户端上签名，只需要发送订单和处理支付返回结果，只需要添加AlipaySDK.bundle和AlipaySDK.framework就行了。 4.2 导入相关的依赖库 4.3 为URL Types 添加支付宝回调scheme identifier必须为 alipayShareURL Schemes 命名规则：ap+AppID，需要和代码中的一致 4.4 代码部分 发送订单的方法 123- (void)payOrder:(NSString *)orderStrfromScheme:(NSString *)schemeStrcallback:(CompletionBlock)completionBlock; 在AppDelegate中处理事件回调 在 APAppDelegate.m 文件中，增加引用代码：1#import &lt;AlipaySDK/AlipaySDK.h&gt; 在@implementation AppDelegate中增加如下代码： 1234567891011121314151617181920#pragma mark - 处理返回结果- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123;//如果极简开发包不可用，会跳转支付宝钱包进行支付，需要将支付宝钱包的支付结果回传给开发包if ([url.host isEqualToString:@&quot;safepay&quot;]) &#123;[[AlipaySDK defaultService] processOrderWithPaymentResult:url standbyCallback:^(NSDictionary *resultDic) &#123;//【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】NSLog(@&quot;result = %@&quot;,resultDic);&#125;];&#125;if ([url.host isEqualToString:@&quot;platformapi&quot;])&#123;//支付宝钱包快登授权返回authCode[[AlipaySDK defaultService] processAuthResult:url standbyCallback:^(NSDictionary *resultDic) &#123;//【由于在跳转支付宝客户端支付的过程中，商户app在后台很可能被系统kill了，所以pay接口的callback就会失效，请商户对standbyCallback返回的回调结果进行处理,就是在这个方法里面处理跟callback一样的逻辑】NSLog(@&quot;result = %@&quot;,resultDic);&#125;];&#125;return YES;&#125; 集成到这里就差不多了，另外再推荐几篇好文章： 这篇是客户端做的时候遇到的坑：点这里。 如果签名数据是在App上做的，可以参考下这篇文章，已经封装好的，点这里。 这个是官方的集成流程，很详细，点这里。 iOS 集成支付宝 集成支付宝钱包支付iOS SDK的方法与经验]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - AFNetworking - 上传、下载、网络监听]]></title>
    <url>%2F2017%2F04%2F01%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20AFNetworking%20-%20%E4%B8%8A%E4%BC%A0%E3%80%81%E4%B8%8B%E8%BD%BD%E3%80%81%E7%BD%91%E7%BB%9C%E7%9B%91%E5%90%AC%2F</url>
    <content type="text"><![CDATA[这一篇是接着上一篇总结的，如果有朋友需要了解网络请求的内容，可以到这里。和上篇一样，先说下这篇文章的大概内容，以便朋友们能够快速找到自己需要的。这篇文章主要介绍了 AFNetworking 的三个很广泛的应用：上传、下载以及网络监听。如果有朋友想了解苹果自带的 NSURLSession 相关的上传与下载，可以到这里。接下来是使用 AFNetworking 上传、下载以及网络监听的 demo. 一、上传：这里介绍了 AFN 的两种上传方式： 1.通过工程中的文件上传12345// 创建管理者对象AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];// 请求参数NSString *urlStr = @&quot; &quot;; 1234567891011121314151617181920212223242526272829NSDictionary *dic = @&#123;@&quot; &quot; : @&quot; &quot;,@&quot; &quot; : @&quot; &quot;&#125;;// 发送 post 请求，上传一张图片[sessionManager POST:urlStr parameters:dic constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) &#123;NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;a.jpg&quot; ofType:nil];NSData *imgData = [NSData dataWithContentsOfFile:filePath];// 将图片数据拼接，进行上传[formData appendPartWithFileData:imgData name:@&quot;pic&quot; fileName:@&quot;filename&quot; mimeType:@&quot;image/jpg&quot;];&#125; progress:^(NSProgress * _Nonnull uploadProgress) &#123;// 获取上传的进度NSLog(@&quot;%.2f&quot;,uploadProgress.fractionCompleted);NSLog(@&quot;%@&quot;,[NSThread currentThread]); //子线程&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;// 请求成功NSLog(@&quot;请求成功：%@&quot;,responseObject);NSLog(@&quot;%@&quot;,[NSThread currentThread]); //主线程&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;// 请求失败NSLog(@&quot;请求失败：%@&quot;,error);&#125;]; 2.根据URL路径上传123456789101112131415// 创建管理者对象AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];[sessionManager POST:@&quot; &quot; parameters:@&#123;@&quot; &quot; : @&quot; &quot;&#125; constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123;// 在block中设置需要上传的文件[formData appendPartWithFileURL:[NSURL fileURLWithPath:@&quot;文件路径&quot;] name:@&quot;file&quot; error:nil];&#125; success:^(NSURLSessionDataTask *task, id responseObject) &#123;NSLog(@&quot;成功：%@&quot;, responseObject);&#125; failure:^(NSURLSessionDataTask *task, NSError *error) &#123;NSLog(@&quot;失败：%@&quot;, error);&#125;]; 二、下载12345678910111213141516171819202122232425262728293031323334353637// 创建管理者对象AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];// 确定请求的URL地址NSURL *url = [NSURL URLWithString:@&quot; &quot;];// 创建请求对象NSURLRequest *request = [NSURLRequest requestWithURL:url];// 下载文件NSURLSessionDownloadTask *task = [manager downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) &#123;// block会实时调用NSLog(@&quot;%.2f&quot;,downloadProgress.fractionCompleted);&#125; destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) &#123;// NSHomeDirectory()可以得到应用程序目录的路径// 返回一个URL存储文件NSString *filePath = [NSHomeDirectory() stringByAppendingPathComponent:@&quot;Documents/***.mp3&quot;];NSURL *url = [NSURL fileURLWithPath:filePath];return url;&#125; completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) &#123;if (error) &#123;NSLog(@&quot;下载失败 ~~~ %@&quot;,error);&#125;else &#123;NSLog(@&quot;下载成功&quot;);&#125;&#125;];// 开始下载任务[task resume]; 三、网络监听（监听手机网络的不同状态）1234567891011121314151617181920212223242526272829303132333435363738// 获得网络监控的管理者AFNetworkReachabilityManager *manager = [AFNetworkReachabilityManager manager];// 只要网络环境发生变化，就会调用此 block[manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;/* 枚举里面的四个状态AFNetworkReachabilityStatusUnknown = -1, 未知AFNetworkReachabilityStatusNotReachable = 0, 不可用AFNetworkReachabilityStatusReachableViaWWAN = 1, 手机自带网络AFNetworkReachabilityStatusReachableViaWiFi = 2, wifi*/switch (status) &#123;case AFNetworkReachabilityStatusUnknown:NSLog(@&quot;未知&quot;);break;case AFNetworkReachabilityStatusNotReachable:NSLog(@&quot;不可用&quot;);break;case AFNetworkReachabilityStatusReachableViaWWAN:NSLog(@&quot;手机自带网络&quot;);break;case AFNetworkReachabilityStatusReachableViaWiFi:NSLog(@&quot;Wifi&quot;);break;default:break;&#125;&#125;];// 开始监听[manager startMonitoring]; 这是今天做的一些关于 AFNetworking 的总结，如果有错误或疏忽的地方，希望大家能够指出！谢谢大家！！！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - AFNetworking - 网络请求]]></title>
    <url>%2F2017%2F03%2F29%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20AFNetworking%20-%20%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[最近一直很忙也没有时间写博客，今天正好有点空闲时间，所以就对 AFNetworking 做了一些简单的总结，特地记录下来，以便遇到的朋友们看看！！！ 先说下这篇文章的大概内容，以便朋友们能够快速找到自己需要的。这篇文章主要介绍了三种网络请求的渠道，第一种是通过苹果自带的 NSURLSession 请求网络；第二种是通过 AFNetworking2.x 请求网络；最后一种是通过 AFNetworking3.0 请求网络。下边是这三种网络请求渠道的 demo. 一、苹果自带的请求网络方法：这里介绍了三种，GET 请求、POST 请求、代理方式请求。 1.GET 请求:12// 获得 NSURLSession 对象NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:nil delegateQueue:[NSOperationQueue mainQueue]]; 1234567// 创建任务NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot; &quot;]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;NSLog(@&quot;data ~~~ %@ ~~~ response ~~~ %@ ~~~ error~~~ %@&quot;, data, response , error);&#125;];// 启动任务[dataTask resume]; 2.POST 请求:12345678910111213141516171819// 获得NSURLSession对象NSURLSession *session = [NSURLSession sharedSession];// 创建请求NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot; &quot;]];// 设置请求方法request.HTTPMethod = @&quot;POST&quot;;// 设置请求体request.HTTPBody = [@&quot; &quot; dataUsingEncoding:NSUTF8StringEncoding];// 创建任务NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;NSLog(@&quot;data ~~~ %@ ~~~ response ~~~ %@ ~~~ error~~~ %@&quot;, data, response , error);&#125;];// 启动任务[task resume]; 3.代理:NSURLSessionDataDelegate12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)viewDidLoad &#123;[super viewDidLoad];NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot; &quot;]];NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];// 如果创建task时，有block，代理会失效NSURLSessionDataTask *task = [session dataTaskWithRequest:request];[task resume];&#125;#pragma mark - NSURLSessionDataDelegate#pragma mark - 接收到响应头调用的协议方法- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveResponse:(NSURLResponse *)responsecompletionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;NSHTTPURLResponse *httpRes = (NSHTTPURLResponse *)response;NSLog(@&quot;%@&quot;,httpRes.allHeaderFields);//通过设置 completionHandler, Block 可以设置后面的响应体中的数据是否继续发送,默认是不发送completionHandler(NSURLSessionResponseAllow);&#125;#pragma mark - 数据请求完成后，调用的协议方法，data是响应体中的数据- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTaskdidReceiveData:(NSData *)data &#123;NSLog(@&quot;%@&quot;,data);&#125;#pragma mark - 不管请求成功还是失败，最终都会调用此方法- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error &#123;if (error) &#123;NSLog(@&quot;请求失败&quot;);&#125; else &#123;NSLog(@&quot;请求成功&quot;);&#125;&#125; 二、AFNetworking2.x1.GET 请求12345678AFHTTPRequestOperationManager *operationManager = [AFHTTPRequestOperationManager manager];[operationManager GET:@&quot; &quot; parameters:nilsuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;NSLog(@&quot;请求成功&quot;);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;NSLog(@&quot;请求失败&quot;);&#125;]; 2.POST 请求 12345678AFHTTPRequestOperationManager *operationManager = [AFHTTPRequestOperationManager manager];[operationManager POST:@&quot; &quot; parameters:nilsuccess:^(AFHTTPRequestOperation *operation, id responseObject) &#123;NSLog(@&quot;请求成功&quot;);&#125; failure:^(AFHTTPRequestOperation *operation, NSError *error) &#123;NSLog(@&quot;请求失败&quot;);&#125;]; 三、AFNetworking3.01.GET 请求 12345678910111213141516171819AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];// 解析服务器返回的JSON数据// [AFJSONResponseSerializer serializer];// 解析服务器返回的XML数据// [AFXMLParserResponseSerializer serializer];// 参数1: 请求的网址// 参数2: 参数// 参数3: 当前的进度// 参数4: 请求成功// 参数5: 请求失败[sessionManager GET:@&quot; &quot; parameters:nil progress:^(NSProgress * _Nonnull downloadProgress) &#123;NSLog(@&quot;进度&quot;);&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;NSLog(@&quot;请求成功&quot;);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;NSLog(@&quot;请求失败&quot;);&#125;]; 2.POST 请求12345678910111213141516// 创建管理者对象AFHTTPSessionManager *sessionManager = [AFHTTPSessionManager manager];// 设置请求参数NSString *urlStr = @&quot; &quot;;// 需要设置 body 体NSDictionary *dic = @&#123;@&quot; &quot; : @&quot; &quot;,@&quot; &quot; : @&quot; &quot;&#125;;[sessionManager POST:urlStr parameters:dic progress:^(NSProgress * _Nonnull downloadProgress) &#123;NSLog(@&quot;进度&quot;);&#125; success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) &#123;NSLog(@&quot;请求成功&quot;);&#125; failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) &#123;NSLog(@&quot;请求失败&quot;);&#125;]; 上面的一些代码都是基础性代码，因此也没怎么做注释，如果有疑问的话可以私信交流…另外代码有什么问题的话也希望大家能够指出！谢谢大家！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>AFNetworking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - CADisplayLink 实现酷炫动画]]></title>
    <url>%2F2017%2F03%2F21%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20CADisplayLink%20%E5%AE%9E%E7%8E%B0%E9%85%B7%E7%82%AB%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[偶然发现了一个好玩的类， CADisplayLink，出于好奇所以就尝试了一下，用 CADisplayLink 做了个类似云飘的效果。由于对 CADisplayLink 的认识还比较浅，如果哪里写的不正确，还请各位大大能够指出来！看效果图先，就是有点丑，😂 核心代码如下： 一、创建 CADisplayLink，添加事件，绑定 Runloop。1234// 创建 CADisplayLink- (CADisplayLink *)displayLink &#123;if (!_displayLink) &#123;_displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(makeCloud)]; 12345678910111213141516// 当把 CADisplayLink 对象添加到 Runloop 中后，selector就能被周期性调用[self.displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];&#125;return _displayLink;&#125;// 周期调用的方法- (void)makeCloud &#123;self.cloudOffsetX += self.cloudSpeed;[self cloudLayerName:self.firstCloudLayer];[self cloudLayerName:self.secondCloudLayer];[self cloudLayerName:self.thirdCloudLayer];[self cloudLayerName:self.fourthCloudLayer];[self cloudLayerName:self.fifthCloudLayer];&#125; 二、配置参数，加载图层 1234567891011121314 self.cloudWidth = self.frame.size.width; // 云彩宽度 self.cloudColor = RGBA(255, 255, 255, 0.3); // 云彩颜色 self.cloudSpeed = 0.05 / M_PI; // 云彩飘动的速度 self.cloudPointY = 100; // 云彩Y坐标 self.cloudOffsetX = 0; // 云彩位移X self.cloudAmplitude = 30; // 振幅大小 self.cloudCycle = 1.03 * M_PI / self.cloudWidth; // 周期大小 // 添加图层 [self.layer addSublayer:self.firstCloudLayer]; [self.layer addSublayer:self.secondCloudLayer]; [self.layer addSublayer:self.thirdCloudLayer]; [self.layer addSublayer:self.fourthCloudLayer]; [self.layer addSublayer:self.fifthCloudLayer]; 三、创建 CAShapeLayer 动画 12345678910111213141516171819202122232425262728293031323334 // 五个图层动画 - (void)cloudLayerName:(CAShapeLayer *)cloudLayerName &#123; // 创建一个Path句柄 CGMutablePathRef path = CGPathCreateMutable(); CGFloat y = self.cloudPointY; // 初始化该path到一个初始点 CGPathMoveToPoint(path, nil, 0, y); for (float x = 0.0f; x &lt;= self.cloudWidth; x++) &#123; if (cloudLayerName == self.firstCloudLayer) &#123; // 云彩的 Y 值 y = self.cloudAmplitude * sin(self.cloudCycle * x + self.cloudOffsetX - 10) + self.cloudPointY + 10; &#125; else if (cloudLayerName == self.secondCloudLayer) &#123; y = (self.cloudAmplitude + 15) * sin(self.cloudCycle * x + self.cloudOffsetX ) + self.cloudPointY ; &#125; else if (cloudLayerName == self.thirdCloudLayer) &#123; y = (self.cloudAmplitude + 30)* sin(self.cloudCycle * x + self.cloudOffsetX + 20) + self.cloudPointY + 10; &#125; else if (cloudLayerName == self.fourthCloudLayer) &#123; y = (self.cloudAmplitude + 20)* sin(self.cloudCycle * x + self.cloudOffsetX - 20) + self.cloudPointY - 10; &#125; else if (cloudLayerName == self.fifthCloudLayer) &#123; y = (self.cloudAmplitude + 10)* sin(self.cloudCycle * x + self.cloudOffsetX - 10) + self.cloudPointY + 2; &#125; // 添加一条直线 CGPathAddLineToPoint(path, nil, x, y); &#125; // 添加一条直线 CGPathAddLineToPoint(path, nil, self.cloudWidth, self.frame.size.height); // 添加一条直线 CGPathAddLineToPoint(path, nil, 0, self.frame.size.height); // 关闭该path CGPathCloseSubpath(path); cloudLayerName.path = path; // 释放该path CGPathRelease(path); &#125; 推荐几篇和 CADisplayLink 相关的深度好文！ 官方文档 iOS 核心动画高级技巧 CADisplayLink 结合 UIBezierPath的神奇妙用]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>酷炫动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - DZNEmptyDataSet 空白页占位图]]></title>
    <url>%2F2017%2F03%2F19%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20DZNEmptyDataSet%20%E7%A9%BA%E7%99%BD%E9%A1%B5%E5%8D%A0%E4%BD%8D%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[发现了一个很有用的第三方，DZNEmptyDataSet，用起来也极其方便，这里给大家分享下！先说下其用途：DZNEmptyDataSet 主要用于 UITableView 以及 UICollectionView 页面空白时展示（据说也可以用于 UIScrollView， 有兴趣的童鞋可以试试）。开发中之所以用占位图，是为了提高用户体验；而为什么选 DZNEmptyDataSet 而不自行设计占位图（做过占位图的童鞋应该会觉得做占位图并不难，但没有对比就没有伤害，你如果试用了 DZNEmptyDataSet ，就会顿悟自己做占位图是多么地繁琐）。坦白说，DZNEmptyDataSet 是一个为了让开发人员“变懒”的第三方（貌似每个第三方都是这样的“宗旨”），接下来我们就一起看下 DZNEmptyDataSet 吧！ 一、先来认识一下 DZNEmptyDataSet GitHub 地址：DZNEmptyDataSet DZNEmptyDataSet 效果图 二、用 DZNEmptyDataSet 实现占位图效果不得不说，其使用方法极其简单，用 cocoapods 导入可以，直接拖进项目也行。。。接着~~~ 导入头文件 1#import &quot;UIScrollView+EmptyDataSet.h&quot; 添加代理协议 1@interface NNViewController ()&lt;UITableViewDataSource, DZNEmptyDataSetSource, DZNEmptyDataSetDelegate&gt; 设置代理协议 1234567_tableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 0, NNSCREENWIDTH, NNSCREENHEIGHT) style:UITableViewStylePlain];[self.view addSubview:self.tableView];self.tableView.dataSource = self;self.tableView.emptyDataSetSource = self;self.tableView.emptyDataSetDelegate = self;self.tableView.tableFooterView = [[UIView alloc] init]; 设置空白页展示图片 12345#pragma mark - DZNEmptyDataSetSource// 返回图片- (UIImage *)imageForEmptyDataSet:(UIScrollView *)scrollView&#123;return [UIImage imageNamed:@&quot;Screenshot_Slack&quot;];&#125; 到这里简单的占位图已经做好了，是不是觉得 so 轻松 so easy！下面是效果图： 三、接下来是 DZNEmptyDataSet 的其它使用方法DZNEmptyDataSet 框架扩展性极强，可以在占位图上添加图片、标题文字、详情文字等等一堆东西，总有一款适合你！下边是一些具体用法及效果图。 3.1 添加标题文字123456// 返回标题文字- (NSAttributedString *)titleForEmptyDataSet:(UIScrollView *)scrollView &#123;NSString *text = @&quot;这是一张空白页&quot;;NSDictionary *attribute = @&#123;NSFontAttributeName: [UIFont boldSystemFontOfSize:18.0f], NSForegroundColorAttributeName: [UIColor darkGrayColor]&#125;;return [[NSAttributedString alloc] initWithString:text attributes:attribute];&#125; 3.2 添加详情文字12345678// 返回详情文字- (NSAttributedString *)descriptionForEmptyDataSet:(UIScrollView *)scrollView &#123; NSString *text = @&quot;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈&quot;;NSMutableParagraphStyle *paragraph = [NSMutableParagraphStyle new];paragraph.lineBreakMode = NSLineBreakByWordWrapping;paragraph.alignment = NSTextAlignmentCenter;NSDictionary *attribute = @&#123;NSFontAttributeName: [UIFont systemFontOfSize:14.0f], NSForegroundColorAttributeName: [UIColor lightGrayColor], NSParagraphStyleAttributeName: paragraph&#125;;return [[NSAttributedString alloc] initWithString:text attributes:attribute];&#125; 3.3 添加可以点击的按钮 上面带文字1234567891011121314// 返回可以点击的按钮 上面带文字- (NSAttributedString *)buttonTitleForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state &#123;NSDictionary *attribute = @&#123;NSFontAttributeName: [UIFont boldSystemFontOfSize:17.0f]&#125;;return [[NSAttributedString alloc] initWithString:@&quot;哈喽&quot; attributes:attribute];&#125;//#pragma mark - DZNEmptyDataSetDelegate// 处理按钮的点击事件- (void)emptyDataSet:(UIScrollView *)scrollView didTapButton:(UIButton *)button &#123;NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;https://www.baidu.com&quot;]];if ([[UIApplication sharedApplication] canOpenURL:url]) &#123;[[UIApplication sharedApplication] openURL:url];&#125;&#125; 3.4 空白区域点击事件12345// 空白区域点击事件- (void)emptyDataSet:(UIScrollView *)scrollView didTapView:(UIView *)view &#123;UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;哈哈&quot; message:@&quot;最近咋样&quot; delegate:nil cancelButtonTitle:@&quot;别点我&quot; otherButtonTitles:@&quot;点我干啥&quot;, nil];[alert show];&#125; 3.5 改变标题文字与详情文字的距离1234// 标题文字与详情文字的距离- (CGFloat)spaceHeightForEmptyDataSet:(UIScrollView *)scrollView &#123;return 100;&#125; 3.6 空白区域的颜色自定义1234// 返回空白区域的颜色自定义- (UIColor *)backgroundColorForEmptyDataSet:(UIScrollView *)scrollView &#123;return [UIColor cyanColor];&#125; 3.7 标题文字与详情文字同时调整垂直偏移量1234// 标题文字与详情文字同时调整垂直偏移量- (CGFloat)verticalOffsetForEmptyDataSet:(UIScrollView *)scrollView &#123;return -100;&#125; 3.8 添加动画效果123456789101112131415161718192021#pragma mark - DZNEmptyDataSetSource// 返回图片- (UIImage *)imageForEmptyDataSet:(UIScrollView *)scrollView&#123;return [UIImage imageNamed:@&quot;icon_wwdc&quot;];&#125;- (CAAnimation *)imageAnimationForEmptyDataSet:(UIScrollView *)scrollView &#123;CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath: @&quot;transform&quot;];animation.fromValue = [NSValue valueWithCATransform3D:CATransform3DIdentity];animation.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI_2, 0.0, 0.0, 1.0)];animation.duration = 0.25;animation.cumulative = YES;animation.repeatCount = MAXFLOAT;return animation;&#125;#pragma mark - DZNEmptyDataSetDelegate// 图片是否要动画效果，默认NO- (BOOL)emptyDataSetShouldAnimateImageView:(UIScrollView *)scrollView &#123;return YES;&#125; 3.9 其它方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma mark - DZNEmptyDataSetSource// 返回图片的 tintColor- (UIColor *)imageTintColorForEmptyDataSet:(UIScrollView *)scrollView &#123;return [UIColor yellowColor];&#125;// 返回可点击按钮的 image- (UIImage *)buttonImageForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state &#123;return [UIImage imageNamed:@&quot;icon_wwdc&quot;];&#125;// 返回可点击按钮的 backgroundImage- (UIImage *)buttonBackgroundImageForEmptyDataSet:(UIScrollView *)scrollView forState:(UIControlState)state &#123;return [UIImage imageNamed:@&quot;icon_wwdc&quot;];&#125;// 返回自定义 view- (UIView *)customViewForEmptyDataSet:(UIScrollView *)scrollView &#123;return nil;&#125;#pragma mark - DZNEmptyDataSetDelegate// 是否显示空白页，默认YES- (BOOL)emptyDataSetShouldDisplay:(UIScrollView *)scrollView &#123;return YES;&#125;// 是否允许点击，默认YES- (BOOL)emptyDataSetShouldAllowTouch:(UIScrollView *)scrollView &#123;return YES;&#125;// 是否允许滚动，默认NO- (BOOL)emptyDataSetShouldAllowScroll:(UIScrollView *)scrollView &#123;return YES;&#125;// 图片是否要动画效果，默认NO- (BOOL)emptyDataSetShouldAnimateImageView:(UIScrollView *)scrollView &#123;return YES;&#125;// 空白页将要出现- (void)emptyDataSetWillAppear:(UIScrollView *)scrollView &#123;&#125;// 空白页已经出现- (void)emptyDataSetDidAppear:(UIScrollView *)scrollView &#123;&#125;// 空白页将要消失- (void)emptyDataSetWillDisappear:(UIScrollView *)scrollView &#123;&#125;// 空白页已经消失- (void)emptyDataSetDidDisappear:(UIScrollView *)scrollView &#123;&#125; ——————华丽的分割线—————— 小结：本小白只在 UITableView 上试用了 DZNEmptyDataSet 框架。。。公司要求年前再迭代一个版本，时间不太充裕因此没逐一去试。。。哪位大神如果试了 UICollectionView 或 UIScrollView 发现有问题，还请不吝赐教！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>DZNEmptyDataSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - 键盘处理神器 IQKeyboardManager]]></title>
    <url>%2F2017%2F03%2F12%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20%E9%94%AE%E7%9B%98%E5%A4%84%E7%90%86%E7%A5%9E%E5%99%A8%20IQKeyboardManager%2F</url>
    <content type="text"><![CDATA[年后上班第一天，比较闲，上午的时候抽空整理了iOS开发中常用的易忘知识点：iOS开发之 - 小冷易忘知识点总结，有兴趣的朋友们可以去看看。下午整理了之前用过的一个第三方库——键盘处理神器 IQKeyboardManager。 平常在开发中，用到输入框的地方不胜其数，当输入框位于屏幕底部时，弹起的键盘很可能覆盖输入框，导致用户看不到输入结果，体验较差…… IQKeyboardManager 可以很简单快捷的解决键盘遮盖输入框的问题，接下来就一起来学习一下吧。 先简单认识下 IQKeyboardManagerGitHub 地址：GitHub 地址 官方示意效果图如下： 再贴一下自己做的简单效果图☺️先说下我的 Xcode 版本是：Version 8.1 (8B62)，简单起见直接在 Main.storyboard 中拖入 7 个UITextField， 每个 UITextField 都设有占位文字。 以下是 IQKeyboardManager 的一些具体使用1. 用 Cocoapod 导入或直接下载拖进去，这里方便起见直接用 Cocoapod 导入。IQKeyboardManager 的 GitHub地址：IQKeyboardManager 的 GitHub 地址 2. 在 AppDelegate.m 中导入头文件1#import &lt;IQKeyboardManager/IQKeyboardManager.h&gt; 3. 在 AppDelegate 中设置全局属性12345678910111213141516171819202122- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; // 获取类库的单例变量keyboardManager.enable = YES; // 控制整个功能是否启用keyboardManager.shouldResignOnTouchOutside = YES; // 控制点击背景是否收起键盘keyboardManager.shouldToolbarUsesTextFieldTintColor = YES; // 控制键盘上的工具条文字颜色是否用户自定义keyboardManager.toolbarManageBehaviour = IQAutoToolbarBySubviews; // 有多个输入框时，可以通过点击Toolbar 上的“前一个”“后一个”按钮来实现移动到不同的输入框keyboardManager.enableAutoToolbar = YES; // 控制是否显示键盘上的工具条keyboardManager.shouldShowTextFieldPlaceholder = YES; // 是否显示占位文字keyboardManager.placeholderFont = [UIFont boldSystemFontOfSize:17]; // 设置占位文字的字体keyboardManager.keyboardDistanceFromTextField = 10.0f; // 输入框距离键盘的距离return YES;&#125; 4. 若某个类不需要使用 IQKeyboardManager，可以在这个类中这样设置123456789- (void)viewWillAppear:(BOOL)animated &#123;[super viewWillAppear:animated];[IQKeyboardManager sharedManager].enable = NO;&#125;- (void)viewWillDisappear:(BOOL)animated &#123;[super viewWillDisappear:animated];[IQKeyboardManager sharedManager].enable = YES;&#125; 5. 常用属性介绍 sharedManager：获取类库的单例变量 enable：项目使用不使用 IQKeyboardManager 这个类库，当然，某些页面可以根据需要单独设置 shouldResignOnTouchOutside：点击背景页面时是否收起键盘 shouldToolbarUsesTextFieldTintColor：控制键盘上的工具条文字颜色是否用户自定义，默认为 NO toolbarManageBehaviour：有多个输入框时，可以通过点击Toolbar 上的“前一个” “后一个”按钮来实现移动到不同的输入框 enableAutoToolbar：是否显示键盘上的工具条 shouldShowTextFieldPlaceholder：是否显示占位文字（如果输入框有占位文字，那么在 Toolbar 中默认会显示出来） placeholderFont：占位文字的字体大小 keyboardDistanceFromTextField：输入框距离键盘的距离 6. 再推荐几篇不错的相关文章 iOS开发第三方库一 IQKeyboardManager 自动处理键盘事件的第三方库 IQKeyboardManager iOS开发之处理键盘问题神器IQKeyboardManager]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>IQKeyboardManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - MD5加密]]></title>
    <url>%2F2017%2F02%2F19%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20MD5%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[MD5（消息摘要算法第五版）是计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。 MD5特点：1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。2、容易计算：从原数据计算出MD5值很容易。3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。4、强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 事先介绍一个概念，因为下边有用到👇加盐：所谓加盐， 就是在原本需要加密的信息基础上，糅入其它内容salt。 接下来是一些代码的实现，方便起见，这里创建了一个分类NSString+MD5。 分类 NSString+MD5.h 中的代码如下： 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface NSString (MD5)/** 直接加密 */- (NSString *)MD5_32BIT;/** 加盐 */- (NSString *)MD5_saltStr:(NSString *)saltStr;/** 多次加密 */- (NSString *)MD5_againStr:(NSString *)againStr;/** 乱序加密 */- (NSString *)MD5_Chaos:(NSString *)chaosStr;@end 这里是分类 NSString+MD5.m 中的代码，需要导入头文件 #import &lt;CommonCrypto/CommonDigest.h&gt;： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#import &quot;NSString+MD5.h&quot;#import &lt;CommonCrypto/CommonDigest.h&gt;#define salt @&quot;qwertyuiop&quot;@implementation NSString (MD5)// 直接加密- (NSString *)MD5_32BIT &#123;const char *cStr = [self UTF8String];unsigned char digest[CC_MD5_DIGEST_LENGTH];CC_MD5( cStr, (CC_LONG)self.length, digest );NSMutableString *result = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH * 2];for(int i = 0; i &lt; CC_MD5_DIGEST_LENGTH; i++)[result appendFormat:@&quot;%02X&quot;, digest[i]];return result;&#125;// 加盐- (NSString *)MD5_saltStr:(NSString *)saltStr &#123;saltStr = [saltStr stringByAppendingString:salt];NSString *result =[saltStr MD5_32BIT];return result;&#125;// 多次加密- (NSString *)MD5_againStr:(NSString *)againStr &#123;NSString *result = [againStr MD5_32BIT];result = [result MD5_32BIT];return result;&#125;// 乱序加密- (NSString *)MD5_Chaos:(NSString *)chaosStr &#123;NSString *result =[chaosStr MD5_32BIT];NSString *header =[result substringFromIndex:2];NSString *footer=[result substringFromIndex:2];result =[footer stringByAppendingString:header];return result;&#125;@end 接着在控制器中调用：123456789101112131415#import &quot;ViewController.h&quot;#import &quot;NSString+MD5.h&quot;@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];NSString *string = @&quot;10.24&quot;;// 调用 MD5 加密并打印结果NSLog(@&quot;MD5Result = %@&quot;, [string MD5_32BIT]);NSLog(@&quot;MD5_saltResult = %@&quot;, [string MD5_saltStr:string]);NSLog(@&quot;MD5_againResult = %@&quot;, [string MD5_againStr:string]);NSLog(@&quot;chaosResult = %@&quot;, [string MD5_Chaos:string]);&#125; 这里是打印结果：12342016-10-26 08:15:49.616 md5[92278:6185546] MD5Result = F7F942B87C2D0B62FC27AD465CF0D05B2016-10-26 08:15:49.616 md5[92278:6185546] MD5_saltResult = 1C2140C07ADD1E334896D499E8C4968C2016-10-26 08:15:49.617 md5[92278:6185546] MD5_againResult = 01AE5309B5A8E672AE4D427FE987E06A2016-10-26 08:15:49.617 md5[92278:6185546] chaosResult = F942B87C2D0B62FC27AD465CF0D05BF942B87C2D0B62FC27AD465CF0D05B 总结：大家应该都知道有一个MD5破解网站，名字叫做 md5在线解密加密，因此我们在使用MD5加密的时候，最好使用多次加密，加盐，乱序加密等，不然会很容易被破解。至于其它加密，等以后用到了会继续整理出来，如果文章有什么不足之处，还请朋友们能过指出来，谢谢大家！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - RunLoop]]></title>
    <url>%2F2017%2F02%2F09%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20RunLoop%2F</url>
    <content type="text"><![CDATA[以下是 RunLoop 相关的内容，前半部分是理论知识，后半部分是代码。。。 一、RunLoop 基础知识1.1 RunLoop 简介一般来说，一个线程只能执行一个任务，执行完就会退出，如果我们需要一种机制，让线程能随时处理时间但并不退出，那么 RunLoop 就是这样的一个机制。Runloop是事件接收和分发机制的一个实现。所以它实际上是一个对象，这个对象管理了其需要处理的事件和消息。在iOS 系统中，有这样两个对象： NSRunLoop 和 CFRunLoopRef。 NSRunLoop 和 CFRunLoopRef都代表着 RunLoop 对象。 1.2 RunLoop的基本作用(1)保持程序的持续运行；(2)处理 App 中的各种事件(比如触摸事件、定时器事件、Selector 事件)；(3)节省 CPU 资源, 提高程序性能。 1.3 RunLoop的使用环境仅当在为你的程序创建辅助线程的时候，你才需要显示运行 RunLoop 。对于辅助线程，你需要判断一个 RunLoop 是否是必须的。如果是必须的，那么你要自己配置并启动它，你不需要再任何情况下都去启动一个线程的 RunLoop 。 RunLoop 在你要和线程有更多的交互时才需要，比如以下情况：(1)使用端口或者自定义输入源来和其他线程通信；(2)使用线程的定时器；(3) Cocoa 中使用任何 performSelector 的方法；(4)使线程周期性工作。 1.4 RunLoop工作的特点:(1)当有时间发生时, RunLoop 会根据具体的事件类型通知应用程序作出响应；(2)当没有事件发生时, RunLoop 会进入休眠状态；(3)当事件再次发生时, RunLoop 会被重新唤醒, 处理事件。 1.5 runLoop的内部逻辑runLoop其实是一个函数，其内部是一个 do-while 循环，当你调用CFRunLoop() 时，线程就会一直停留在这个循环中；直到超时或被手动停止，该函数才会返回。每次运行 runLoop，线程的 runLoop 会自动处理之前未处理的消息，并通知相关的观察者，具体的顺序如下：(1)通知观察者 runLoop 已经启动；(2)通知观察者处理将要开始的定时器；(3)通知观察者处理即将启动的非基于端口的源；(4)处理非基于端口的源；(5)如果基于端口的源准备好并处于等待状态，立即启动进入步骤⑨；(6)通知观察者线程即将进入休眠；(7)线程处于休眠状态，直到下面的任意的一个事件发生：A.某一时间到达基于端口的源；B.定时器启动；C.runLoop被外部手动唤醒；(8)通知观察者线程刚被唤醒；(9)处理接收到的事件，处理定时器并重启 runLoop，进入步骤2；(10)通知观察者，即将退出 runLoop。 1.6 RunLoop与线程的关系(1)每条线程都有唯一的一个与之对应的 RunLoop 对象；(2)主线程的 RunLoop 已经自动创建好了, 子线程的 RunLoop 需要手动创建；(3) RunLoop在第一次获取时创建, 在线程结束时销毁；(4)直线线程与圆形线程：直线线程执行的任务是一条直线；而圆形线程不断循环，直到通过某种方式截止，在 iOS 中，圆形线程就是通过 runLoop 实现的。 1.7 RunLoop对象(1) iOS中有2套 API 来访问和使用 RunLoop。Foundation框架 : NSRunLoop；Core Foundation框架: CFRunLoopRef。 (2) NSRunLoop 和 CFRunLoopRef 都代表着 RunLoop 对象 ,它们是等价的，可以互相转换； (3) NSRunLoop 是基于 CFRunLoopRef 的一层 OC 包装，所以要了解 RunLoop 内部结构，需要多研究 CFRunLoopRef 层面的 API（Core Foundation层面）。 1.8获得 RunLoop 对象苹果不允许直接创建RunLoop，它只提供了两个自动获取的函数。(1) Foundation [NSRunLoop currentRunLoop]; //获得当前线程的 RunLoop 对象[NSRunLoop mainRunLoop]; //获得主线程的 RunLoop 对象 (2) Core FoundationCFRunLoopGetCurrent(); //获得当前线程的 RunLoop 对象CFRunLoopGetMain(); //获得主线程的 RunLoop 对象 1.9 相关类:Core Foundation中关于 RunLoop 的 5 个类 ,RunLoop 如果没有这些东西, 会直接退出。(1) CFRunLoopRef(2) CFRunLoopModeRef 该类并没有对外暴露；(3) CFRunLoopSourceRef(4) CFRunLoopTimerRef(5) CFRunLoopObserverRef 1.10 CFRunLoopSourceRef 事件源(输入源)时间产生的地方，source 有两个版本：(1) source0：只包含一个回调，它并不能主动触发事件，使用时，需先调用 CFRunLoopSourceSignal 将这个 source 标记为待处理，后调用 CFRunLoopWakeUp 来唤醒 runLoop，让其处理这个事件；(2) source1：包含一个 mach_port 和一个回调，被用于通过内核和其他线程互发送消息，这种 source 能主动唤醒 runLoop 线程。 1.11 CFRunLoopObserverRefCFRunLoopObserverRef是观察者,能够监听 RunLoop 的状态改变,当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入 Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), //即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), //即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), //刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), //即将退出 Loop 1.12 runLoop的模式runLoop 中使用 mode 来指定时间在运行循环中的优先级，系统默认注册了 5 个Mode：(1)NSDefaultRunLoopMode（kCFRunLoopDefaultMode）:默认Mode,通常主线程是在这个Mode下运行； (2) UITrackingRunLoopMode:界面跟踪Mode,用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响； (3) UIInitializationRunLoopMode:启动程序后的过渡 mode，启动完成后就不再使用； (4) GSEventReceiveRunLoopMode:接受系统事件的内部 Mode,通常用不到； (5)kCFRunLoopCommonModes（NSRunLoopCommonModes）: 这是一个占位用的 Mode ，作为标记 DefaultMode 和CommonMode 用。 二、演示代码演示代码一:常驻线程控制器.m中的代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)viewDidLoad &#123;[super viewDidLoad];self.thread = [[NNThread alloc] initWithTarget:self selector:@selector(run) object:nil];[self.thread start];&#125;#pragma mark -常驻线程方式一- (void)run &#123;@autoreleasepool &#123;[[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];NSLog(@"-- run -- %@ --", [NSThread currentThread]);[[NSRunLoop currentRunLoop] run];NSLog(@"--不会执行--"); // 不会执行&#125;&#125;#pragma mark -常驻线程方式二- (void)run1&#123;@autoreleasepool &#123;while (1) &#123;[[NSRunLoop currentRunLoop] run];NSLog(@"-- run1 -- %@ --", [NSThread currentThread]);&#125;&#125;&#125;#pragma mark -常驻线程方式三- (void)run2&#123;@autoreleasepool &#123;[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];NSLog(@"-- run2 -- %@ --", [NSThread currentThread]);[[NSRunLoop currentRunLoop] run];&#125;&#125;#pragma mark -在该线程中自定义事件- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;[self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;- (void)test &#123;NSLog(@"-- test -- %@ --", [NSThread currentThread]);&#125; 线程子类化: 123456789#import "NNThread.h"@implementation NNThread#pragma mark -重写了 dealloc 方法,查看线程是否销毁- (void)dealloc &#123;NSLog(@"线程 NNThread 被销毁"); // 不会打印&#125;@end 演示代码二: GCD 定时器:123456789101112131415161718192021222324252627#pragma mark - GCD 的 timer- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&#123;//获得队列dispatch_queue_t queue = dispatch_get_main_queue();//创建一个定时器 (dispatch_source_t 本质还是个 OC 对象)self.timer =dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);// GCD的时间参数，一般是纳秒（1秒== 10的9次方纳秒）dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC));uint64_t interval = (uint64_t)(1.0 * NSEC_PER_SEC);dispatch_source_set_timer(self.timer, start, interval, 0);//设置回调dispatch_source_set_event_handler(self.timer, ^&#123;NSLog(@"------ %@ ------", [NSThread currentThread]);count++;if (count == 10) &#123;//取消定时器dispatch_cancel(self.timer);self.timer = nil;&#125;&#125;);//启动定时器dispatch_resume(self.timer);&#125; 演示代码三:观察者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#pragma mark -观察者-(void)observerTest&#123;/**CFRunLoopObserverRef是观察者, 能够监听 RunLoop 的状态改变,当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。CFRunLoopObserverRef参数:第一个参数:分配存储空间第二个参数:监听状态第三个参数:是否要持续监听第四个参数:优先级第五个参数:回调*///创建observerCFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;switch (activity) &#123;case kCFRunLoopEntry:NSLog(@"即将进入runloop");break;case kCFRunLoopBeforeTimers:NSLog(@"RunLoop即将处理 timer");break;case kCFRunLoopBeforeSources:NSLog(@"RunLoop即将处理Sources");break;case kCFRunLoopBeforeWaiting:NSLog(@"RunLoop即将进入休眠");break;case kCFRunLoopAfterWaiting:NSLog(@"RunLoop刚从休眠中唤醒");break;case kCFRunLoopExit:NSLog(@"即将退出RunLoop ");break;default:break;&#125;&#125;);/**RunLoop的模式1.NSDefaultRunLoopMode（kCFRunLoopDefaultMode）:默认Mode,通常主线程是在这个Mode下运行2.UITrackingRunLoopMode:界面跟踪 Mode, 用于 ScrollView 追踪触摸滑动, 保证界面滑动时不受其他 Mode 影响3.UIInitializationRunLoopMode:启动程序后的过渡 mode，启动完成后就不再使用4.GSEventReceiveRunLoopMode:接受系统事件的内部 Mode,通常用不到5.kCFRunLoopCommonModes（NSRunLoopCommonModes）: 这是一个占位用的 Mode, 作为标记 DefaultMode 和 CommonMode 用*//**CFRunLoopAddObserver参数:第一个参数:要监听哪个RunLoop第二个参数:监听者第三个参数:要监听RunLoop在哪种运行模式下的状态*/// 添加观察者：监听RunLoop的状态CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);// 释放 ObserverCFRelease(observer);&#125;- (void)timerTest&#123;//调用了 scheduledTimer 返回的定时器，已经自动被添加到当前 RunLoop 中，默认是 NSDefaultRunLoopModeNSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];//修改模式[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&#125; end 结束语：RunLoop 的总结就到此为止了，以后如果想到或遇到新知识点，会再来补充！另外如果文章写的有什么错误，烦请各位能指出来！谢谢大家！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - Runtime]]></title>
    <url>%2F2017%2F02%2F06%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20Runtime%2F</url>
    <content type="text"><![CDATA[想总结 Runtime 不是一天两天了，前几天利用空闲时间已经打好文稿，但觉得还有需要改进的地方，现在已经改过来了，这里贴出来与大家分享下（如果还有什么小问题，还望各位朋友指出来哈）! 下面我们就开始进入运行时 Runtime 的世界吧！ 一、Runtime简介Runtime简称运行时，是系统在运行的时候的一些机制，其中最主要的是消息机制。它是一套比较底层的纯 C 语言 API, 属于一个 C 语言库，包含了很多底层的 C 语言 API。我们平时编写的 OC 代码，在程序运行过程时，其实最终都是转成了 Runtime 的 C 语言代码。如下所示: 12345// OC代码:[Person coding];//运行时 runtime 会将它转化成 C 语言的代码:objc_msgSend(Person, @selector(coding)); 二、相关函数1234567891011121314151617181920212223// 遍历某个类所有的成员变量class_copyIvarList// 遍历某个类所有的方法class_copyMethodList// 获取指定名称的成员变量class_getInstanceVariable// 获取成员变量名ivar_getName// 获取成员变量类型编码ivar_getTypeEncoding// 获取某个对象成员变量的值object_getIvar// 设置某个对象成员变量的值object_setIvar// 给对象发送消息objc_msgSend 三、相关应用 1.利用Runtime遍历模型对象的所有属性 2.归档与解档 3.字典模型互转(利用 Runtime 遍历模型对象的所有属性, 根据属性名从字典中取出对的值,设置到模型的属性上) 4.动态添加/修改属性、动态添加/修改/替换方法(修改Person的身高体重等；替换 coding 方法为 eating 等) 四、演示代码演示代码一：遍历对象的属性新建一个Person类，继承自NSObject，在.h文件中设置它的属性如下 1234567891011@interface NNPerson : NSObject &#123;NSString * _str1;&#125;@property NSString * str2;@property (nonatomic, copy) NSString *str3;@property (nonatomic, copy) NSDictionary * dict;@property (nonatomic, copy) NSArray *ary; 在 ViewController 中获取它的属性，代码如下 123456789101112131415161718192021#import &quot;ViewController.h&quot;#import &lt;objc/runtime.h&gt;#import &quot;NNPerson.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123;[super viewDidLoad];// 获取 NNModel 中所有的变量并且输出变量名及类型unsigned int count = 0;Ivar * ivars = class_copyIvarList([NNPerson class], &amp;count);for (unsigned int i = 0; i &lt; count; i ++) &#123;Ivar ivar = ivars[i];NSLog(@&quot;类型: %s -名字: %s &quot;, ivar_getTypeEncoding(ivar), ivar_getName(ivar));&#125;free(ivars);&#125; 演示代码二：归档解档新建一个类，继承自 NSObject 。.m中的代码如下： 12345678910111213141516171819202122232425262728293031323334353637#pragma mark -归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123;unsigned int count = 0;//获取类中所有属性Ivar *vars = class_copyIvarList([self class], &amp;count);for (unsigned int i = 0; i &lt; count; i ++) &#123;Ivar var = vars[i];const char *name = ivar_getName(var);NSString *key = [NSString stringWithUTF8String:name];//利用 KVC 进行取值，根据属性名称获取对应的值id value = [self valueForKey:key];[aCoder encodeObject:value forKey:key];&#125;free(vars);&#125;#pragma mark -解档- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder &#123;if (self = [super init]) &#123;unsigned int count = 0;//获取类中所有属性Ivar *vars = class_copyIvarList([self class], &amp;count);for (unsigned int i = 0; i &lt; count; i ++) &#123;Ivar var = vars[i];const char *name = ivar_getName(var);NSString *key = [NSString stringWithUTF8String:name];//进行解档取值id value = [aDecoder decodeObjectForKey:key];//利用 KVC 对属性赋值[self setValue:value forKey:key];&#125;free(vars);&#125;return self;&#125; ViewController中的代码：123456789- (void)viewDidLoad &#123;[super viewDidLoad];LZNArchive *archive = [LZNArchive objectWithKeyValues:self.Mydictionary];NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).lastObject;path = [path stringByAppendingPathComponent:@&quot;hello&quot;];[NSKeyedArchiver archiveRootObject:archive toFile:path];LZNArchive *m = [NSKeyedUnarchiver unarchiveObjectWithFile:path];&#125; 演示代码三：字典与模型互转首先应导入一个 plist 文件，将文件中的内容读取到字典中；然后新建一个分类如: NSObject+KeyValues123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#pragma mark -字典转模型+(instancetype)objectWithDict:(NSDictionary *)dict &#123;id objc = [[self alloc] init];//遍历字典中的属性for (NSString *key in dict.allKeys) &#123;id value = dict[key];objc_property_t property = class_getProperty(self, key.UTF8String);unsigned int count = 0;objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;count);objc_property_attribute_t attribute = attributeList[0];NSString *string = [NSString stringWithUTF8String:attribute.value];if ([string isEqualToString:@"@\"LZNArchive\""]) &#123;value = [self objectWithDict:value];&#125;//生成 setter 方法，并用 objc_msgSend 调用NSString *methodName = [NSString stringWithFormat:@"set%@%@:",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];SEL setter = sel_registerName(methodName.UTF8String);if ([objc respondsToSelector:setter]) &#123;((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);&#125;free(attributeList);&#125;return objc;&#125;#pragma mark -模型转字典-(NSDictionary *)keyValuesWithObject &#123;unsigned int count = 0;objc_property_t *propertyList = class_copyPropertyList([self class], &amp;count);NSMutableDictionary *dict = [NSMutableDictionary dictionary];//遍历模型中属性for (int i = 0; i &lt; count; i ++) &#123;objc_property_t property = propertyList[i];//生成 getter 方法，并用 objc_msgSend 调用const char *propertyName = property_getName(property);SEL getter = sel_registerName(propertyName);if ([self respondsToSelector:getter]) &#123;id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);//判断当前属性if ([value isKindOfClass:[self class]] &amp;&amp; value) &#123;value = [value keyValuesWithObject];&#125;if (value) &#123;NSString *key = [NSString stringWithUTF8String:propertyName];[dict setObject:value forKey:key];&#125;&#125;&#125;free(propertyList);return dict;&#125; 演示代码四：objc_msgSend 消息传递新建一个类，继承自NSObject，.m中的代码如下:1234567891011121314151617181920- (void)sayHello &#123;NSLog(@&quot;Hello!&quot;);&#125;-(void)showName:(NSString *)name &#123;NSLog(@&quot;My name is %@&quot;,name);&#125;-(void)showAge:(NSInteger)age &#123;NSLog(@&quot;My age is %ld&quot;, age);&#125;-(float)showHeight&#123;return 180.0f;&#125;-(NSString *)showInformation &#123;return @&quot;Nice to meet you!&quot;;&#125; ViewController中的代码:1234567891011121314LZN_msgSend *msgSend = [[LZN_msgSend alloc] init];((void (*) (id, SEL)) objc_msgSend) (msgSend, sel_registerName("sayHello"));((void (*) (id, SEL, NSString *)) objc_msgSend) (msgSend, sel_registerName("showName:"), @"Liu Zhong Ning");((void (*) (id, SEL, NSInteger)) objc_msgSend) (msgSend, sel_registerName("showAge:"), 23);float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (msgSend, sel_registerName("showHeight"));NSLog(@"and height is %.2fcm",f);NSString *information = ((NSString* (*) (id, SEL)) objc_msgSend) (msgSend, sel_registerName("showInformation"));NSLog(@"%@",information); the end 结束语：Runtime 相关的知识就整理了这么些，希望对看到的朋友们有用！另外如果 demo 有什么问题，还烦请大家告知，一起进步！谢谢O(∩_∩)O~! 另祝大家周末愉快哈！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - SDWebImage 的使用]]></title>
    <url>%2F2017%2F01%2F08%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20SDWebImage%20%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SDWebImage 是一个开源的第三方库，在我们 iOS 开发中用到 SDWebImage 的地方有很多，比如在 tableView 中，在 collectionView 中……不然它也不会高达 16000+ 这么多的 Star 了😄。下面是总结的一些 SDWebImage 相关的具体用法。 首先用 cocoapods 导入 SDWebImage 框架，网上有很多安装以及使用 cocoapods 的教程，在此就不累述了，这篇文章的内容是在导入 SDWebImage 基础之上的，主要是总结了一些 SDWebImage 的具体用法。 简单下载图片123方式一：// 只下载图片[self.imageView sd_setImageWithURL:@&quot;URL地址&quot;]]; 12345678方式二：/**第一个参数:图片的url第二个参数:占位图片*/[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]placeholderImage:[UIImage imageNamed: @&quot;占位图片名&quot;]]; 下载成功或失败之后做的事情 12345678910111213141516171819202122232425262728293031323334353637方式一：/**第一个参数:图片的urlblock:下载成功或失败之后的回调*/[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123;NSLog(@&quot;下载成功或失败之后的回调&quot;);&#125;];方式二：/**第一个参数:图片的url第二个参数:占位图片block:下载成功或失败之后的回调*/[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]placeholderImage:[UIImage imageNamed: @&quot;占位图片名&quot;]completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123;NSLog(@&quot;下载成功或失败之后的回调&quot;);&#125;];方式三：/**第一个参数:图片的url第二个参数:占位图片第三个参数:下载图片的策略第四个参数:progress进度第五个参数:completed 下载完成之后的回调*/[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]placeholderImage:[UIImage imageNamed: @&quot;占位图片名&quot;]options:SDWebImageRetryFailedprogress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;NSLog(@&quot;progress进度&quot;);&#125;completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL) &#123;NSLog(@&quot;下载成功或失败之后的回调&quot;);&#125;]; 借用一个方法简单的介绍一下 options 中的选项 123456789101112131415161718192021222324252627/**//失败后重试SDWebImageRetryFailed = 1 &lt;&lt; 0,//UI交互期间开始下载，导致延迟下载比如UIScrollView减速。SDWebImageLowPriority = 1 &lt;&lt; 1,//只进行内存缓存SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//这个标志可以渐进式下载,显示的图像是逐步在下载SDWebImageProgressiveDownload = 1 &lt;&lt; 3,//刷新缓存SDWebImageRefreshCached = 1 &lt;&lt; 4,//后台下载SDWebImageContinueInBackground = 1 &lt;&lt; 5,//NSMutableURLRequest.HTTPShouldHandleCookies = YES;SDWebImageHandleCookies = 1 &lt;&lt; 6,//允许使用无效的SSL证书//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,//优先下载SDWebImageHighPriority = 1 &lt;&lt; 8,//延迟占位符SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,//改变动画形象SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,*/[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]placeholderImage:[UIImage imageNamed: @&quot;占位图片名&quot;]options:SDWebImageRetryFailed]; 使用 SDWebImageManager 下载图片 123456789101112131415161718SDWebImageManager *imageManager = [SDWebImageManager sharedManager];/**第一个参数:图片的url第二个参数:下载图片的(策略)第三个参数:progress进度第四个参数:completed 下载完成之后的回调*/[imageManager downloadImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]options:SDWebImageRetryFailedprogress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;NSLog(@&quot;progress进度&quot;);&#125;completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;NSLog(@&quot;下载成功或失败之后的回调&quot;);if (image) &#123;self.image = image;&#125;&#125;]; 使用 SDWebImageDownloader 下载图片 123456789101112131415161718SDWebImageDownloader *imageDownloader = [SDWebImageDownloader sharedDownloader];/*第一个参数:图片的url第二个参数:下载图片的策略第三个参数:progressBlock 进度第四个参数:completedBlock 下载完成之后的回调*/[imageDownloader downloadImageWithURL:[NSURL URLWithString:@&quot;URL地址&quot;]options:SDWebImageDownloaderLowPriorityprogress:^(NSInteger receivedSize, NSInteger expectedSize) &#123;NSLog(@&quot;progress进度&quot;);&#125;completed:^(UIImage *image, NSData *data, NSError *error, BOOL finished) &#123;NSLog(@&quot;下载成功或失败之后的回调&quot;);if (image) &#123;self.image = image;&#125;&#125;]; 内存警告时调用 12345678910// 当程序收到内存警告时会调用这个方法- (void)didReceiveMemoryWarning &#123;[super didReceiveMemoryWarning];// 清除缓存[[SDWebImageManager sharedManager].imageCache clearDisk]; // clean:删除过期缓存[[SDWebImageManager sharedManager].imageCache cleanDisk]; // clear:直接删除然后重新创建// 取消下载[[SDWebImageManager sharedManager] cancelAll];&#125; 其它一些很有用的方法 12345678910111213141516171819202122// 取消掉当前所有的下载- (void)cancelAll;// 检查是否有图片在下载- (BOOL)isRunning;// 将图片存入cache的方法- (void)saveImageToCache:(UIImage *)image forURL:(NSURL *)url;// 通过图片的url判断其是否已经存在- (BOOL)cachedImageExistsForURL:(NSURL *)url;// 检测一个image是否已经被缓存到磁盘(是否存且仅存在disk里).- (BOOL)diskImageExistsForURL:(NSURL *)url;// 如果检测到图片已经被缓存,那么执行回调block- (void)cachedImageExistsForURL:(NSURL *)urlcompletion:(SDWebImageCheckCacheCompletionBlock)completionBlock;// 如果检测到图片已经在磁盘中,那么执行回调block- (void)diskImageExistsForURL:(NSURL *)urlcompletion:(SDWebImageCheckCacheCompletionBlock)completionBlock; 以上是关于 SDWebImage 的一些用法总结，以后再用到其它的了，会再来补充。另外如果有写错的地方，欢迎朋友们指正！谢谢😊！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之 - WKWebView VS UIWebView]]></title>
    <url>%2F2017%2F01%2F06%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%20-%20WKWebView%20VS%20UIWebView%2F</url>
    <content type="text"><![CDATA[WKWebView是苹果在 iOS 8 中推出的新框架，相比UIWebView来说，WKWebView 性能好，速度快，内存小，功能多，且支持了更多的 HTML5 特性……因此本小白禁不住“诱惑”利用了一晚上的时间，整理了一些关于 WKWebView 的资料，与大家分享下！在说 WKWebView 之前，我们先说说他的老大哥 UIWebView ！！！ UIWebView 是苹果在 iOS 2 之后推出的，由于资格比较“老”，大家对 UIWebView 应该也不会陌生，这里直接上代码： 1.UIWebView 基本使用12345678// 创建webviewUIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 20, NNWidth, NNHeight - 20)];// 网络请求NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];// 加载网页[webView loadRequest:request];// 添加到界面[self.view addSubview:webView]; 2.UIWebView 常用方法1234567[webView reload]; // 刷新[webView stopLoading]; // 停止加载[webView goBack]; // 后退[webView goForward]; // 前进[webView canGoBack]; // 是否可以后退[webView canGoForward]; // 是否可以向前[webView isLoading]; // 是否正在加载 3.UIWebView 相关代理协议1234567891011121314151617181920#pragma mark - UIWebViewDelegate/// 是否允许加载网页- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;NSLog(@&quot;允许加载网页&quot;);return YES;&#125;/// 开始加载网页时调用- (void)webViewDidStartLoad:(UIWebView *)webView &#123;NSLog(@&quot;开始加载网页&quot;);&#125;/// 网页加载完成时调用- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;NSLog(@&quot;网页加载完成&quot;);&#125;/// 网页加载错误时调用- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error &#123;NSLog(@&quot;网页加载错误时调用&quot;);&#125; 这里是 UIWebView 的效果图！！！ 因为主要想与大家分享的是 WKWebView，所以对 UIWebView 的介绍就到此为止了。接下来的 WKWebView 才是今晚的主角！！！ 依然是先介绍 WKWebView 的基本使用 1. WKWebView 基本使用 这里加一个不用提示的提示：WKWebView 和 UIWebview 的基本使用方法相类似，但是需要导入头文件 #import &lt;WebKit/WebKit.h&gt;，其它步骤如下 12345678// 创建webviewWKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 20, NNWidth, NNHeight - 20)];// 创建请求NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];// 加载网页[webView loadRequest:request];// 将webView添加到界面[self.view addSubview:webView]; ps:这里就不再补充效果图了，除了速度内存优于 UIWebView，显示的效果差不多。。。 2. WKWebView 加载文件12345678// 创建webviewWKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 20, NNWidth, NNHeight - 20)];// 创建url(可以随便从桌面拉张图片)NSURL *url = [NSURL fileURLWithPath:@&quot;/Users/ios/Desktop/图片/90416596477f347431a929dc73b9f404.jpg&quot;];// 加载文件[webView loadFileURL:url allowingReadAccessToURL:url];// 最后将webView添加到界面[self.view addSubview:webView]; 这里是加载文件效果图！ 3. WKWebView 与 JS 代码交互1234567891011// 图片缩放的 JS 代码NSString *JSImage = @&quot;var count = document.images.length;for (var i = 0; i &lt; count; i++) &#123;var image = document.images[i];image.style.width=375;&#125;;window.alert(&apos;找到&apos; + count + &apos;张图&apos;);&quot;;// 初始化 WKUserScriptWKUserScript *script = [[WKUserScript alloc] initWithSource:JSImage injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];// 初始化WKWebViewConfigurationWKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];[configuration.userContentController addUserScript:script];_webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];// 这里需要从网上找到一张图片的地址[_webView loadHTMLString:@&quot;&lt;head&gt;&lt;/head&gt;![](http://upload-images.jianshu.io/upload_images/2665449-f109bc70619e2a92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)&quot;baseURL:nil];[self.view addSubview:_webView]; 4. WKWebView 常用的代理协议WKWebView 的代理方法还是蛮有趣的，大家可以试下哈！ 4.1 WKNavigationDelegate 协议这里简单罗列了几个常用的方法。以下四个与 UIWebView 中的方法相同：1234567891011121314151617#pragma mark - WKNavigationDelegate// 页面开始加载时调用- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation &#123;&#125;// 内容开始返回时调用- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123;&#125;// 页面加载完成时调用- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation &#123;&#125;// 页面加载失败时调用- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation &#123;&#125; 新增的三个代理方法:12345678910111213// 这个方法是服务器重定向时调用，即 接收到服务器跳转请求之后调用- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation &#123;&#125;// 在收到响应后，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;&#125;// 在发送请求之前，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;&#125; 4.2 WKUIDelegate 协议123456789101112131415161718192021222324252627282930#pragma mark - WKUIDelegate/// 创建一个新的WebView- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures &#123;return nil;&#125;/*** web界面中有弹出警告框时调用** @param webView 实现该代理的webview* @param message 警告框中的内容* @param frame 主窗口* @param completionHandler 警告框消失调用*/- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(void (^)())completionHandler &#123;&#125;/// 输入框- (void)webView:(WKWebView *)webView runJavaScriptTextInputPanelWithPrompt:(NSString *)prompt defaultText:(nullable NSString *)defaultText initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(NSString * __nullable result))completionHandler &#123;&#125;/// 确认框- (void)webView:(WKWebView *)webView runJavaScriptConfirmPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(BOOL result))completionHandler &#123;&#125;/// 警告框- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;&#125; 5.另外搜集了一些 WKWebView 常用的属性：12345678910• WKBackForwardListItem: webview中后退列表里的某一个网页。• WKFrameInfo: 包含一个网页的布局信息。• WKNavigation: 包含一个网页的加载进度信息。• WKPreferences: 概括一个 webview 的偏好设置。• WKProcessPool: 表示一个 web 内容加载池。• WKScriptMessage: 包含网页发出的信息。• WKUserScript:表示可以被网页接受的用户脚本。• WKWebViewConfiguration: 初始化 webview 的设置。• WKWindowFeatures: 指定加载新网页时的窗口属性。• WKScriptMessageHandler: 提供从网页中收消息的回调方法。 小尾巴:正像开头说的那样， WKWebView 相比UIWebView来说性能好，速度快，内存小，功能多……但现在开发中普遍用的还是 UIWebView，这是因为大多数App需要支持iOS7及以上的版本。但苹果之所以推出 WKWebView 就是为了弥补 UIWebView 的种种不足，逐渐取代 UIWebView，相信不久的将来，网页会成为 WKWebView 的天下！ 今天就简单的写到这里，以后如果用到其它的了，再和大家分享😄!]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之源码解析 - Masonry]]></title>
    <url>%2F2016%2F12%2F16%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20Masonry%2F</url>
    <content type="text"><![CDATA[这是 GitHub 上，Masonry 官方对 Masonry 的介绍： Masonry is a light-weight layout framework which wraps AutoLayout with a nicer syntax. Masonry has its own layout DSL which provides a chainable way of describing your NSLayoutConstraints which results in layout code that is more concise and readable. Masonry supports iOS and Mac OS X. 译文如下： Masonry 是一个轻量级的布局框架，它通过一种友好的语法封装了自动布局。Masonry 通过链式语法 DSL(Domain-specific language) 来封装 NSLayoutConstraints，使布局代码更加地简洁易读。Masonry 支持 iOS 和 Mac OS X。 在分析 Masonry 源码之前，有必要先说一下 Masonry 的基本使用，而在说 Masonry 的基本使用之前，我们还是先来看看 storyboard 以及 xib 中是如何进行 AutoLayout 的，我截了两张图： 从上图我们可以看出，在 storyboard 和 xib 中，我们可以在可视化界面对控件进行 AutoLayout，操作较为简单方便。Masonry 的实现原理与这很相似，接下来我们就一起看看如何使用 Masonry 进行自动布局。 先看一下 Masonry 支持哪些属性： 12345678910111213141516171819202122232425262728293031323334/*** 以下属性返回一个新的 MASViewConstraint*/@property (nonatomic, strong, readonly) MASConstraint *left; // 左侧@property (nonatomic, strong, readonly) MASConstraint *top; // 上侧@property (nonatomic, strong, readonly) MASConstraint *right; // 右侧@property (nonatomic, strong, readonly) MASConstraint *bottom; // 下侧@property (nonatomic, strong, readonly) MASConstraint *leading; // 首部@property (nonatomic, strong, readonly) MASConstraint *trailing; // 尾部@property (nonatomic, strong, readonly) MASConstraint *width; // 宽@property (nonatomic, strong, readonly) MASConstraint *height; // 高@property (nonatomic, strong, readonly) MASConstraint *centerX; // 横向居中@property (nonatomic, strong, readonly) MASConstraint *centerY; // 纵向居中@property (nonatomic, strong, readonly) MASConstraint *baseline; // 文本基线/*** 返回一个 block 对象，block 的接收参数是 MASAttribute 类型,返回一个 MASCompositeConstraint 对象*/@property (nonatomic, strong, readonly) MASConstraint *(^attributes)(MASAttribute attrs);/*** 返回一个 MASConstraint 对象，包含上下左右的布局信息*/@property (nonatomic, strong, readonly) MASConstraint *edges;/*** 返回一个 MASConstraint 对象，包含宽高的布局信息*/@property (nonatomic, strong, readonly) MASConstraint *size;/*** 返回一个 MASConstraint 对象，包含 centerX 和 centerY 信息*/@property (nonatomic, strong, readonly) MASConstraint *center; 有了属性之后，怎样添加约束呢？使用 Masonry 添加约束的函数有三个，这三个方法我们在文件 View+MASAdditions 中可以查看到： 12345678/// 新增约束- (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;/// 更新约束- (NSArray *)mas_updateConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block;/// 清除旧约束，只保留新约束- (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; 上面这三个方法中最常用的是 - (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block。即第一个，接下来我们就尝试一下。 举个栗子： 导入 Masonry 框架之后，添加以下代码：12345678910111213- (void)layoutViews&#123;UIImageView *imageView = [[UIImageView alloc] init];[imageView setImage:[UIImage imageNamed:@&quot;123&quot;]];[self.view addSubview:imageView];[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(self.view).offset(100);make.right.equalTo(self.view).offset(-100);make.top.equalTo(self.view).offset(250);make.bottom.equalTo(self.view).offset(-250);&#125;];&#125; 上面这几句代码便可以对 UIImageView 控件进行约束，这里还有两点值得一提。第一点：下面这三种方式会实现相同的效果1234567891011121314151617/// 第一种[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(self.view).offset(100);make.right.equalTo(self.view).offset(-100);make.top.equalTo(self.view).offset(250);make.bottom.equalTo(self.view).offset(-250);&#125;];/// 第二种[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.top.bottom.left.right.equalTo(self.view).insets(UIEdgeInsetsMake(250, 100, 250, 100));&#125;];/// 第三种[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.edges.equalTo(self.view).insets(UIEdgeInsetsMake(250, 100, 250, 100));&#125;]; 三种方式得出的效果图一样： 第二点：必须先把控件添加到视图上，才能对控件进行布局，否则程序会崩。即先 addSubview:，再 mas_makeConstraints: 。 以上是对 Masonry 使用的简单介绍。接下来我们开始分析它的源码。 通过对 Masonry 使用方法的了解，我们可以看出 Masonry 的使用过程还是很简洁的 123456[imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123;make.left.equalTo(self.view).offset(100);make.right.equalTo(self.view).offset(-100);make.top.equalTo(self.view).offset(250);make.bottom.equalTo(self.view).offset(-250);&#125;]; 那我们就从 mas_makeConstraints: 这个方法开始探寻 Masonry 的源码。上文说到，Masonry 中设置约束最常用的方法是 12 /// 新增约束 - (NSArray *)mas_makeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; 同时，Masonry 还提供两个类方法用于更新和重建约束 12345 /// 更新约束 - (NSArray *)mas_updateConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; /// 清除旧约束，只保留新约束 - (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block; 这里我们就以 mas_makeConstraints: 为切入点开始分析 Masonry 这个框架。mas_makeConstraints: 这个方法位于分类View+MASAdditions中，方法的实现如下： 1234567891011 /// 新增约束 - (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block &#123; /// 我们是手动添加约束，因此将自动转换关闭 self.translatesAutoresizingMaskIntoConstraints = NO; /// 创建 MASConstraintMaker 对象 MASConstraintMaker *constraintMaker = [[MASConstraintMaker alloc] initWithView:self]; /// 通过 block 进行值的回调 block(constraintMaker); /// 调用 install 方法 return [constraintMaker install]; &#125; 该方法先去掉 AutoResizing 的自动转换（如果这个属性没有被正确设置，那么视图的约束不会被成功添加），接着初始化一个 MASConstraintMaker 对象，传递到 block 中，执行 block，最后调用 install 方法。 第一次点击进来看到这个方法之后，我有几处疑问。 第一，MASConstraintMaker 类内部做了什么操作？ 第二，回调 block(constraintMaker)有什么用？ 第三，调用 [constraintMaker install] 方法实现了什么？ 我们先来分析一下 MASConstraintMaker 这个类。MASConstraintMaker 是 Masonry 框架整个 DSL 过程的控制中心，它控制着整个添加过程，上文我们总结 Masonry 支持哪些属性时，总结的那些属性就来自 MASConstraintMaker 类。我们知道 Masonry 是基于 AutoLayout 进行的封装，所以接着我们一起来看下 MASConstraintMaker 是如何发挥作用的。下面是 MASConstraintMaker 的初始化 12345678910 /// 这里的 MAS_VIEW 是一个宏，#define MAS_VIEW UIView - (id)initWithView:(MAS_VIEW *)view &#123; self = [super init]; if (!self) return nil; self.view = view; self.constraints = NSMutableArray.new; return self; &#125; 从上边代码中我们可以清晰的看出，Masonry 在初始化 MASConstraintMaker 时，将当前的 view 赋给 MASConstraintMaker 类，并初始化一个 constraints 的空可变数组，作为约束数组。 除此之外 MASConstraintMaker 还做了什么呢？ 先来到 MASConstraintMaker 的头文件 MASConstraintMaker.h 中，下面是一些比较常规的属性 1234567891011121314 /** * 以下属性返回一个新的 MASViewConstraint */ @property (nonatomic, strong, readonly) MASConstraint *left; // 左侧 @property (nonatomic, strong, readonly) MASConstraint *top; // 上侧 @property (nonatomic, strong, readonly) MASConstraint *right; // 右侧 @property (nonatomic, strong, readonly) MASConstraint *bottom; // 下侧 @property (nonatomic, strong, readonly) MASConstraint *leading; // 首部 @property (nonatomic, strong, readonly) MASConstraint *trailing; // 尾部 @property (nonatomic, strong, readonly) MASConstraint *width; // 宽 @property (nonatomic, strong, readonly) MASConstraint *height; // 高 @property (nonatomic, strong, readonly) MASConstraint *centerX; // 横向居中 @property (nonatomic, strong, readonly) MASConstraint *centerY; // 纵向居中 @property (nonatomic, strong, readonly) MASConstraint *baseline; // 文本基线 另外可以在 MASConstraintMaker 的 MASConstraintMaker.m 中看到另一个属性 @property (nonatomic, strong) NSMutableArray *constraints ，用来存储 MASConstraint 1234567 @interface MASConstraintMaker () &lt;MASConstraintDelegate&gt; @property (nonatomic, weak) MAS_VIEW *view; /// 存储 MASConstraint @property (nonatomic, strong) NSMutableArray *constraints; @end 接下来我们通过下面这个例子来分析上面这些属性： 123 [imageView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.bottom.left.right.equalTo(self.view).insets(UIEdgeInsetsMake(250, 100, 250, 100)); &#125;]; block 中首先会执行 make.top ，会先调用一个增加约束的通用方法- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute ，接着会调用 MASConstraintMaker 中 MASConstraintDelegate 的 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute 方法。具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041 /// 重写 getter 方法 - (MASConstraint *)top &#123; return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop]; &#125; /// 增加约束的通用方法 - (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute]; &#125; /// 通过 NSLayoutAttribute 添加约束 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; /// 构造 MASViewAttribute MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; /// 通过 MASViewAttribute 构造第一个 MASViewConstraint MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; /// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; /// 替换原来的 constraint 成新的 MASCompositeConstraint [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; /// 不存在则设置 constraint 到 self.constraints if (!constraint) &#123; /// 设置delegate newConstraint.delegate = self; /// 将约束添加到self.constraints [self.constraints addObject:newConstraint]; &#125; /// 返回刚刚创建的 MASViewConstraint 对象 return newConstraint; &#125; 值得一提的是，当调用 make.top 的时候会创建一个只有 firstViewAttribute 的 MASViewConstraint 对象，并且进入不存在 constraint 的代码部分，详情见代码块中的注释。 123456789 /// 不存在则设置 constraint 到 self.constraints if (!constraint) &#123; /// 设置delegate newConstraint.delegate = self; /// 将约束添加到self.constraints [self.constraints addObject:newConstraint]; &#125; /// 返回刚刚创建的 MASViewConstraint 对象 return newConstraint; 在这个方法的实现过程中，make.top 的返回值是 MASViewConstraint 对象。 当执行到 make.top.bottom 的时候，其实是对 MASViewConstraint 对象 .bottom 的调用，会走到 MASViewConstraint 中重写的 - (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute方法，然后最终还是会调用这个代理方法 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute 12345678910111213141516171819202122232425262728293031323334353637 - (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; NSAssert(!self.hasLayoutRelation, @&quot;Attributes should be chained before defining the constraint relation&quot;); return [self.delegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute]; &#125; /// 通过 NSLayoutAttribute 添加约束 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; /// 构造 MASViewAttribute MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; /// 通过 MASViewAttribute 构造第一个 MASViewConstraint MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; /// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; /// 替换原来的 constraint 成新的 MASCompositeConstraint [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; /// 不存在则设置 constraint 到 self.constraints if (!constraint) &#123; /// 设置delegate newConstraint.delegate = self; /// 将约束添加到self.constraints [self.constraints addObject:newConstraint]; &#125; /// 返回刚刚创建的 MASViewConstraint 对象 return newConstraint; &#125; 和前面的执行过程不同，因为 MASViewConstraint 的 delegate 对象是刚才设置过的 MASConstraintMaker 对象，并且因为 constraint 不是 nil，所以会进入 1234567891011 /// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; /// 替换原来的 constraint 成新的 MASCompositeConstraint [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; 因此调用 make.top.bottom 返回的是一个 MASCompositeConstraint 对象。 当程序执行到 make.top.bottom.left 时，就是对 MASCompositeConstraint 中 .left 的调用，会走 MASCompositeConstraint 中的重写方法 - (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute，接着会调用 - (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute方法，最终还是会调用 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041 - (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; [self constraint:self addConstraintWithLayoutAttribute:layoutAttribute]; return self; &#125; - (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; id&lt;MASConstraintDelegate&gt; strongDelegate = self.delegate; MASConstraint *newConstraint = [strongDelegate constraint:self addConstraintWithLayoutAttribute:layoutAttribute]; newConstraint.delegate = self; [self.childConstraints addObject:newConstraint]; return newConstraint; &#125; /// 通过 NSLayoutAttribute 添加约束 - (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; /// 构造 MASViewAttribute MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; /// 通过 MASViewAttribute 构造第一个 MASViewConstraint MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute]; /// 如果存在 contraint，则把 constraint 和 newConstraint 组合成 MASCompositeConstraint if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; /// 替换原来的 constraint 成新的 MASCompositeConstraint [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; /// 不存在则设置 constraint 到 self.constraints if (!constraint) &#123; newConstraint.delegate = self; [self.constraints addObject:newConstraint]; &#125; return newConstraint; &#125; 但这次 if ([constraint isKindOfClass:MASViewConstraint.class]) 与 if (!constraint) 都不会进入，只直接返回 MASViewConstraint 对象，然后回到 - (MASConstraint *)constraint:(MASConstraint __unused *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute 方法中设置它的 delegate，并且将对象存入 MASCompositeConstraint 的 childConstraints 中。 之后再有更多的链式 MASConstraint 的组合（比如执行到 make.top.bottom.left.right），也只是 MASCompositeConstraint 的调用，直接加入 childConstraints 中即可。 至于 equalTo(self.view) 的调用过程，这里有必要说明一下，equalTo(self.view) 在文件 MASConstraint 中执行 - (MASConstraint * (^)(id))equalTo 方法，接着调用 MASViewConstraint 中的 - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation 方法。代码如下： 1234567891011121314151617181920212223242526272829303132333435 /// MASConstraint 是一个抽象类，其中有很多的方法都必须在子类中覆写。Masonry 中有两个 MASConstraint 的子类，分别是 MASViewConstraint 和 MASCompositeConstraint /// MASConstraint.m - (MASConstraint * (^)(id))equalTo &#123; return ^id(id attribute) &#123; return self.equalToWithRelation(attribute, NSLayoutRelationEqual); &#125;; &#125; /// MASViewConstraint.m - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation &#123; return ^id(id attribute, NSLayoutRelation relation) &#123; if ([attribute isKindOfClass:NSArray.class]) &#123; NSAssert(!self.hasLayoutRelation, @&quot;Redefinition of constraint relation&quot;); NSMutableArray *children = NSMutableArray.new; for (id attr in attribute) &#123; MASViewConstraint *viewConstraint = [self copy]; viewConstraint.layoutRelation = relation; viewConstraint.secondViewAttribute = attr; [children addObject:viewConstraint]; &#125; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self.delegate; [self.delegate constraint:self shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125; else &#123; NSAssert(!self.hasLayoutRelation || self.layoutRelation == relation &amp;&amp; [attribute isKindOfClass:NSValue.class], @&quot;Redefinition of constraint relation&quot;); self.layoutRelation = relation; self.secondViewAttribute = attribute; return self; &#125; &#125;; &#125; - (MASConstraint * (^)(id))equalTo 方法提供了参数 attribute 和布局关系 NSLayoutRelationEqual，这两个参数会传递到 - (MASConstraint * (^)(id, NSLayoutRelation))equalToWithRelation 中，设置 constraint 的布局关系和 secondViewAttribute 属性，为 [constraintMaker install] 做准备。 到这里基本上就把上文的那个例子说完了，通过例子让我们对 MASConstraintMaker 中的一些常规属性有了一定的了解，同时也明白了 block(constraintMaker) 这个方法的作用——在调用 block(constraintMaker) 时，对 constraintMaker 进行配置。 MASConstraintMaker 中还有一些别的属性，我们再一起来看看吧 12345678910111213141516171819 /** * 返回一个 block 对象，block 的接收参数是 MASAttribute 类型，返回一个 MASCompositeConstraint 对象 */ @property (nonatomic, strong, readonly) MASConstraint *(^attributes)(MASAttribute attrs); /** * 返回一个 MASConstraint 对象，包含上下左右的布局 */ @property (nonatomic, strong, readonly) MASConstraint *edges; /** * 返回一个 MASConstraint 对象，包含宽高的布局 */ @property (nonatomic, strong, readonly) MASConstraint *size; /** * 返回一个 MASConstraint 对象，包含 centerX 和 centerY */ @property (nonatomic, strong, readonly) MASConstraint *center; 这里只简单的介绍一下上面的几个属性 attributes：返回一个 block 对象，block 的接收参数是 MASAttribute 类型，返回 MASCompositeConstraint 对象 edges：返回一个 MASConstraint 对象，同时包含了上下左右的布局 size：返回一个 MASConstraint 对象，同时包含了宽高的布局 center：返回一个 MASConstraint 对象，同时包含了 centerX 和centerY 接下来我们来分析 [constraintMaker install] 方法。 我们在- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *))block 方法的最后会调用 [constraintMaker install] 方法来添加所有存储在 self.constraints 数组中的所有约束。 12345678910111213141516171819 - (NSArray *)install &#123; /// 是否需要删除原来的约束 if (self.removeExisting) &#123; /// 获得所有约束 NSArray *installedConstraints = [MASViewConstraint installedConstraintsForView:self.view]; /// 删除所有约束 for (MASConstraint *constraint in installedConstraints) &#123; [constraint uninstall]; &#125; &#125; NSArray *constraints = self.constraints.copy; for (MASConstraint *constraint in constraints) &#123; constraint.updateExisting = self.updateExisting; [constraint install]; &#125; /// 去除所有缓存的约束结构体 [self.constraints removeAllObjects]; return constraints; &#125; 这个方法会先判断当前视图的约束是否需要删除，如果我们之前调用过 - (NSArray *)mas_remakeConstraints:(void(NS_NOESCAPE ^)(MASConstraintMaker *make))block 这个方法（它会把 removeExisting 的 BOOL 值设为 YES），那么视图中的原有约束就会被全被删除。接着往下走，程序会遍历 constraints 数组，发送 install 消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576 /// MASViewConstraint.m - (void)install &#123; /// 已经有约束 if (self.hasBeenInstalled) &#123; return; &#125; /// 支持 active 且已经有约束 if ([self supportsActiveProperty] &amp;&amp; self.layoutConstraint) &#123; /// 激活约束 self.layoutConstraint.active = YES; /// 添加约束缓存 [self.firstViewAttribute.view.mas_installedConstraints addObject:self]; return; &#125; /// 获得 firstLayoutItem, firstLayoutAttribute, secondLayoutItem, secondLayoutAttribute MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item; NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute; MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item; NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute; // alignment attributes must have a secondViewAttribute // therefore we assume that is refering to superview // eg make.left.equalTo(@10) if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123; secondLayoutItem = self.firstViewAttribute.view.superview; secondLayoutAttribute = firstLayoutAttribute; &#125; /// NSLayoutConstraint 的创建，生成约束，MASLayoutConstraint 其实就是 NSLayoutConstraint 的别名 MASLayoutConstraint *layoutConstraint = [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; /// 设置 priority 和 mas_key layoutConstraint.priority = self.layoutPriority; layoutConstraint.mas_key = self.mas_key; /// 如果 secondViewAttribute 有 view 对象 if (self.secondViewAttribute.view) &#123; /// 取得两个 view 的最小公共 view MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view]; NSAssert(closestCommonSuperview, @&quot;couldn&apos;t find a common superview for %@ and %@&quot;, self.firstViewAttribute.view, self.secondViewAttribute.view); /// 设置约束 view 为此 view self.installedView = closestCommonSuperview; &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123; self.installedView = self.firstViewAttribute.view; &#125; else &#123; self.installedView = self.firstViewAttribute.view.superview; &#125; /// 已经存在的约束 MASLayoutConstraint *existingConstraint = nil; if (self.updateExisting) &#123; // 需要更新 existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint]; &#125; if (existingConstraint) &#123; // 如果存在则替换约束 // just update the constant existingConstraint.constant = layoutConstraint.constant; self.layoutConstraint = existingConstraint; &#125; else &#123; /// 其它情况则直接添加约束 [self.installedView addConstraint:layoutConstraint]; self.layoutConstraint = layoutConstraint; [firstLayoutItem.mas_installedConstraints addObject:self]; &#125; &#125; 上面这个方法是为当前视图添加约束的最后的方法，首先这个方法会先获取即将用于初始化 NSLayoutConstraint 的子类的几个属性 1234567 /// MASViewConstraint.m /// 获得 firstLayoutItem, firstLayoutAttribute, secondLayoutItem, secondLayoutAttribute MAS_VIEW *firstLayoutItem = self.firstViewAttribute.item; NSLayoutAttribute firstLayoutAttribute = self.firstViewAttribute.layoutAttribute; MAS_VIEW *secondLayoutItem = self.secondViewAttribute.item; NSLayoutAttribute secondLayoutAttribute = self.secondViewAttribute.layoutAttribute; 然后判断当前即将添加的约束，如果不是 size 类型并且没有提供 self.secondViewAttribute，会自动将约束添加到 superview 上 12345 /// MASViewConstraint.m if (!self.firstViewAttribute.isSizeAttribute &amp;&amp; !self.secondViewAttribute) &#123; secondLayoutItem = self.firstViewAttribute.view.superview; secondLayoutAttribute = firstLayoutAttribute; &#125; 接着创建 MASLayoutConstraint 对象 1234567891011121314 /// MASViewConstraint.m /// NSLayoutConstraint 的创建，生成约束，MASLayoutConstraint 其实就是 NSLayoutConstraint 的别名 MASLayoutConstraint *layoutConstraint = [MASLayoutConstraint constraintWithItem:firstLayoutItem attribute:firstLayoutAttribute relatedBy:self.layoutRelation toItem:secondLayoutItem attribute:secondLayoutAttribute multiplier:self.layoutMultiplier constant:self.layoutConstant]; /// 设置 priority 和 mas_key layoutConstraint.priority = self.layoutPriority; layoutConstraint.mas_key = self.mas_key; 创建完约束对象后，我们要寻找该约束添加到那个 View 上。下方的代码段就是获取接收该约束对象的视图。如果是两个视图相对约束，就获取两种的公共父视图。如果添加的是 Width 或者 Height，那么就添加到当前视图上。如果既没有指定相对视图，也不是 Size 类型的约束，那么就将该约束对象添加到当前视图的父视图上。代码实现如下： 12345678910111213141516 /// MASViewConstraint.m /// 如果 secondViewAttribute 有 view 对象 if (self.secondViewAttribute.view) &#123; /// 取得两个 view 的最小公共 view MAS_VIEW *closestCommonSuperview = [self.firstViewAttribute.view mas_closestCommonSuperview:self.secondViewAttribute.view]; NSAssert(closestCommonSuperview, @&quot;couldn&apos;t find a common superview for %@ and %@&quot;, self.firstViewAttribute.view, self.secondViewAttribute.view); /// 设置约束 view 为此 view self.installedView = closestCommonSuperview; &#125; else if (self.firstViewAttribute.isSizeAttribute) &#123; self.installedView = self.firstViewAttribute.view; &#125; else &#123; self.installedView = self.firstViewAttribute.view.superview; &#125; 加约束时我们要判断是否需要对约束进行更新，如果需要，就替换约束，如果不需要就直接添加约束即可。添加成功后我们将通过 mas_installedConstraints 属性记录一下本次添加的约束。 123456789101112131415 /// 已经存在的约束 MASLayoutConstraint *existingConstraint = nil; if (self.updateExisting) &#123; // 需要更新 existingConstraint = [self layoutConstraintSimilarTo:layoutConstraint]; &#125; if (existingConstraint) &#123; // 如果存在则替换约束 // just update the constant existingConstraint.constant = layoutConstraint.constant; self.layoutConstraint = existingConstraint; &#125; else &#123; /// 其它情况则直接添加约束 [self.installedView addConstraint:layoutConstraint]; self.layoutConstraint = layoutConstraint; [firstLayoutItem.mas_installedConstraints addObject:self]; &#125; 到此为止，对 Masonry 源码的简单介绍已接近尾声了。。。Masonry 的代码流程简单来讲就是提供给我们一个 MASConstraintMaker，然后我们根据 Masonry 提供的语法，添加约束。最后 Masonry 解析约束，将真正的约束关系添加到相应的视图上。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之源码解析 - MBProgressHUD]]></title>
    <url>%2F2016%2F12%2F14%2FiOS%E5%BC%80%E5%8F%91%E4%B9%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%20-%20MBProgressHUD%2F</url>
    <content type="text"><![CDATA[MBProgressHUD 是一个为 APP 添加 HUD 窗口的第三方框架，使用起来极其简单方便，关于 MBProgressHUD 的使用方法，GitHub 上有详细的说明，这里就不多加介绍了，本文主要是从源码的角度分析 MBProgressHUD的具体实现。 先来对 MBProgressHUD 有个大体的认识，这是刚从 GitHub 上拉下来的代码，如下图，MBProgressHUD 的主要文件只有两个： 下面我们就开始分析 MBProgressHUD 的具体实现。在此之前先了解下文章的目录，本文主要有三个部分： MBProgressHUD 核心 API 这一部分讲的主要是 MBProgressHUD 的一些属性方法等，主要是为了对 MBProgressHUD 先有个大概的认识 show 系列方法 这一部分主要是展示 HUD 窗口时调用的方法及代码分析 hide 系列方法 这一部分主要是隐藏 HUD 窗口时调用的方法及代码分析 begin~~~ 一、MBProgressHUD 核心 API 这一部分讲的主要是 MBProgressHUD 的一些属性方法等，主要是为了对 MBProgressHUD 先有个大概的认识 1.1 模式首先来看看 MBProgressHUD 中定义的枚举，mode 一共有六种显示样式： 123456789101112131415/// 显示样式typedef NS_ENUM(NSInteger, MBProgressHUDMode) &#123;/// 默认模式, 系统自带的指示器MBProgressHUDModeIndeterminate,/// 圆形饼图MBProgressHUDModeDeterminate,/// 水平进度条MBProgressHUDModeDeterminateHorizontalBar,/// 圆环MBProgressHUDModeAnnularDeterminate,/// 自定义视图MBProgressHUDModeCustomView,/// 只显示文字MBProgressHUDModeText&#125;; 简单的效果图如下（颜色尺寸等都可以优化，我这里只是简单地示例）： 1.2 动画效果MBProgressHUD 在显示 HUD 窗口的时候，一般都伴随着动画效果，MBProgressHUD 中的动画效果也是一个枚举，如下： 12345678910typedef NS_ENUM(NSInteger, MBProgressHUDAnimation) &#123;/// 默认效果，只有透明度变化MBProgressHUDAnimationFade,/// 透明度变化 + 形变 (放大时出现缩小消失)MBProgressHUDAnimationZoom,/// 透明度变化 + 形变 (缩小)MBProgressHUDAnimationZoomOut,/// 透明度变化 + 形变 (放大)MBProgressHUDAnimationZoomIn&#125;; 这里先简单的罗列出来，下文中还会多次用到。 1.3 MBProgressHUD 组成MBProgressHUD 主要由四部分组成：loading 动画视图、标题文本框、详情文本框、HUD 背景框，如下图。 之前用 MBProgressHUD 设置标题文本详情文本是通过几个属性来实现的，功能少也较为繁琐，因此被遗弃了；现在设置标题文本详情文本等十分简便，直接通过 label 等控件就可以实现，而且在功能上也有很大的扩展，详情请看下面这个代码块： 123456789101112/// bezelView 是指包括文本和指示器的视图，和自定义的 customView 类似@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;/// backgroundView 背景视图@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;/// customView 自定义视图@property (strong, nonatomic, nullable) UIView *customView;/// label 指的是标题文本@property (strong, nonatomic, readonly) UILabel *label;/// detailsLabel指的是详情文本@property (strong, nonatomic, readonly) UILabel *detailsLabel;/// hud 窗口还可以加入button，添加事件@property (strong, nonatomic, readonly) UIButton *button; 另外这里再附加两张 MBProgressHUD 的整体布局图，以便更好地认识 MBProgressHUD。 简单介绍： backgroundView：整个背景图层，可以通过 MBBackgroundView 的 style 属性设置 bezelView：提供元素 （indicator、label、detailLabel、button）的背景 indicator：指示器显示进度情况 这个视图由我们设定的mode属性决定 label：显示标题文本 detailLabel：显示详情文本 button：添加点击事件 1.4 MBProgressHUD 中的属性MBProgressHUD 文件中主要包括四个类，它们分别是 MBProgressHUD、MBRoundProgressView、 MBBarProgressView、 MBBackgroundView。这四个类各有各的用法，比如如果是进度条模式(MBProgressHUDModeDeterminateHorizontalBar)，则使用的是 MBBarProgressView 类；如果是饼图模式(MBProgressHUDModeDeterminate)或环形模式(MBProgressHUDModeAnnularDeterminate)，则使用的是 MBRoundProgressView类。下面是这四个类的相关属性。 1.41 MBProgressHUD 相关属性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// show 方法触发到显示 HUD 窗口的间隔时间，默认是 0@property (assign, nonatomic) NSTimeInterval graceTime;/// HUD 窗口显示的最短时间，默认是 0@property (assign, nonatomic) NSTimeInterval minShowTime;/// HUD 窗口显示模式, 默认是系统自带的指示器@property (assign, nonatomic) MBProgressHUDMode mode;/// 进度条指示器以及文本的颜色@property (strong, nonatomic, nullable) UIColor *contentColor UI_APPEARANCE_SELECTOR;/// HUD 窗口显示和隐藏的动画类型MBProgressHUD@property (assign, nonatomic) MBProgressHUDAnimation animationType UI_APPEARANCE_SELECTOR;/// HUD 窗口位置设置，比如 hud.offset = CGPointMake(0.f, MBProgressMaxOffset)，可以移到底部中心位置@property (assign, nonatomic) CGPoint offset UI_APPEARANCE_SELECTOR;/// HUD 元素到 HUD 边缘的距离，默认是 20.f@property (assign, nonatomic) CGFloat margin UI_APPEARANCE_SELECTOR;/// HUD 窗口背景框的最小尺寸@property (assign, nonatomic) CGSize minSize UI_APPEARANCE_SELECTOR;/// 是否强制 HUD 背景框宽高相等@property (assign, nonatomic, getter = isSquare) BOOL square UI_APPEARANCE_SELECTOR;/// 进度条 (0.0 到 1.0)@property (nonatomic, assign) float progress;/// bezelView 是指包括文本和指示器的视图，和自定义的 customView 类似@property (strong, nonatomic, readonly) MBBackgroundView *bezelView;/// backgroundView 背景视图@property (strong, nonatomic, readonly) MBBackgroundView *backgroundView;/// customView 自定义视图@property (strong, nonatomic, nullable) UIView *customView;/// label 指的是标题文本@property (strong, nonatomic, readonly) UILabel *label;/// detailsLabel指的是详情文本@property (strong, nonatomic, readonly) UILabel *detailsLabel;/// hud 窗口还可以加入button，添加事件@property (strong, nonatomic, readonly) UIButton *button; 1.42 MBRoundProgressView 相关属性1234567891011121314/// 进度条 (0.0 到 1.0)@property (nonatomic, assign) float progress;/// 进度条颜色@property (nonatomic, strong) UIColor *progressColor;/// 进度条指示器的颜色@property (nonatomic, strong) UIColor *progressTintColor;/// 进度条指示器的背景颜色，只适用在 iOS7 以上，默认为半透明的白色 (透明度 0.1)@property (nonatomic, strong) UIColor *backgroundTintColor;/// 显示模式，NO = 圆形；YES = 环形。默认是 NO@property (nonatomic, assign, getter = isAnnular) BOOL annular; 1.43 MBBarProgressView 相关属性1234567891011/// 进度条 (0.0 到 1.0)@property (nonatomic, assign) float progress;/// 进度条边界线的颜色，默认是白色@property (nonatomic, strong) UIColor *lineColor;/// 进度条背景色，默认是透明@property (nonatomic, strong) UIColor *progressRemainingColor;/// 进度条颜色@property (nonatomic, strong) UIColor *progressColor; 1.44 MBBackgroundView 相关属性12345/// 背景图层样式，有两种，iOS7 或者以上版本默认风格是MBProgressHUDBackgroundStyleBlur，其他为MBProgressHUDBackgroundStyleSolidColor，由于 iOS7 不支持 UIVisualEffectView，所以在 iOS7 和更高版本中会有所不同@property (nonatomic) MBProgressHUDBackgroundStyle style;/// 背景颜色，由于 iOS7 不支持 UIVisualEffectView，所以在 iOS7 和更高版本中会有所不同@property (nonatomic, strong) UIColor *color; 1.5 MBProgressHUD 中的一些方法1.51 类方法12345678/// 创建一个 HUD 窗口，并把它显示在 view 上，还可以设置是否有动画+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;/// 找到最上层的 HUD subview 并把它隐藏，成功为YES、其他情况为 NO+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;/// 返回最上层的 HUD subview+ (nullable MBProgressHUD *)HUDForView:(UIView *)view; 这三个类方法中，常用的是第一个函数+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated;直接创建 HUD，并把它显示在 view 上，用起来极其方便 1.52 对象方法1234567891011/// 以view为基准创建初始化一个HUD对象，为HUD的初始化构造函数- (instancetype)initWithView:(UIView *)view;/// 显示HUD控件，此函数应该在主线程中调用- (void)showAnimated:(BOOL)animated;/// 隐藏HUD控件，animated控制是否显示动画。对应于- (void)showAnimated:(BOOL)animated;- (void)hideAnimated:(BOOL)animated;/// 在delay时间之后隐藏HUD，animated控制显示动画与否，delay控制延迟时间- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay; 这几个对象方法中，常用的也有两个- (void)hideAnimated:(BOOL)animated;和- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay; 二、show 系列方法 这一部分主要是展示 HUD 窗口时调用的方法及代码分析 下面这个方法在我们创建 MBProgressHUD 对象时首先调用 12345678910111213+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated &#123;/// 创建并初始化 MBProgressHUD 对象，根据传进来的 view 来设定MBProgressHUD *hud = [[self alloc] initWithView:view];/// 移除 HUD 窗口hud.removeFromSuperViewOnHide = YES;/// 添加到 View 上，并显示[view addSubview:hud];[hud showAnimated:animated];return hud;&#125; 这个方法会调用两个主要方法：- (id)initWithView:(UIView *)view 和 - (void)showAnimated:(BOOL)animated，具体的调用流程如下图： 当然在 MBProgressHUD 中，+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated 调用的方法远不止上图列的这些，图上列的只是几个主要方法。接下来我们就根据程序的执行过程来一步一步分析一下代码。 在方法 - (id)initWithView:(UIView *)view中，调用 - (instancetype)initWithFrame:(CGRect)frame，接着会调用- (void)commonInit。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657- (id)initWithView:(UIView *)view &#123;NSAssert(view, @&quot;View must not be nil.&quot;);return [self initWithFrame:view.bounds];&#125;- (instancetype)initWithFrame:(CGRect)frame &#123;if ((self = [super initWithFrame:frame])) &#123;[self commonInit];&#125;return self;&#125;- (instancetype)initWithCoder:(NSCoder *)aDecoder &#123;if ((self = [super initWithCoder:aDecoder])) &#123;[self commonInit];&#125;return self;&#125;- (void)commonInit &#123;/// 默认效果, 透明度变化_animationType = MBProgressHUDAnimationFade;/// 默认模式, 系统自带的指示器_mode = MBProgressHUDModeIndeterminate;/// HUD 元素到 HUD 边缘的距离，默认是 20.f_margin = 20.0f;_opacity = 1.f;_defaultMotionEffectsEnabled = YES;// 默认颜色，根据当前的 iOS 版本BOOL isLegacy = kCFCoreFoundationVersionNumber &lt; kCFCoreFoundationVersionNumber_iOS_7_0;/// 进度条指示器以及文本的颜色_contentColor = isLegacy ? [UIColor whiteColor] : [UIColor colorWithWhite:0.f alpha:0.7f];/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NOself.opaque = NO;/// 背景色self.backgroundColor = [UIColor clearColor];// 透明度为 0self.alpha = 0.0f;/// 自动调整子控件与父控件之间的宽高self.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;self.layer.allowsGroupOpacity = NO;/// 设置所需的子view[self setupViews];/// 设置指示器样式[self updateIndicators];/// 注册通知[self registerForNotifications];&#125; 上面代码块中的代码已经加过注释，因此在这里不再累述某句代码有什么作用，这里直接说程序的执行流程。当程序执行到 - (void)commonInit 这个方法时，会相继执行- (void)setupViews，- (void)updateIndicators，- (void)registerForNotifications 这三个方法，当然在执行这三个方法期间，也会执行其它的方法，比如会执行- (void)updateForBackgroundStyle 和- (void)updateBezelMotionEffects等等，这和你设置的 mode 的模式，以及和 label，detailsLabel ，button 这一系列元素，以及和相应的属性都有一定的关系。 接着我们来分析一下 - (void)setupViews，- (void)updateIndicators，- (void)registerForNotifications 这三个方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182- (void)setupViews &#123;/// 进度条指示器以及文本的颜色UIColor *defaultColor = self.contentColor;/// 创建背景视图MBBackgroundView *backgroundView = [[MBBackgroundView alloc] initWithFrame:self.bounds];/// 背景图层样式backgroundView.style = MBProgressHUDBackgroundStyleSolidColor;backgroundView.backgroundColor = [UIColor clearColor];/// 自动调整 view 的宽度和高度backgroundView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;backgroundView.alpha = 0.f;[self addSubview:backgroundView];_backgroundView = backgroundView;/// 创建背景视图（和上面那个大小不同）MBBackgroundView *bezelView = [MBBackgroundView new];/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NObezelView.translatesAutoresizingMaskIntoConstraints = NO;bezelView.layer.cornerRadius = 5.f;bezelView.alpha = 0.f;[self addSubview:bezelView];_bezelView = bezelView;/// 调用 updateBezelMotionEffects 方法，设置视差效果[self updateBezelMotionEffects];/// 创建 label 标签，显示主要文本UILabel *label = [UILabel new];/// 取消文字大小自适应label.adjustsFontSizeToFitWidth = NO;label.textAlignment = NSTextAlignmentCenter;label.textColor = defaultColor;label.font = [UIFont boldSystemFontOfSize:MBDefaultLabelFontSize];/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NOlabel.opaque = NO;label.backgroundColor = [UIColor clearColor];_label = label;/// 创建 detailsLabel 标签，显示详细信息UILabel *detailsLabel = [UILabel new];/// 取消文字大小自适应detailsLabel.adjustsFontSizeToFitWidth = NO;detailsLabel.textAlignment = NSTextAlignmentCenter;detailsLabel.textColor = defaultColor;detailsLabel.numberOfLines = 0;detailsLabel.font = [UIFont boldSystemFontOfSize:MBDefaultDetailsLabelFontSize];/// opaque 类似 Alpha，表示当前 UIView 的不透明度，设置是否之后对于 UIView 的显示并没有什么影响,官方文档的意思是 opaque 默认为 YES，如果 alpha 小于 1，那么应该设置 opaque 设置为 NO，当 alpha 为 1，opaque设置为 NOdetailsLabel.opaque = NO;detailsLabel.backgroundColor = [UIColor clearColor];_detailsLabel = detailsLabel;/// 创建 button 按钮，并添加响应按钮UIButton *button = [MBProgressHUDRoundedButton buttonWithType:UIButtonTypeCustom];button.titleLabel.textAlignment = NSTextAlignmentCenter;button.titleLabel.font = [UIFont boldSystemFontOfSize:MBDefaultDetailsLabelFontSize];[button setTitleColor:defaultColor forState:UIControlStateNormal];_button = button;/// 将 label，detailLabel，button 添加到蒙版视图for (UIView *view in @[label, detailsLabel, button]) &#123;/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NOview.translatesAutoresizingMaskIntoConstraints = NO;/// 为视图设置水平方向上优先级为 998 的压缩阻力[view setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal];/// 为视图设置垂直方向上优先级为 998 的压缩阻力[view setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical];[bezelView addSubview:view];&#125;/// 创建顶部视图UIView *topSpacer = [UIView new];/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NOtopSpacer.translatesAutoresizingMaskIntoConstraints = NO;topSpacer.hidden = YES;[bezelView addSubview:topSpacer];_topSpacer = topSpacer;/// 创建底部视图UIView *bottomSpacer = [UIView new];/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NObottomSpacer.translatesAutoresizingMaskIntoConstraints = NO;bottomSpacer.hidden = YES;[bezelView addSubview:bottomSpacer];_bottomSpacer = bottomSpacer;&#125;- (void)updateIndicators &#123;UIView *indicator = self.indicator;/// 判断当前指示器是否是 UIActivityIndicatorViewBOOL isActivityIndicator = [indicator isKindOfClass:[UIActivityIndicatorView class]];/// 判断当前指示器是否是 MBRoundProgressViewBOOL isRoundIndicator = [indicator isKindOfClass:[MBRoundProgressView class]];MBProgressHUDMode mode = self.mode;/// MBProgressHUDModeIndeterminate:系统自带的指示器if (mode == MBProgressHUDModeIndeterminate) &#123;if (!isActivityIndicator) &#123;// 如果当前指示器不属于 UIActivityIndicatorView 类型，则移除之前的indicator，重新创建[indicator removeFromSuperview];indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];[(UIActivityIndicatorView *)indicator startAnimating];[self.bezelView addSubview:indicator];&#125;&#125;else if (mode == MBProgressHUDModeDeterminateHorizontalBar) &#123;/// 如果当前指示器不属于 MBBarProgressView 类型，则移除之前的indicator，重新创建[indicator removeFromSuperview];indicator = [[MBBarProgressView alloc] init];[self.bezelView addSubview:indicator];&#125;else if (mode == MBProgressHUDModeDeterminate || mode == MBProgressHUDModeAnnularDeterminate) &#123;if (!isRoundIndicator) &#123;/// 如果当前指示器不属于 MBRoundProgressView 类型，则移除之前的indicator，重新创建[indicator removeFromSuperview];indicator = [[MBRoundProgressView alloc] init];[self.bezelView addSubview:indicator];&#125;if (mode == MBProgressHUDModeAnnularDeterminate) &#123; /// 圆环指示器[(MBRoundProgressView *)indicator setAnnular:YES];&#125;&#125;else if (mode == MBProgressHUDModeCustomView &amp;&amp; self.customView != indicator) &#123; /// 自定义视图指示器[indicator removeFromSuperview];indicator = self.customView;[self.bezelView addSubview:indicator];&#125;else if (mode == MBProgressHUDModeText) &#123; /// 文本形式，去除指示器视图[indicator removeFromSuperview];indicator = nil;&#125;/// 代码层面使用 Autolayout，需要对使用的 View 的translatesAutoresizingMaskIntoConstraints 属性设置为NOindicator.translatesAutoresizingMaskIntoConstraints = NO;self.indicator = indicator;if ([indicator respondsToSelector:@selector(setProgress:)]) &#123;/// 设置进度条的数值[(id)indicator setValue:@(self.progress) forKey:@&quot;progress&quot;];&#125;/// 为视图设置水平方向上优先级为 998 的压缩阻力[indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisHorizontal];/// 为视图设置垂直方向上优先级为 998 的压缩阻力[indicator setContentCompressionResistancePriority:998.f forAxis:UILayoutConstraintAxisVertical];/// 设置控件颜色[self updateViewsForColor:self.contentColor];/// 更新布局[self setNeedsUpdateConstraints];&#125;- (void)registerForNotifications &#123;#if !TARGET_OS_TVNSNotificationCenter *nc = [NSNotificationCenter defaultCenter];/// 通过通知 UIApplicationDidChangeStatusBarOrientationNotification 来处理屏幕转屏事件[nc addObserver:self selector:@selector(statusBarOrientationDidChange:)name:UIApplicationDidChangeStatusBarOrientationNotification object:nil];#endif&#125; 由上面代码我们可以看出，在方法- (void)setupViews中，创建了 backgroundView、bezelView、label、detailsLabel、button 这几个控件，并使用 for 循环把 label、detailsLabel、button 添加到bezelView 视图中，最后还创建了顶部视图和底部视图，不过默认是隐藏的。有一点值得说明，在创建 button 时并没有设置 button 的 size 等属性，那么这个按钮是不会显示的。在这里 MBProgressHUD 重写了一个 Unbutton 的子类 MBProgressHUDRoundedButton。这个子类里面有一个方法，- (CGSize)intrinsicContentSize，通过这个方法来设置 Unbutton 的 size。 12345678- (CGSize)intrinsicContentSize &#123;/// 只有当有事件才显示（这里也告诉我们，如果这个 button 没有任何事件的话，它的大小就是 CGSizeZero，即不会显示）if (self.allControlEvents == 0) return CGSizeZero;CGSize size = [super intrinsicContentSize];// Add some side paddingsize.width += 20.f;return size;&#125; - (void)updateIndicators这个方法主要是用来设置 indicator 指示器的，根据 mode 的属性显示不同的形式，具体可以参看代码注释。这个方法最后调用的是setNeedsUpdateConstraints函数，这个函数是系统自带的方法，它会自动调用- (void)updateConstraints 方法，- (void)updateConstraints 主要作用是更新各个控件的布局，我们稍后再对这个方法进行详细分析。 - (void)registerForNotifications这个方法中的代码量很少，它的作用是通过通知 UIApplicationDidChangeStatusBarOrientationNotification 来处理屏幕转屏事件 当- (void)registerForNotifications这一系列方法执行完毕之后，程序会重新返回到+ (instancetype)showHUDAddedTo:(UIView *)view animated:(BOOL)animated这个方法中，接着调用另一个主要函数- (void)showAnimated:(BOOL)animated。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (void)showAnimated:(BOOL)animated &#123;/// 显示放在主线程中MBMainThreadAssert();/// 取消定时器[self.minShowTimer invalidate];self.useAnimation = animated;self.finished = NO;/// 如果设置了宽限时间graceTime，则延迟显示（避免 HUD 一闪而过的差体验）if (self.graceTime &gt; 0.0) &#123;/// 创建定时器，把它加入 NSRunLoop 中NSTimer *timer = [NSTimer timerWithTimeInterval:self.graceTime target:self selector:@selector(handleGraceTimer:) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];self.graceTimer = timer;&#125;/// 没有设置 graceTime，则直接显示else &#123;[self showUsingAnimation:self.useAnimation];&#125;&#125;/// 设置宽限时间 graceTime时调用的方法- (void)handleGraceTimer:(NSTimer *)theTimer &#123;// Show the HUD only if the task is still runningif (!self.hasFinished) &#123;[self showUsingAnimation:self.useAnimation];&#125;&#125;- (void)showUsingAnimation:(BOOL)animated &#123;/// 移除所有动画[self.bezelView.layer removeAllAnimations];[self.backgroundView.layer removeAllAnimations];/// 取消 hideDelayTimer[self.hideDelayTimer invalidate];/// 开始时间self.showStarted = [NSDate date];self.alpha = 1.f;/// 以防我们隐藏 NSProgress 对象[self setNSProgressDisplayLinkEnabled:YES];if (animated) &#123;[self animateIn:YES withType:self.animationType completion:NULL];&#125; else &#123;/// 方法弃用告警#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;self.bezelView.alpha = self.opacity;#pragma clang diagnostic popself.backgroundView.alpha = 1.f;&#125;&#125; 由上面这段代码我们可以看出，在方法- (void)showAnimated:(BOOL)animated中，无论我们有没有设置graceTime这个属性，最后都会去执行一个方法 - (void)showUsingAnimation:(BOOL)animated，- (void)showUsingAnimation:(BOOL)animated 这个方法在上面已经做过注释，不再细说，不过有两小点值得我们注意，第一点是 - (void)showUsingAnimation:(BOOL)animated 在执行过程中调用了一个方法 - (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled，先来看下这个方法123456789101112- (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled &#123;/// 这里使用 CADisplayLink，是因为如果使用 KVO 机制会非常消耗主线程（因为 NSProgress 频率非常快）if (enabled &amp;&amp; self.progressObject) &#123;/// 创建 CADisplayLink 对象if (!self.progressObjectDisplayLink) &#123;self.progressObjectDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateProgressFromProgressObject)];&#125;&#125; else &#123;self.progressObjectDisplayLink = nil;&#125;&#125; 这个方法是关于 CADisplayLink 的，CADisplayLink 是一个能让我们以和屏幕刷新率相同的频率将内容画到屏幕上的定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop 中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。一旦 CADisplayLink 以特定的模式注册到 runloop 之后，每当屏幕需要刷新，runloop 就会向 CADisplayLink 指定的target 发送一次指定的 selector 消息， CADisplayLink 类对应的 selector 就会被调用一次。 - (void)showUsingAnimation:(BOOL)animated 这个方法中还有一点值得注意，就是只有具有动画效果的前提下，即 animated 为真时才会调用 - (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion 这个方法，下面我们再一起来看下这个方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/// animated 为真时调用，消失或出现时的伸缩效果，以及透明度- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion &#123;/// 自动确定正确的缩放动画类型，关于 MBProgressHUDAnimation 的几种类型，上文已全部列出，这里不再详细介绍if (type == MBProgressHUDAnimationZoom) &#123;type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;&#125;/// CGAffineTransformMakeScale 中的两个参数，分别代表x和y方向缩放倍数CGAffineTransform small = CGAffineTransformMakeScale(0.5f, 0.5f);CGAffineTransform large = CGAffineTransformMakeScale(1.5f, 1.5f);/// 设定初始状态UIView *bezelView = self.bezelView;if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;bezelView.transform = small; /// 缩放&#125; else if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;bezelView.transform = large; /// 扩大&#125;/// 创建动画任务dispatch_block_t animations = ^&#123;if (animatingIn) &#123;bezelView.transform = CGAffineTransformIdentity;&#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;bezelView.transform = large;&#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;bezelView.transform = small;&#125;/// 方法弃用告警#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;bezelView.alpha = animatingIn ? self.opacity : 0.f;#pragma clang diagnostic popself.backgroundView.alpha = animatingIn ? 1.f : 0.f;&#125;;/// 动画的两种形式，&gt;= iOS7 的是一种形式，iOS7以下是另一种#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TVif (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;/// 只支持 &gt;= iOS7[UIView animateWithDuration:0.3 delay:0. usingSpringWithDamping:1.f initialSpringVelocity:0.f options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];return;&#125;#endif[UIView animateWithDuration:0.3 delay:0. options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];&#125; - (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion 这个方法，无论是处于 show 状态还是处于 hide 状态，都会调用，下边我们再一起看下 hide 系列的一些方法。 三、hide 系列方法 这一部分主要是隐藏 HUD 窗口时调用的方法及代码分析 关于隐藏 HUD 窗口，MBProgressHUD 给我们提供的方法有以下几个：12345678/// 找到最上层的 HUD subview 并把它隐藏，成功为YES、其他情况为 NO+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated;//隐藏HUD控件，animated控制是否显示动画。对应于- (void)showAnimated:(BOOL)animated;- (void)hideAnimated:(BOOL)animated;//在delay时间之后隐藏HUD，animated控制显示动画与否，delay控制延迟时间- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay; 最常用的是后面两个： - (void)hideAnimated:(BOOL)animated 和 - (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay，这两个方法的本质是相同的，不同的只是形式，也就是说这两个方法的实现流程基本上是一致的，只不过 - (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay 多执行一两个方法而已。下面我们就来具体分析下 hide 系列的方法。 首先还是来说说+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated这个函数，如果调用这个方法来隐藏 HUD 窗口，那么会先调用两个方法： 12345678910111213141516171819202122+ (BOOL)hideHUDForView:(UIView *)view animated:(BOOL)animated &#123;/// 获取当前 view 的最上面的 HUDMBProgressHUD *hud = [self HUDForView:view];if (hud != nil) &#123;/// 移除 HUD 窗口hud.removeFromSuperViewOnHide = YES;[hud hideAnimated:animated];return YES;&#125;return NO;&#125;+ (MBProgressHUD *)HUDForView:(UIView *)view &#123;/// NSEnumerator 是一个枚举器，依附于集合类（NSArray,NSSet,NSDictionary等），reverseObjectEnumerator 倒序遍历NSEnumerator *subviewsEnum = [view.subviews reverseObjectEnumerator];for (UIView *subview in subviewsEnum) &#123;if ([subview isKindOfClass:self]) &#123;return (MBProgressHUD *)subview;&#125;&#125;return nil;&#125; 当执行完上面这两个方法之后，接下来执行的方法和调用- (void)hideAnimated:(BOOL)animated隐藏 HUD 窗口时执行的方法相同，所以下边会详细分析。 接下来说说调用- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay 隐藏 HUD 窗口时的情况，上文已经说过，调用这个方法会比调用- (void)hideAnimated:(BOOL)animated 多执行一两个方法： 12345678910- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay &#123;/// 创建定时器，并把它加入到 NSRunLoop 中NSTimer *timer = [NSTimer timerWithTimeInterval:delay target:self selector:@selector(handleHideTimer:) userInfo:@(animated) repeats:NO];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];self.hideDelayTimer = timer;&#125;- (void)handleHideTimer:(NSTimer *)timer &#123;[self hideAnimated:[timer.userInfo boolValue]];&#125; 由上面代码可以清晰的看出，- (void)hideAnimated:(BOOL)animated afterDelay:(NSTimeInterval)delay 这个方法中加了一个定时器，当执行完这个定时器的selector时，就会执行- (void)hideAnimated:(BOOL)animated方法。 由此可见无论使用哪种方法隐藏 HUD 窗口，最终都会来到这个方法，- (void)hideAnimated:(BOOL)animated，接下来我们就来分析下这个方法的具体调用流程，先看个图： 上图显示的是 hide 相关的方法调用，只罗列了几个主要方法。接下来我们就来分析下这几个主要方法。先来到- (void)hideAnimated:(BOOL)animated方法中： 1234567891011121314151617181920212223242526- (void)hideAnimated:(BOOL)animated &#123;MBMainThreadAssert();[self.graceTimer invalidate];self.useAnimation = animated;self.finished = YES;/// 如果设置了最小显示时间，则执行此步骤，否则直接隐藏if (self.minShowTime &gt; 0.0 &amp;&amp; self.showStarted) &#123;NSTimeInterval interv = [[NSDate date] timeIntervalSinceDate:self.showStarted];/// 如果 minShowTime 比较大，则暂时不触发 HUD 的隐藏，而是启动一个 NSTimerif (interv &lt; self.minShowTime) &#123;/// 创建定时器，并把它加入到 NSRunLoop 中NSTimer *timer = [NSTimer timerWithTimeInterval:(self.minShowTime - interv) target:self selector:@selector(handleMinShowTimer:) userInfo:nil repeats:NO];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];self.minShowTimer = timer;return;&#125;&#125;/// 直接隐藏 HUD[self hideUsingAnimation:self.useAnimation];&#125;- (void)handleMinShowTimer:(NSTimer *)theTimer &#123;[self hideUsingAnimation:self.useAnimation];&#125; 从上面代码块中可以看出，无论我们有没有设置最小显示时间 self.minShowTime，都会触发 - (void)hideUsingAnimation:(BOOL)animated 这个方法，因此程序最后都会来到 - (void)hideUsingAnimation:(BOOL)animated 这个方法中： 1234567891011121314- (void)hideUsingAnimation:(BOOL)animated &#123;if (animated &amp;&amp; self.showStarted) &#123;/// 将 showStarted 设为 nilself.showStarted = nil;[self animateIn:NO withType:self.animationType completion:^(BOOL finished) &#123;[self done];&#125;];&#125; else &#123;self.showStarted = nil;self.bezelView.alpha = 0.f;self.backgroundView.alpha = 1.f;[self done];&#125;&#125; 这个方法和 show 系列的 - (void)showUsingAnimation:(BOOL)animated 方法一样，只要设定 animated 的属性为 YES，最终都会走到 - (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion 这个方法中，同时会执行一个方法：- (void)done，接下来我们来看一下这两个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/// animated 为真时调用，消失或出现时的伸缩效果，以及透明度- (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion &#123;/// 自动确定正确的缩放动画类型，关于 MBProgressHUDAnimation 的几种类型，上文已全部列出，这里不再详细介绍if (type == MBProgressHUDAnimationZoom) &#123;type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;&#125;/// CGAffineTransformMakeScale 中的两个参数，分别代表x和y方向缩放倍数CGAffineTransform small = CGAffineTransformMakeScale(0.5f, 0.5f);CGAffineTransform large = CGAffineTransformMakeScale(1.5f, 1.5f);/// 设定初始状态UIView *bezelView = self.bezelView;if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;bezelView.transform = small; /// 缩放&#125; else if (animatingIn &amp;&amp; bezelView.alpha == 0.f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;bezelView.transform = large; /// 扩大&#125;/// 创建动画任务dispatch_block_t animations = ^&#123;if (animatingIn) &#123;bezelView.transform = CGAffineTransformIdentity;&#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;bezelView.transform = large;&#125; else if (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;bezelView.transform = small;&#125;/// 方法弃用告警#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wdeprecated-declarations&quot;bezelView.alpha = animatingIn ? self.opacity : 0.f;#pragma clang diagnostic popself.backgroundView.alpha = animatingIn ? 1.f : 0.f;&#125;;/// 动画的两种形式，&gt;= iOS7 的是一种形式，iOS7以下是另一种#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TVif (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;/// 只支持 &gt;= iOS7[UIView animateWithDuration:0.3 delay:0. usingSpringWithDamping:1.f initialSpringVelocity:0.f options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];return;&#125;#endif[UIView animateWithDuration:0.3 delay:0. options:UIViewAnimationOptionBeginFromCurrentState animations:animations completion:completion];&#125;- (void)done &#123;/// 取消 hideDelayTimer[self.hideDelayTimer invalidate];/// 隐藏 NSProgress 对象[self setNSProgressDisplayLinkEnabled:NO];if (self.hasFinished) &#123;self.alpha = 0.0f;if (self.removeFromSuperViewOnHide) &#123;/// 从父视图中移除[self removeFromSuperview];&#125;&#125;MBProgressHUDCompletionBlock completionBlock = self.completionBlock;if (completionBlock) &#123;completionBlock();&#125;id&lt;MBProgressHUDDelegate&gt; delegate = self.delegate;if ([delegate respondsToSelector:@selector(hudWasHidden:)]) &#123;[delegate performSelector:@selector(hudWasHidden:) withObject:self];&#125;&#125; 关于 - (void)animateIn:(BOOL)animatingIn withType:(MBProgressHUDAnimation)type completion:(void(^)(BOOL finished))completion 这个方法，只要 animated 的属性为 YES，都会调用；而在- (void)done 这个方法中，如果 removeFromSuperViewOnHide 属性为 YES，则将自己从父视图上移除；如果有 completionBlock 回调函数，则执行回调；如果实现了代理并实现了代理方法，则执行代理方法。而且我们还观察到在 hide 时，也会调用 - (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled 方法，只是在 hide 时 enabled 为 NO。 123456789101112- (void)setNSProgressDisplayLinkEnabled:(BOOL)enabled &#123;/// 这里使用 CADisplayLink，是因为如果使用 KVO 机制会非常消耗主线程（因为 NSProgress 频率非常快）if (enabled &amp;&amp; self.progressObject) &#123;/// 创建 CADisplayLink 对象if (!self.progressObjectDisplayLink) &#123;self.progressObjectDisplayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(updateProgressFromProgressObject)];&#125;&#125; else &#123;self.progressObjectDisplayLink = nil;&#125;&#125; over 以上便是对 MBProgressHUD 源码的一些总结和认识，如果有不足之处，还希望各位道友能多指点哈！]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 常用语法]]></title>
    <url>%2F2016%2F12%2F06%2FMarkdown%20%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[又有朋友入坑程序猿这一神圣而又伟大的职业，问写博客用 Markdown 语法怎么样，表示大力赞同 ，一直以来都觉得 Markdown 语法超级简单方便，这两天年后刚上班，闲来无事，于是整理下平常用到的 Markdown 语法，希望能帮到有需要的道友。 一、标题1234567// 标题前面加 # 号，一个 # 代表是一级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果预览： 一级标题二级标题三级标题四级标题五级标题六级标题二、区块引用12345678// `&gt;`后有 1 个空格&gt; 引用&gt; 一级引用&gt; &gt; 二级引用&gt; &gt; &gt; 三级引用&gt; &gt; &gt; &gt; 四级引用&gt; &gt; &gt; &gt; &gt; 五级引用 效果预览： 引用 一级引用 二级引用 三级引用 四级引用 五级引用 三、强调三个 * 或 _ 代表斜体加粗，两个 * 或 _ 代表加粗，一个 * 或 _ 代表斜体，~~ 代表删除。 1234567***斜体加粗文本*** 或者 ___斜体加粗文本___**加粗文本** 或者 __加粗文本__*斜体文本* 或者_斜体文本_~~删除文本~~ 效果预览： 斜体加粗文本 或者 斜体加粗文本 加粗文本 或者 加粗文本 斜体文本 或者斜体文本 删除文本 当然以上几种还可以交叉使用，比如123~~**删除加粗文本**~~~~***删除斜体加粗文本***~~ 效果预览： 删除加粗文本 删除斜体加粗文本 四、列表Markdown 支持有序列表和无序列表。无序列表使用 * 、-、和 + 作为列表标记：12345678910111213141516171819202122232425262728293031* 北京* 海淀区* 五道口* 上海* 黄浦区* 外滩* 广州* 广州* 广州- 北京- 海淀区- 五道口- 上海- 黄浦区- 外滩- 广州- 广州- 广州+ 北京+ 海淀区+ 五道口+ 上海+ 黄浦区+ 外滩+ 广州+ 广州+ 广州 效果预览： 北京 海淀区 五道口 上海 黄浦区 外滩 广州 广州 广州 有序列表则使用数字加英文句点 . 来表示：1231. 北京2. 上海3. 广州 效果预览： 北京 上海 广州 ###五、分隔线 可以用三个或三个以上的 * 、-、或 _ 来建立分隔线123******___--- 效果预览： 六、链接Markdown 支持三种形式的链接语法： 行内式和参考式和自动链接。 12345678行内式链接：[_以梦为马](http://www.jianshu.com/u/4f54fbd2ea5f)参考式链接：[_以梦为马][url]// url 为链接标记[url]: http://www.jianshu.com/u/4f54fbd2ea5f自动链接：&lt;http://www.jianshu.com/u/4f54fbd2ea5f&gt; 效果预览： 行内式链接：_以梦为马 参考式链接：_以梦为马 自动链接：http://www.jianshu.com/u/4f54fbd2ea5f 七、图片Markdown 插入图片的方式有两种，分为行内式和参考式，但两者都无法调整图片大小，因此建议在插入图片之前先调整好图片的大小 123行内式插入图片：![图片描述](http://upload.jianshu.io/users/upload_avatars/2665449/2a2822209b0d.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240)参考式插入图片：![图片描述][image][image]: http://upload.jianshu.io/users/upload_avatars/2665449/2a2822209b0d.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240 效果预览： 这是行内式插入图片： [图片上传失败…(image-62463-1514895850682)] 这是参考式插入图片：![参考式插入图片][image][image]: http://upload.jianshu.io/users/upload_avatars/2665449/2a2822209b0d.jpeg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240 八、代码代码分为行内代码和代码框 行内代码就是用两个`把需要添加行内代码的区域包起来。 1这是行内代码：`self.tableView.delegate = self` 效果预览： 这是行内代码：self.tableView.delegate = self 代码框就是用两个 12 这是代码框：12345self.tableView.delegate = self;self.tableView.dataSource = self;self.tableView.showsVerticalScrollIndicator = NO;self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone;``` 效果预览： 这是代码框：1234self.tableView.delegate = self;self.tableView.dataSource = self;self.tableView.showsVerticalScrollIndicator = NO;self.tableView.separatorStyle = UITableViewCellSeparatorStyleNone; 九、表格 表格对齐方式有三种： 居左：:---- 居中：:----:或----- 居右：----: 12345|标题|标题|标题||:---|:---:|---:||居左居左居左居左|居中|居右||居左|居中居中居中居中|居右||居左|居中|居右居右居右居右| 效果预览： 标题 标题 标题 居左居左居左居左 居中 居右 居左 居中居中居中居中 居右 居左 居中 居右居右居右居右 十、脚注使用[^]来定义脚注： 123这是一个脚注 [^1][^1]: 这是一个脚注 效果预览： 这是一个脚注 ^1 ###十一、高级技巧 HTML 标签 代码块 &lt;pre&gt;代码块&lt;/pre&gt;效果预览：代码块 粗斜体 &lt;b&gt; Markdown 加粗 *斜体* &lt;/b&gt;效果预览： Markdown 加粗 斜体 下划线 &lt;u&gt;下划线&lt;/u&gt;效果预览：下划线 Markdown 中 HTML 标签还有很多，比如&lt;kdb&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt; &lt;p&gt;等等，有兴趣的童鞋可以试试。 符号转义12\_不想这里的文本变斜体\_\*\*不想这里的文本加粗\*\* 效果预览：_不想这里的文本变斜体_**不想这里的文本加粗** 结束语：Markdown 的常用语法基本上都在这里了，另外再推荐一款免费且十分好用的 Markdown 编辑器 Mou（Mac OS X 上）。]]></content>
      <categories>
        <category>iOS 开发</category>
      </categories>
      <tags>
        <tag>iOS 开发</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
